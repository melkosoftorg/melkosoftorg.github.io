<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><meta content="text/html; charset=Windows-1251" http-equiv="content-type"><title>Способы увеличения быстродействия программ</title></head>
<body><div style="text-align: center;">
<a href="../../ktp.html">Тематический
план </a>]
[&nbsp;<span style="font-size: 12pt; line-height: 115%; font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">
<a href="z40v00.html">Оптимизация использования памяти. Оптимизация использования жесткого
диска. Оптимизация использования сети. Инструменты повышения производительности
программного обеспечения.</a></span><small><span style="font-size: 14pt; line-height: 115%; font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;"></span></small><span style="font-size: 12pt; line-height: 115%; font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">&nbsp;</span>]<br>
</div>



<div style="text-align: center;">

&nbsp;[<a href="z40v01.html"> 1</a>
] [ 2
] [ <a href="z40v03.html">3</a>
]&nbsp;









</div>



<hr>











<span style="font-size: 14pt; line-height: 115%; font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;"></span>
<div style="text-align: center;"><h2>Способы увеличения быстродействия программ</h2>


</div>
    <p>Современные ЭВМ обладают очень большой мощностью. Скорость работы процессора (ЦП) современных ЭВМ измеряется
        гигагерцами, объём оперативной памяти гигабайтами, а современные интерфейсы устройств обеспечивают скорость
        обмена данными порядка, как минимум, нескольких сотен мегабайт в секунду. Производительность, которая ещё
        несколько лет назад казалась «сказочной» в настоящее время стала нормой жизни.</p>
    <p>Однако параллельно росту мощности ЭВМ увеличивается и ресурсоёмкость приложений. У приложений совершенствуется
        функционал, интерфейс, возрастает объём обрабатываемых данных и как следствие системные требования. Поэтому
        вопрос об увеличении быстродействия приложений не теряет своей актуальности.<span></span></p>
    <p><strong>Общие вопросы быстродействия программ.</strong></p>
    <p>Быстродействие программ (ПО) зависит от многих факторов, но основными из них являются два:</p>
    <ul><li>Соотношение между реальными системными требованиями ПО и существующей аппаратной конфигурацией ЭВМ;</li><li>Алгоритмы работы ПО.</li></ul>
    <p>Если низкое быстродействие обусловлено первым фактором, то решением является модернизация аппаратной части
        (hardware). В некоторых случаях проблему можно решить также с помощью тонкой настройки hardware и операционной
        системы. Однако этот путь имеет ряд недостатков:</p>
    <ol><li>Увеличивается производительность hardware, а вовсе не быстродействие ПО;</li><li>Производительность hardware ограничена возможностями существующих в данный момент элементной базы и
            инженерных решений в данной области;</li><li>Большие финансовые затраты на модернизацию и настройку по причине высокой стоимости комплектующих ЭВМ и
            услуг специалистов требуемой квалификации.</li></ol>
    <p>По этим причинам при разработке ПО прибегают к увеличению его быстродействия с помощью различных средств
        программной инженерии. Это позволяет:</p>
    <ol><li>Обеспечить работу нового ПО на уже существующем оборудовании;</li><li>Разработать масштабируемое ПО;</li><li>Значительно уменьшить финансовые и трудовые затраты при внедрении.</li></ol>
    <p>Вместе с тем и у этого пути имеется ряд недостатков:</p>
    <ol><li>Значительно усложняется процесс разработки ПО, так как более «быстрые» алгоритмы сложнее более
            «медленных» (на пример алгоритм бинарного поиска сложнее, чем алгоритм линейного поиска);</li><li>Реализация более сложных алгоритмов, как правило, требует привлечения специалистов более высокой
            квалификации;</li><li>В случае работы с большими объёмами данных или выполнении задач требующих больших и сложных вычислений,
            ресурсоёмкость ПО всё равно остаются достаточно высокой. Несмотря, на какие либо способы увеличения
            быстродействия.</li></ol>
    <p>Таким образом, в общем случае обеспечение быстродействия ПО является комплексной задачей.</p>
    <p>Однако следует заметить, что среди существующих задач, очень немногие обладают высокой ресурсоёмкостью.
        Вследствие этого в большинстве случаев не требуется никаких действий относительно hardware и требуемого
        результата можно достичь, прибегая только к программной инженерии.</p>
    <p>Программная инженерия предоставляет несколько способов увеличения быстродействия программ. Рассмотрим их на
        примере языков программирования Delphi и Assembler.</p>
    <p><strong>Увеличение быстродействия программ.</strong></p>
    <p>Как было показано в предыдущем параграфе, можно увеличить быстродействие ПО соответствующим образом реализовав
        его алгоритмы. Количественным показателем быстродействия алгоритма (а, следовательно, и ПО) является время его
        выполнения, измеренное по специальной методике, так называемого профилирования. Таким образом, в общем случае
        выбор наиболее «быстрых» алгоритмов сводится к измерению времени их выполнения и сравнении
        полученных результатов между собой. Такой способ анализа быстродействия является наиболее объективным. На
        протяжении многих лет программистами был накоплен большой опыт профилирования, который позволяет сделать
        определённые выводы относительно возможности оптимизации быстродействия ПО ещё на стадии написания.</p>
    <p>Эти выводы были обобщены и представлены в виде определённых рекомендаций. Если программист будет следовать данным
        рекомендациям, то написанная программа вероятнее всего будет обладать большим быстродействием, чем в случае их
        игнорирования. Однако следует ещё раз подчеркнуть, что достоверные сведения о быстродействии может дать только
        профилирование. Это обусловлено тем, что быстродействие алгоритма определяет в первую очередь его конкретная
        реализация. Кроме того необходимо ещё раз отметить, что в отношении увеличения быстродействия ПО программная
        инженерия не всесильна.</p>
    <p>В чём же состоят выше упомянутые рекомендации? Их краткое содержание применительно к языку программирования
        Delphi приведено ниже.</p>
    <ol><li>При написании кода программ рекомендуется избегать процедур, состоящих из сотен строк. Практически всегда в
            них можно выделить блоки, которые лучше оформить в виде отдельной процедуры. Возможно, позже вы ей даже
            воспользуетесь где-то в другом месте. Не говоря уже о том, что это повышает понимание программы и вами, и
            другими программистами. К тому же так проще искать «узкие» места в программе.</li><li>Использование оператора case (switch) вместо многократных if… then… else (if… else). Во
            втором варианте компилятор будет выполнять проверку условия столько раз, сколько у вас вариантов. В первом
            проверка выполняется лишь однажды.</li><li>Некоторые действия могут быть довольно продолжительными, поэтому рекомендуется выносить за рамки цикла всё,
            что можно выполнить вне его, чтобы избежать большого числа повторений внутри цикла.</li><li>В циклах типа for нужно стараться, чтобы значение счетчика уменьшалось до нуля, а не наоборот —
            начиналось с нуля. Это связано с особенностями процессора. Сравнение с нулём выполняется гораздо быстрее,
            чем с другим числом.</li><li>Пользоваться типом Variant только при необходимости. Операции над этим типом сложнее, чем, например, над
            Integer или String.</li><li>Не злоупотреблять «программированием на компонентах». В частности не использовать компонент
            TTreeView для хранения древовидных структур данных — он работает очень медленно и предназначен только
            для визуального отображения. В случае работы со структурами данных лучше использовать алгоритмы, созданные
            самостоятельно на основе фундаментальных.</li><li>Сохранение и загрузка свойств компонентов с помощью методов ReadComponent и WriteComponent работает довольно
            медленно, поэтому по возможности рекомендуется сохранять и восстанавливать состояние программы между
            сеансами при помощи других способов.</li><li>Заменить простой в реализации алгоритм на более сложный, но с большим быстродействием. Например, если
            заранее известно, что в списке для поиска будет много элементов, лучше его отсортировать и применять
            бинарный поиск вместо линейного.</li><li>В критических с точки зрения быстродействия местах программы делать вставки на ассемблере. Команды
            ассемблера напрямую транслируются в машинный код. Таким образом, в отличие от высокоуровневых языков при
            компиляции отсутствует проблема синхронизации и ряд других негативных обстоятельств.</li></ol>
    <p>Для других языков программирования вышеприведённый список может несколько отличаться, в частности отсутствием
        поддержки ассемблера и как следствие возможности оптимизации с его помощью (Java, Visual C# и др.).</p>
    <p>Особо следует отметить, что рекомендации 3 и 4 применяются не только для языков высокого уровня, но и для
        ассемблера. Помимо вышеуказанных для увеличения быстродействия программ написанных на ассемблере, в том числе и
        вставок, существуют следующие рекомендации:</p>
    <ol><li>Замещение универсальных инструкций на учитывающие конкретную ситуацию, например, замена умножения на степень
            двойки на команды сдвига (отказ от универсальности).</li><li>Уменьшение количества передач управления в программе: за счет преобразования подпрограмм в макрокоманды для
            непосредственного включения в машинный код; за счет преобразования условных переходов так, чтобы условие
            перехода оказывалось истинным значительно реже, чем условие для его отсутствия; перемещение условий общего
            характера к началу разветвленной последовательности переходов; преобразование вызовов, сразу за которыми
            следует возврат в программу, в переходы («сращивание хвостов» и «устранение рекурсивных
            хвостов») и т.д.</li><li>Максимальное использование всех доступных регистров за счет хранения в них рабочих значений всякий раз,
            когда это возможно, чтобы минимизировать число обращений к памяти, упаковка множественных значений или
            флагов в регистры и устранение излишних продвижений стека (особенно на входах и выходах подпрограмм).</li><li>Использование специфических для данного процессора инструкций, например, инструкции засылки в стек
            непосредственного значения, которая имеется в процессоре 80286 и более поздних. Другие примеры –
            двухсловные строковые инструкции, команды перемножения 32-разрядных чисел, деление 64-разрядного на
            32-разрядное число и умножение на непосредственное значение, которые реализованы в процессорах 80386 и
            80486. Программа должна, разумеется, вначале определить, с каким типом процессора она работает!</li></ol>
    <p><strong>Заключение.</strong></p>
    <p>Методы оптимизации быстродействия, рассмотренные в этой лекции, были выработаны и проверены не одним поколением
        программистов и уже стали классическими. В то же время информационные технологии, в частности технологии
        программирования, постоянно развиваются. Появляются новые технологии, старые – модернизируются или уходят
        в прошлое. Растёт производительность аппаратной части ЭВМ и параллельно с этим растёт сложность и ресурсоёмкость
        выполняемых ими задач.</p> </body></html>