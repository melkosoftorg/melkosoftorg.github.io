<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>
<meta content="text/html; charset=Windows-1251" http-equiv="content-type"><title>Кросс-платформенные технологии</title></head><body>
<div style="text-align: center;">
<a href="../../ktp.html">Тематический
план </a>]
[&nbsp;<span style="font-size: 12pt; line-height: 115%; font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;"> </span><a href="z42v00.html"><span style="font-size: 14pt; line-height: 115%; font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">Аппаратно-программные платформы серверов и рабочих
станций.</span></a><span style="font-size: 12pt; line-height: 115%; font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;"></span>]<br>
</div>







<div style="text-align: center;">

&nbsp;[ <a href="z42v01.html">1</a>
] [ 2
] [ <a href="z42v03.html">3</a>
]&nbsp;









</div>







<hr>













<span style="font-size: 14pt; line-height: 115%; font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;"></span>
<div style="text-align: center;">

<p class="MsoNormal" style="line-height: normal;">

</p>
<p class="MsoNormal" style="margin-left: 0cm; text-align: center; text-indent: 0cm;"><big style="font-weight: bold;">Кросс-платформенные
технологии</big><span style="" lang="EN-US"><o:p></o:p></span></p>


<p class="MsoNormal" style="line-height: normal;"><b><span style="font-size: 13.5pt; font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;"><o:p></o:p></span></b></p>






</div>








&nbsp;
<br>






















<p class="MsoNormal" style="text-align: justify; line-height: normal;">

</p>


<p class="MsoNormal" style="text-align: justify; line-height: normal;">

</p>

<p class="MsoNormal" style="text-align: justify; line-height: normal;">

</p>
<p style="text-align: justify;">Кросс-платформенные технологии обеспечивают
совместную эксплуатацию различных аппаратных и программных платформ в интересах
организаций-потребителей.</p>


<h4 style="text-align: justify;">Основные архитектуры программного обеспечения</h4>


<h5 style="text-align: justify;">Автономные (standalone) приложения</h5>


<p style="text-align: justify;">Такими могут быть, как правило, сервисные
программы, <span class="keyword">системные утилиты</span>, текстовые и
графические редакторы, компиляторы, достаточно простые корпоративные программы.
Развитая корпоративная информационная система, как правило, не может состоять
из отдельных, не связанных между собой компонентов.</p>


<h5 style="text-align: justify;">Двухзвенная архитектура
"клиент-сервер"</h5>


<p style="text-align: justify;">Эта архитектура получила распространение с начала
1990-х годов на фоне роста рынка персональных компьютеров и снижения спроса на
мэйнфреймы. В архитектуре "клиент-сервер" программное обеспечение
разделено на две части -клиентскую часть и серверную часть. Задача
клиентской-части (программы-клиента) состоит во взаимодействии с пользователем,
передаче пользовательского запроса серверу, получение запроса от серверной
части (программы-сервера) и представление его в удобном для пользователя виде.
Программа-сервер же обрабатывает запросы клиента и выдает ответы. Классические
примеры: <span class="texample">Web</span> -технологии (клиент-браузер, сервер- <span class="texample">Web</span> -сервер), работа с распределенными <span class="texample">СУБД</span> (клиент - специальная программа, сервер - сервер
базы данных). Развитие архитектуры "клиент-сервер", а особенно
появление современных графических интерфейсов, привело сначала к появлению
разновидности архитектуры клиент-сервер, называемой <i>"архитектура с толстым
клиентом"</i>.Здесь логика представления данных и бизнес-логика
размещаются на клиенте, который (скажем, в случае, когда сервером является <span class="texample">СУБД</span> ) общается с логикой хранения и накопления данных на
сервере, используя язык структурированных запросов <i>SQL</i>.Однако
необходимость установки "<span class="keyword">толстых клиентов</span>",
требующих значительного количества специальных библиотек и специальной
настройки окружения, на большое число пользовательских компьютеров с различными
операционными средами, как правило вызывает массу проблем. Как альтернатива
поэтому возникла также двухзвенная архитектура <i>"с тонким клиентом"</i>.При
этом в идеале программа-клиент реализует лишь графический интерфейс
пользователя <i>(GUI) </i>и передает/принимает запросы, а вся бизнес-логика
выполняется сервером. В идеале клиентом является просто интернет-браузер,
который имеется в стандартной операционной среде любого пользовательского
компьютера и не требует специальной настройки, установки специализированного ПО
и т.п. К сожалению, такая схема тоже не свободна от недостатков, хотя бы уже
потому, что серверу приходится брать на себя иногда не свойственные для него
функции реализации бизнес-логики приложения (например, серверу <span class="texample">СУБД</span> приходится выполнять расчеты!)</p>


<h5 style="text-align: justify;">Многозвенная (multitiered) архитектура</h5>


<p style="text-align: justify;">Начало процессу развития корпоративного
программного обеспечения в <span class="keyword">многозвенной архитектуре</span>
было положено еще в рамках технологии "клиент/сервер". В них наряду с
клиентской частью приложения и сервером баз данных появились серверы приложений
<i>(Application Servers)</i>.В идеале:</p>


<ul type="disc">
<li class="MsoNormal" style="line-height: normal;"><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">программа-клиент реализует <i>GUI</i>,передает
     запросы серверу приложений и принимает от него ответ,<o:p></o:p></span></li><li class="MsoNormal" style="text-align: justify; line-height: normal;"><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">сервер
     приложений реализует бизнес-логику и обращается с запросами к серверу
     "третьего уровня" (например, серверу базы данных за данными),<o:p></o:p></span></li><li class="MsoNormal" style="text-align: justify; line-height: normal;"><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">сервер
     третьего уровня обслуживает запросы сервера приложений.<o:p></o:p></span></li>
</ul>


<p style="text-align: justify;">Программа-клиент, таким образом, может быть
"тонкой". Преимущества такой архитектуры очевидны:</p>


<ul type="disc">
<li class="MsoNormal" style="text-align: justify; line-height: normal;"><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">изменения
     на каждом из звеньев можно осуществлять независимо;<o:p></o:p></span></li><li class="MsoNormal" style="text-align: justify; line-height: normal;"><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">снижаются
     нагрузки на сеть, поскольку звенья не обмениваются между собой большими
     объемами информации;<o:p></o:p></span></li><li class="MsoNormal" style="text-align: justify; line-height: normal;"><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">обеспечивается
     масштабирование и простая модернизация оборудования и программного
     обеспечения, поддерживающего каждое из звеньев, в том числе обновление
     серверного парка и терминального оборудования, <span class="texample">СУБД</span>
     и т.д.;<o:p></o:p></span></li><li class="MsoNormal" style="text-align: justify; line-height: normal;"><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">Приложения
     могут создаваться на стандартных языках третьего или четвертого поколения
     ( <i>Java</i>, <span class="texample">C/C++</span> ).<o:p></o:p></span></li>
</ul>


<p style="text-align: justify;">Следующий логический шаг - дальнейшее увеличение
числа звеньев, причем возрастет не только за счет разбиения, когда
"утоньшается" каждое из известных технических звеньев, но вся
бизнес-модель строится как многозвенная. Современные корпоративные программные
системы представляют собой, как правило, сложные системы взаимодействующих
между собой на разных уровнях компонентов, каждые из которых могут являться клиентами
для одних компонентов и серверами для других.</p>


<p style="text-align: justify;">Основной проблемой систем, основанных на
двухзвенной архитектуре "клиент-сервер", или тем более на <span class="keyword">многозвенной архитектуре</span>, является то, что от них
требуется мобильность в как можно более широком классе аппаратно-программных
сред. Даже если ограничиться <i>UNIX-</i> ориентированными локальными сетями, в
разных сетях применяется разная аппаратура и протоколы связи. Попытки создания
систем, поддерживающих все возможные протоколы, приводит к их перегрузке сетевыми
деталями в ущерб функциональности. Еще более сложный аспект этой проблемы
связан с возможностью использования разных представлений данных в разных узлах
неоднородной локальной сети. В разных компьютерах может существовать различная
адресация, представление чисел, кодировка символов и т.д. Это особенно
существенно для серверов высокого уровня: телекоммуникационных, вычислительных,
баз данных.</p>


<p style="text-align: justify;">Общим решением проблемы мобильности такого рода
систем является использование технологий, реализующие протоколы удаленного
вызова процедур <i>(RPC </i>- <i>Remote Procedure Call) </i>стандартизованным и
платформо-независимым способом. При использовании таких технологий обращение к
сервису в удаленном узле выглядит как обычный вызов процедуры (методов
удаленных объектов). Средства <i>RPC</i>,в которых, естественно, содержится вся
информация о специфике аппаратуры локальной сети и сетевых протоколов,
переводит вызов в последовательность сетевых взаимодействий. Тем самым,
специфика сетевой среды и протоколов скрыта от прикладного программиста.</p>


<p style="text-align: justify;">При вызове удаленной процедуры, программы <i>RPC </i>производят
<span class="keyword">преобразование форматов данных</span> клиента в
промежуточные машинно-независимые форматы, и затем преобразование в форматы
данных сервера. При передаче ответных параметров производятся обратные преобразования.
Таким образом, если система реализована на основе стандартного пакета <i>RPC</i>,она
может быть легко перенесена в любую <span class="keyword">открытую среду</span>.</p>


<h4 style="text-align: justify;"><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">Технология
CORBA<o:p></o:p></span></h4>


<p style="text-align: justify;"><i>CORBA (Common Object Request Broker
Architecture) </i>- это набор <span class="keyword">открытых спецификаций</span>
интерфейсов, определяющий архитектуру технологии межпроцессного и
платформо-независимого манипулирования объектами. Разработчиками данных
интерфейсов являются <i>OMG </i>и <i>X/Open</i>.</p>


<p style="text-align: justify;"><i>Object Management Group, Inc. (OMG) </i>- это
интернациональная организация, основана в 1989 г., состоящая более чем из 800
членов: поставщиков информационных систем, разработчиков программного
обеспечения и пользователей. <i>OMG </i>продвигает теорию и практику
объектно-ориентированной технологии в область практической разработки
программного обеспечения. Этот процесс включает в себя разработку промышленных
стандартов и спецификаций управления объектами с целью создания общей базы для
разработки программного обеспечения. Первоочередными задачами являются:
повторное использование, переносимость и <span class="keyword">интероперабельность</span>
объектно-ориентированного программного обеспечения в распределенных,
гетерогенных средах. Поддержка данных стандартов создает возможность
разрабатывать гетерогенные приложения, работающие на всех основных платформах и
операционных системах.</p>


<p style="text-align: justify;"><i>X/Open </i>- независимая всемирная открытая
организация, поддерживаемая большинством крупнейших поставщиков информационных
систем, пользовательских организаций и компаний-производителей программного
обеспечения. <i>X/Open </i>разрабатывает на основе существующих и создающихся
стандартов всеобъемлющее и интегрированное системное окружение - <i>Common
Applications Environment (CAE)</i>.Компоненты <i>CAE </i>определены в
стандартах <i>X/Open CAE</i>.Основная цель <i>CAE </i>- создание пакетов
программных интерфейсов <i>(API) </i>которые могут применяться на практике с
сохранением максимальной переносимости на уровне исходных кодов программ. <i>API
</i>также повышают уровень взаимодействия приложений при помощи предоставления
определений и ссылок на протоколы и их профили.</p>


<p style="text-align: justify;">Вышеназванные спецификации тщательно тестируются,
выдержавшим тестирование присваивается <i>X/Open trademark (XPG brand)</i>,лицензированная
<i>X/Open</i>.</p>


<p style="text-align: justify;">Концептуальной инфраструктурой, на которой
базируются все спецификации <i>OMG</i>,является <i>Object Management
Architecture (OMA)</i>.В состав <i>OMA </i>входят разнообразные
стандартизованные или в настоящий момент стандартизируемые <i>OMG </i>службы,
сервисы, программные образцы и шаблоны <i>(CORBAservices, horizontal and
vertical CORBAfacilities)</i>,язык определения интерфейсов распределенных объектов
<i>IDL (Interface Definition Language)</i>,стандартизованные или
стандартизируемые отображения <i>IDL </i>на языки программирования и, наконец,
объектная модель <i>CORBA</i>.</p>


<p style="text-align: justify;">Реализовать технологию в соответствии со
спецификациями может кто угодно. Созданные программные продукты, естественно,
уже не являются открытыми, а становятся коммерческими продуктами.</p>


<h5><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">Архитектура CORBA<o:p></o:p></span></h5>


<p style="text-align: justify;"><i>CORBA </i>определяет, каким образом
программные компоненты, распределенные по сети, могут взаимодействовать друг с
другом вне зависимости от окружающих их операционных систем и языков
реализации. Центральным элементом архитектуры <i>CORBA </i>является <i>ORB
(Object Request Broker) </i>- программное обеспечение, обеспечивающее связь
между объектами, в том числе позволяющее</p>


<ul type="disc">
<li class="MsoNormal" style="text-align: justify; line-height: normal;"><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">найти
     удаленный объект по Объектной Ссылке <i>(IOR </i>- <i>Interoperable Object
     Reference)</i>,<o:p></o:p></span></li><li class="MsoNormal" style="text-align: justify; line-height: normal;"><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">вызвать
     метод удаленного объекта, передав ему входные параметры <i>(marshaling
     parameters)</i>,<o:p></o:p></span></li><li class="MsoNormal" style="text-align: justify; line-height: normal;"><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">получить
     возвращаемое значение и выходящие параметры <i>(unmarshaling parameters)</i>.<o:p></o:p></span></li>
</ul>


<p style="text-align: justify;">Тем самым <i>ORB </i>является связующим звеном
между распределенными частями основанной на технологии <i>CORBA </i>системы,
позволяя одной части системы не заботиться о физическом расположении других
частей (объектов) системы. На рынке представлены <i>ORB </i>разных
производителей (например, <i>VisiBroker, WebLogic)</i>,но все они соответствуют
единой спецификации <i>CORBA</i>. Поэтому в принципе <i>CORBA </i>позволяет
строить распределенные системы, одновременно используя <i>ORB </i>разных
производителей, и строя систему одновременно на различных платформах и
различных сетевых протоколах (это в терминологии <i>CORBA </i>называется
интероперабельностью - <i>interoperability)</i>.В архитектуре <i>CORBA </i>каждый
объект, методы которого доступны другим объектам (обычно его называют <span class="texample">CORBA</span> -объектом) имеет уникальную по всей доступной сети
Объектную Ссылку <i>(IOR </i>- <i>Interoperable Object Reference)</i>,по
которой к нему можно обратиться. Искать <span class="texample">CORBA</span>
-объекты можно как по <span class="texample">IOR</span>, так и по символическим
именам, если они зарегистрированы (обычно при создании) в специальном сервисе
имен <i>(NameService)</i>.Для обращения к методам <span class="texample">CORBA</span>
-объекта последний имеет открытый для всех остальных <span class="texample">CORBA</span>
-объектов интерфейс. Интерфейсы <span class="texample">CORBA</span> -объектов
принято описывать на специальном, определенном спецификацией <i>CORBA </i>языке
<i>IDL (Interface Definition Language)</i>. Производители <i>ORB </i>поставляют
вместе с <i>ORB </i>также и утилиты, преобразующие описания интерфейсов <span class="texample">CORBA</span> -объектов в конструкции соответствующих языков
программирования.</p>


<p style="text-align: justify;">Основой <span class="keyword">интероперабельности</span>
является протокол <i>GIOP </i>- <i>General inter-ORB Protocol</i>,предназначенный
для связи между объектами и <i>ORB </i>в сети. Стандартизация коммуникационного
протокола позволяет разработчикам различных частей корпоративной системы
совершенно не заботиться об используемых <i>ORBах </i>в других частях ( <span class="keyword">ORB</span> доменах)</p>


<p style="text-align: justify;">системы. Почти все современные <span class="texample">ORBbi</span> строятся на основе <i>IIOP - Internet inter-ORB
Protocol </i>(это версия общего протокола <i>GIOP</i>,предусматривающая
использование в качестве транспортного протокола <i>TCP/IP)</i>.</p>


<p style="text-align: justify;">Спецификация <i>CORBA </i>предусматривает также
ряд стандартизованных сервисов <i>(CORBA Services) </i>и горизонтальных и
вертикальных Общих Средств <i>(Common Facilities)</i>. Сервисы представляют
собой обычные <span class="texample">CORBA</span> -объекты со стандартизованными
(и написанными на <span class="texample">IDL</span> ) интерфейсами. К таким
сервисам относится, например, уже упомянутый сервис имен <i>NameService</i>,сервис
сообщений, позволяющий <span class="texample">CORBA</span> -объектам обмениваться
сообщениями, сервис транзакций, позволяющий <span class="texample">CORBA</span>
-объектам организовывать транзакции. В реальной системе не обязательно должны
присутствовать все сервисы, их набор зависит от требуемой функциональности. На
сегодня разработано всего 14 объектных сервисов.</p>


<p style="text-align: justify;">Между объектными сервисами и общими средствами <i>CORBA
</i>нет четкой границы. Последние тоже представляют собой <span class="texample">CORBA</span>
-объекты со стандартизованными интерфейсами. <i>Common Facilities </i>делятся
на горизонтальные (общие для всех прикладных областей) и вертикальные (для
конкретной прикладной области). Например, разработаны <i>Common Facilities </i>для
медицинских организаций, для ряда производств и т.п.</p>


<h4 style="text-align: justify;"><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">Технология
SOAP<o:p></o:p></span></h4>


<p style="text-align: justify;">Основное содержание <i>SOAP (Simple Object Access
Protocol) </i>состоит в обмене сообщениями между удаленными объектами по
протоколу <i>HTTP </i>с использованием <i>XML </i>в качестве транспорта.
Спецификация <i>SOAP </i>поддерживается и развивается консорциумом <i>W3C </i>(см.
http : //www .w3.org/TR/SOAP/).</p>


<p style="text-align: justify;">По функциональным возможностям технология <i>SOAP
</i>весьма сходна с первыми версиями <i>CORBA</i>.Однако у нее есть одно
несомненное достоинство: простота. На уровне передачи данных в глобальных
сетях, между предприятиями, где большой сложности взаимодействие не предвидится
- это оптимальное решение по соотношению время разработки/функциональность.
Существуют многочисленные мосты <i>(CORBA/SOAP, C++/SOAP, Java/SOAP)</i>.</p>


<h4 style="text-align: justify;"><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">Технологии COM/DCOM и .NET<o:p></o:p></span></h4>


<p style="text-align: justify;"><i>COM (Component Object Model) </i>- это
стандарт <i>Microsoft</i>,определяющий структуру и взаимодействие компонентов
программного обеспечения в современных операционных системах <i>MS Windows</i>.Архитектура
современных <span class="texample">Windows</span> -приложений основана на <i>COM</i>:мир
этих приложений - это мир <span class="texample">COM</span> -компонент.
Компоненты <i>COM </i>обладают уникальностью и предоставляют другим компонентам
<i>COM </i>стандартным образом описанные интерфейсы, позволяющие получить доступ
к методам этих компонентов. <i>COM </i>определяет механизм связи только между
локальными (т.е. находящимися на том же компьютере) компонентами.</p>


<p style="text-align: justify;"><i>DCOM (Distributed Component Object Model) </i>-
это распределенная версия <span class="texample">COM</span>, обеспечивающая
механизм связи между удаленным <span class="texample">COM</span> -компонентами
(т.е. находящимися на разных компьютерах, но в среде <i>MS Windows)</i>.Фактически
<i>DCOM </i>это <i>COM </i>с добавленным к последнему механизмом <i>RPC (remote
procedure call)</i>.Сходную функциональность взаимодействия удаленных <span class="texample">Windows</span> -приложений можно получить с использованием
активно развиваемой в последнее время фирмой <i>Microsoft </i>технологии <i>.NET</i>.Важно
подчеркнуть, что упомянутые в данном разделе технологии относятся исключительно
к операционным системам <i>Microsoft</i>.</p>


<h4 style="text-align: justify;"><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">Технология
Enterprise Java Beans<o:p></o:p></span></h4>


<p style="text-align: justify;">Архитектура <i>EJB </i>- это <span class="keyword">компонентная
архитектура</span>, предназначенная для разработки и развертывания
распределенных бизнес-приложений, основанных на компонентах. Приложения,
созданные с помощью архитектуры <i>EJB</i>,являются масштабируемыми,
ориентированными на транзакции и безопасными при работе в многопользовательском
режиме. Эти приложения, однажды написанные, могут затем быть развернуты на
любой серверной платформе, поддерживающей спецификацию <i>EJB</i>.Это
определение можно немного упростить при помощи описанных ранее понятий. <i>Enterprise
Java Beans </i>- это стандартная модель серверных компонентов для мониторов
компонентных транзакций. <i>Enterprise </i><span class="texample">Bean</span>
-компоненты являются <i>Java (J2EE) </i>объектами, реализующими технологию <i>Enterprise
Java Beans (EJB)</i>.Каждый такой компонент выполняется под управлением сервера
приложений, который должен соответствовать так называемой спецификации <i>EJB-</i>
контейнера, т.е. поддерживать соответствующий <i>API </i>- <i>EJB Container API
</i>(обычно сервер приложений в таком случае называют <span class="texample">EJB</span>
-контейнером). <span class="texample">EJB</span> -контейнер предоставляет
компонентам <i>(Enterprise Beans) </i>сервисы системного уровня (например,
многопоточность, механизм транзакций), оставаясь при этом прозрачным для
разработчика приложений. Эти системные сервисы позволяют разработчику быстро
создавать и разворачивать <i>Enterprise </i><span class="texample">Bean</span>
-компоненты: контейнер как бы "закрывает" от разработчика <i>EJB </i>все
сложности системного характера (например, уже упомянутые многопоточность или
механизм транзакций), позволяя ему сосредоточиться исключительно на
бизнес-логике приложения. <i>Enterprise </i><span class="texample">Bean</span>
-компонент - это объект требуемого класса, описанного на языке программирования
<i>Java</i>,расположенный на стороне сервера приложений и выполняющий часть
бизнес-логики приложения (этим занимается собственно код компонента,
осуществляющий задачи приложения). Например, в приложении контроля инвентаря, <i>Enterprise
</i><span class="texample">Bean</span> -компоненты могут реализовывать
бизнес-логику приложения в методах <i>checkInventoryLevel() </i>и <i>orderProduct()</i>.
Вызывая эти методы, удаленные клиенты могут получать доступ к инвентарным
сервисам приложения.</p>


<p style="text-align: justify;">Существует несколько причин, по которым
использование <i>Enterprise </i><span class="texample">Bean</span> -компонентов
упрощает разработку больших распределенных корпоративных приложений.</p>


<ul type="disc">
<li class="MsoNormal" style="text-align: justify; line-height: normal;"><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">Первой
     причиной является тот факт, что <span class="texample">EJB</span> -контейнер
     предоставляет все необходимые сервисы системного уровня, позволяя
     разработчику <i>Bean-</i> компонента сконцентрироваться на решении
     бизнес-задач. Именно <i>EJB-</i> контейнер (а не <span class="texample">Bean</span>
     -разработчик) является ответственным за обеспечение работоспособности
     таких механизмов, как транзакции и авторизация доступа.<o:p></o:p></span></li><li class="MsoNormal" style="text-align: justify; line-height: normal;"><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">Вторым
     преимуществом <span class="texample">EJB</span> -компонентов является их
     расположение на сервере. Вследствие этого, разработчикам клиентов не
     приходится включать бизнес-логику в состав клиентского приложения - в
     таком коде не должно быть функциональности, реализующей бизнес-правила или
     доступ к базам данных. В результате, клиентское приложение получается
     гораздо меньшего размера, что очень важно для выполнения на устройствах с
     ограниченными ресурсами.<o:p></o:p></span></li><li class="MsoNormal" style="text-align: justify; line-height: normal;"><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">Третьим
     преимуществом <i>Enterprise </i><span class="texample">Bean</span>
     -компонент является их переносимость, сборщик приложений может собирать
     новые приложения из уже существующих <span class="texample">Bean</span> -компонент.
     Такие приложения могут быть запущены на любом <span class="texample">J2EE</span>
     -совместимом сервере.<o:p></o:p></span></li>
</ul>


<p style="text-align: justify;">Следует задуматься об использовании <i>Enterprise
</i><span class="texample">Bean</span> -компонент, если ваше приложение отвечает
хотя бы каким-то требованиям из перечисленных ниже.</p>


<ul type="disc">
<li class="MsoNormal" style="text-align: justify; line-height: normal;"><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">Приложение
     должно быть масштабируемым. Чтобы подстроится к растущему количеству
     пользователей, разработчикам, возможно, придется распределить компоненты
     приложения между несколькими серверами. Вне зависимости от компоновки
     компонент на серверах, их расположение остается прозрачным для клиентов.<o:p></o:p></span></li><li class="MsoNormal" style="text-align: justify; line-height: normal;"><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">Требуется
     механизм транзакция для обеспечения целостности данных. <i>Enterprise </i><span class="texample">Bean</span> -компоненты поддерживают транзакции - механизм,
     управляющий одновременным доступом к разделяемым объектам.<o:p></o:p></span></li><li class="MsoNormal" style="text-align: justify; line-height: normal;"><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">У
     приложения будет множество клиентов. Требуется всего несколько строк кода
     в клиентских приложениях для нахождения <i>Enterprise </i><span class="texample">Bean</span> -компонент. Клиентские приложения могут быть
     небольшими, многочисленными и различными.<o:p></o:p></span></li>
</ul>


<p style="text-align: justify;">На сегодняшний день корпорацией <i>Sun
Microsystems </i>было выпущено пять спецификации <i>EJB </i>- <i>EJB 1.0, EJB
1.1, EJB 2.0, EJB 2.1 и EJB 3.0</i>. В спецификации <i>EJB 1.0 </i>были впервые
описаны сеансовые <i>(session bean) </i>и объектные <i>(entity bean) </i>компоненты.
Спецификация <i>EJB 1.1 </i>расширяет спецификацию <i>EJB 1.0</i>.В <i>EJB 2.0 </i>были
добавлены компоненты, управляемые асинхронными сообщениями <i>JMS (Java
Messaging Service)</i>,а также <i>EJB Query Language (EQL) </i>- язык запросов.
В <i>EJB 2.1 </i>был модифицирован и улучшен <span class="texample">EQL</span>,
добавлена возможность вызова объектных компонент через <i>HTTP/SOAP</i>.Также
компоненты, управляемые сообщениями, смогли принимать сообщения не только по
протоколу <i>JMS</i>,но и по другим протоколам. Последняя на данный момент
версия <i>EJB </i>- <i>EJB 3.0</i>.В ней модифицированы механизмы описания
компонент (вместо <span class="texample">XML</span> -файла - метаданные), а сам
процесс разработки переведен на <i>JAVA 5.0</i>.</p>


<h4 style="text-align: justify;"><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">Технология
JINI<o:p></o:p></span></h4>


<p style="text-align: justify;"><i>Jini </i>представляет собой технологию
создания распределенных систем, ориентированную исключительно на использование <i>Java</i>.В
настоящий момент <i>Jini </i>является торговой маркой <i>Sun Microsystems</i>.</p>


<p style="text-align: justify;">Технология <i>Jini </i>состоит из трех основных
компонентов:</p>


<ul type="disc">
<li class="MsoNormal" style="text-align: justify; line-height: normal;"><b><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">Инфраструктура</span></b><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">.Включает в себя
     распределенную систему защиты, которая интегрирована в <i>RMI (Remote
     Method Invocation)</i>,представляющий собой механизм для нахождения,
     активации и захвата объектов <i>сервисов</i>.Инфраструктура состоит из
     объектов, использующих протоколы для передачи информации во время
     транзакций. На уровне транзакций происходят запросы и передача информации.
     Для поиска объектов и передачи информации между ними используется менеджер
     транзакций <i>(transaction manager)</i>.Обязанности менеджера транзакций
     этим не ограничиваются. Помимо этого, он обязан координировать работу
     системы во время выполнения запросов и передавать найденую по этим
     запросам информацию;<o:p></o:p></span></li><li class="MsoNormal" style="text-align: justify; line-height: normal;"><b><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">Модель
     программирования </span></b><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">использует
     язык программирования <i>Java </i>и компоненты <i>JavaBeans </i>для
     организации интерфейсов транзакций и написания приложений, использующих
     модель распределенных вычислений;<o:p></o:p></span></li><li class="MsoNormal" style="text-align: justify; line-height: normal;"><b><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">Сервисы
     </span></b><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">имеют
     определенный унифицированный интерфейс и набор методов, посредством
     которых возможно общение с ними. Реализация сервисов не требует
     использования программной модели <i>Jini</i>,однако эта модель необходима
     при взаимодействии сервисов между собой. Причем сервисы в этом случае
     чем-то подобны процессам в <i>Unix</i>.Каждый сервис может использовать
     другие сервисы для выполнения своих задач, а также порождать новые
     сервисы, специализирующиеся на решении определенных вопросов.<o:p></o:p></span></li>
</ul>


<p style="text-align: justify;">В отличие от <i>EJB</i>,технология <i>JINI </i>не
требует наличия специальных серверов приложений. Кроме того, если модель
использования <i>EJB </i>принципиально двух- или трехзвенна (существует клиент,
запрашивающий методы <i>EJB</i>,работающий под управлением контейнера, и, как
правило, сервер, например, <span class="texample">СУБД</span>, к которому
обращается в процессе работы <i>EJB</i>,причем иерархия запросов в этой схеме
строго задана), то в модели <i>JINI </i>все сервисы абсолютно равноправны между
собой (каждый из них может быть как сервером, так и клиентом к любому). Такая
"равноправная" архитектура взаимосвязей называется <i>одноранговой
(peer-to-peer)</i>.В модели <i>JINI </i>сервисы представляют, таким образом,
своего рода "интеллектуальные устройства" (можно представить себе в
качестве примера сервис печати), общающиеся между собой по стандартизованным
правилам, имеющие стандартизованные имена, общую модель безопасности и т.п.
Такой <span class="keyword">универсум</span> сервисов-"интеллектуальных
устройств" <i>JINI </i>принято называть <i>JINI Federation</i>."Интеллектуальные
устройства" могут сами добавлять себя в этот <span class="keyword">универсум</span>
(например, сервис печати при включении принтера) или, наоборот, выходить из
него (сервис печати при выключении принтера), без необходимости какого-либо
"внешнего" воздействия (диспетчера, оператора и т.п.)</p>


<p style="text-align: justify;">Поиск сервиса, который может выполнить определенную
задачу, происходит приблизительно по такому сценарию.</p>


<ul type="disc">
<li class="MsoNormal" style="text-align: justify; line-height: normal;"><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">Объект
     клиента посредством провайдера сервисов <i>(Service Provider) - </i>объекта,
     "специализирующегося" на поиске объектов-сервисов, - находит
     необходимый сервис.<o:p></o:p></span></li><li class="MsoNormal" style="text-align: justify; line-height: normal;"><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">При
     нахождении необходимого объекта, клиент исследует его, исходя из
     параметров соответствующего запроса. Это исследование найденого сервиса
     происходит посредством проверки его свойств.<o:p></o:p></span></li><li class="MsoNormal" style="text-align: justify; line-height: normal;"><span style="font-family: &quot;Times New Roman&quot;,&quot;serif&quot;;">После
     этого подходящий сервис копируется <i>на локальный диск компьютера клиента</i>.Последующие
     действия с ним происходят, как с локальным объектом, с помощью вызова его
     методов, что в некоторой мере разгружает трафик.<o:p></o:p></span></li>
</ul>


<p style="text-align: justify;">Технология <i>Jini </i>разрабатывалась с целью
создания системы, которая бы требовала к себе мало внимания при обслуживании,
успевала за постоянным изменением и наращиванием системы и обеспечивала
постоянную доступность сервисов посредством Интернета. Безопасность системы и
конфиденциальность информации передаваемой в сети достигается за счет
распределенной системы безопасности. Наращиваемость систем возможна за счет
добавления новых, наследования и изменения старых сервисов, доступных
посредством интернет. Постоянная доступность становится возможной за счет
рассредоточенности системы, в которой можно изменять приложения беспрерывно,
так, что сервис будет доступен из Интернета постоянно.</p>



  

</body></html>