<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><meta content="text/html; charset=Windows-1251" http-equiv="content-type"><title>Утилиты</title></head><body><a href="z27v00.html">нахад</a><br><br>

<h2 style="text-align: justify;">Утилиты</h2>


<p style="text-align: justify;">В UNIX входит немало программ, при помощи которых
можно решать разнообразные инструментальные (т. е. связанные с работой самой
системы) задачи. Это так называемые системные утилиты. Они используются в
первую очередь самой системой (причем вызываются, как правило, из командных
сценариев, о которых рассказывается в лекции 11) и системным администратором -
для управления системой. Однако и пользователь, не обладающий правами
администратора, вполне может задействовать системные утилиты, если они помогают
ему в работе, а системе не мешают (например, создавать файловую систему на
дискете, просматривать состояние системы или демонов и т. п.).</p>

<p style="text-align: justify;">Слово "утилиты" (utilities) буквально
означает "полезности". Утилиты - это программы, которые могут
понадобиться при решении всевозможных задач. Если есть высокая вероятность, что
некоторая программа может понадобиться более чем одному пользователю для
решения более чем одной задачи, то ее стоит включить в систему. Таких пользовательских
утилит в UNIX еще больше, чем системных (чем определенно нарушается принцип У
контекста; о том, как устранить это нарушение, речь пойдет в лекции 6).
Множество пользовательских утилит занимается преобразованием текста, так как
текстовый файл - универсальное пространство для создания умопостижимых моделей.
Немало утилит помогает при разработке решений: компиляторы, отладчики,
редакторы диаграмм, трассировщики и т. д. Почти всеми пользовательскими
утилитами пользуется система, потому что при проективном подходе вообще
невозможно провести четкую границу между системным и пользовательским
наполнением. К обеим категориям, например, относятся утилиты для работы с
файлами и файловой системой или интерпретатор командной строки (shell). На
shell написаны все системные сценарии, поскольку он представляет собой еще и
удобный высокоуровневый язык программирования.</p>

<h1 style="text-align: justify;"><span style="font-size: 14pt; line-height: 115%;">Программные
продукты и пакеты<o:p></o:p></span></h1>

<p style="text-align: justify;">Понятно, что на всякую прикладную область утилит
не напасешься. Чем сложнее и дальше от инструментальной области задача, тем
меньше смысла включать инструменты ее решения в систему. Тем не менее, раз уж
задача есть, значит, кому-то придется ее решать. Такие специализированные
наборы программ хотелось бы иметь если не в самой системе, то где-то
"рядом", чтобы, как только появится пользователь со своими задачами,
предоставить ему средства их решения. И уж конечно метаинструментарий -
средства изготовления таких инструментов - в системе должен быть
(метаинструментарий - это средства программирования и вообще разработки программ:
языки программирования, общие, интерфейсные и предметно-ориентированные
библиотеки, RAD - средства быстрой разработки и т. п.). Такой набор программ
для решения прикладных задач называется программным продуктом.</p>

<p style="text-align: justify;">Для того чтобы оперативно добавлять программный
продукт в систему или удалять его оттуда, необходимо заранее договориться о
размещении в файловой системе всех входящих в него файлов. Запомнив каждый файл
с <b>полным именем</b>, мы получим <b>архив</b>, целиком определяющий
расположение программного продукта в системе. Такой архив в UNIX называется
пакетом. Мы можем <b>устанавливать</b> пакет в систему и <b>удалять</b> его,
зная, что записываем и удаляем файлы, принадлежащие только ему. В пакете могут
храниться не только программные продукты, но и вообще любые
"кирпичики", из которых можно складывать систему: утилиты, драйверы,
документация, шрифты и все остальное. Если при установке или удалении пакета
нужно проделать какие-нибудь действия (например, зарегистрировать
устанавливаемый шрифт), к нему прилагаются <b>установочный сценарий</b> и <b>сценарий
удаления</b>.</p>

<p style="text-align: justify;">Система, настроенная на решение определенных
задач, не обязательно должна содержать все возможные пакеты. Как правило, в
дистрибутив UNIX входит несколько тысяч пакетов разного назначения и объема, от
утилиты, сообщающей, в какой фазе сегодня находится луна, до издательской
системы. В действительности их устанавливают несколько сотен.</p>

<h2 style="text-align: justify;"><span style="font-size: 14pt;">Процессы<o:p></o:p></span></h2>

<p style="text-align: justify;">В роли задач в UNIX выступают процессы. Процесс –
это программа, запущенная пользователем, которая находится в памяти и, как
полагается задаче, потребляет ресурсы: выполняется, требует памяти,
обменивается данными с системой, внешними устройствами и другими процессами.
При запуске процесс получает уникальный идентификатор процесса (Process
IDentifier, PID), по которому он становится доступен другим процессам и
планировщику. Планировщик процессов в UNIX устроен сложнее. Наше описание
предельно упрощено, а полностью разобраться в планировании процессов поможет.
Главное отличие планировщика UNIX заключается в том, что каждая задача из
очереди работает в течение всего отведенного ей промежутка времени, только если
ей есть чем заняться. Если задача к этому времени работать не может (например,
ожидает завершения операции ввода/вывода, или сигнала, или освобождения
какого-либо ресурса), она из начала очереди перемещается в конец "очереди
для тех, кто без очереди" или очереди "спящих" задач. Как только
какая-нибудь задача из очереди спящих просыпается, ей тут же отводится место в
начале обычной очереди. Таким образом максимально сокращается время простоя (idle)
системы, если, конечно, выполняемых задач достаточно для того, чтобы полностью
ее загрузить. Сверх того процессы в UNIX могут иметь разные приоритеты,
сообразно которым идет планирование очередного запуска процесса (например,
полностью отработав свой промежуток времени, процесс может помещаться не в
конец очереди).</p>

<h1 style="text-align: justify;"><span style="font-size: 14pt; line-height: 115%;">Использование
виртуальных терминалов<o:p></o:p></span></h1>

<p style="text-align: justify;">Операционная система (ОС) UNIX является
многопользовательской системой, то есть обеспечивает возможность одновременной
работы нескольких пользователей. Для этого в системе имеется несколько
терминальных портов (терминалов). Традиционно терминалом называется устройство,
состоящее из клавиатуры и монитора, подключенное к ЭВМ и обеспечивающее
ввод-вывод информации. В данном случае под терминалом понимается любой
зарегистрированный в системе двунаправленный канал для последовательной
передачи алфавитно-цифровой информации, связанный с драйвером устройства
ввода-вывода (консоль - монитор и клавиатура, последовательный порт). Любая
работающая в системе прикладная программа связана с одним из терминалов и
использует его для получения информации от пользователя и выдачи выходных
данных. Несколько одновременно работающих пользователей используют разные
терминалы, вновь запускаемые программы по умолчанию связываются с тем
терминалом, с которым работает запустивший их пользователь. Процесс работы
пользователя с терминалом называется терминальной сессией.</p>

<p style="text-align: justify;">Современные версии UNIX позволяют пользователю
персонального компьютера одновременно запустить несколько терминальных сессий,
переключаясь между ними и попеременно работая от имени различных пользователей
с использованием одной и той же реальной клавиатуры и монитора. Такие
терминальные порты, связанные с одними и теми же физическими устройствами
называются виртуальными терминалами. По умолчанию в LINUX активны 7 виртуальных
терминалов, для переключения между ними используются сочетания клавиш Alt+F1 …
Alt+F7. Седьмой виртуальный терминал как правило используется для запуска
графического интерфейса пользователя.</p>

<h2 style="text-align: justify;"><span style="font-size: 14pt;">Вход в систему<o:p></o:p></span></h2>

<p style="text-align: justify;">Перед началом работы с системой UNIX необходимо
пройти регистрацию в системе, то есть ввести имя пользователя (login) и пароль
(password). При загрузке системы для каждого активного терминала запускается
программа getty, выдающая на терминал запрос имени пользователя. После ввода
имени getty запускает программу login, передавая ей имя пользователя в качестве
входного параметра. login запрашивает пароль, преобразовывает его одним из
методов необратимого шифрования и сравнивает результат с шифрованным паролем
данного пользователя, хранящимся в одном из файлов ОС (/etc/passwd или
/etc/shadow). Если пароли совпадают, программа login выводит на экран
приветствие, хранящееся в файле /etc/motd и запускает командный интерпретатор.</p>

<p style="text-align: justify;">После завершения работы с системой следует
отключиться от нее. Для этого следует подать команду logout.</p>

<p style="text-align: justify;">Имейте в виду, что в Linux различаются большие и
малые буквы. А символы <b>Del</b> и <b>Backspace</b> считаются как символы
пароля. Поэтому, если нажали не тот символ, чтобы очистить строчку с паролем,
нажмите <b>Ctrl+U</b> и введите пароль заново. Если вы корректно ввели имя
пользователя и пароль, то вы попадете в ваш домашний каталог.</p>

<p style="text-align: justify;">Узнать ваше регистрационное имя можно командой “<b>whoami</b>”</p>

<p style="text-align: justify;">Узнать о других зарегистрированных пользователях
можно командой “<b>who</b>”</p>

<p style="text-align: justify;"><b>exit</b> – выйти из текущей оболочки (bash, mc
и т.п.)</p>

<p style="text-align: justify;"><b>logout</b> – выйти из текущего сеанса (аналог <b>Ctrl+D</b>)</p>

<p style="text-align: justify;">Alt+F1 … Alt+F6 – переключаться между
виртуальными консолями</p>


<h1 style="text-align: justify;"><span style="font-size: 14pt; line-height: 115%;">Пользователи,
группы<o:p></o:p></span></h1>

<p style="text-align: justify;">Права пользователя на доступ к файлам
определяются во-первых именем пользователя, а во-вторых именем группы, к
которой он принадлежит. Имя пользователя вводится при регистрации в системе,
имя группы, к которой он принадлежит определяется из файлов etc/passwd и
/etc/group (подробнее эти файлы рассмотрены в лабораторной работе 2). Каждому
имени пользователя и каждой группе в ОС сопоставлены числовые идентификаторы,
обозначаемые UID (user ID) и GID (group ID) соответственно. Пользователь с
UID=0 традиционно имеет имя root, называется суперпользователем, и имеет
полномочия администратора, то есть право доступа ко всем файлам в ОС.</p>

<p style="text-align: justify;">Для каждой запущенной программы (процесса) в ядре
ОС имеется структура данных, в которой хранится различная информация о
процессе, в том числе UID и GID пользователя-владельца, которые определяют
права этого процесса на доступ к файлам. При запуске командного интерпретатора
программа login присваивает ему UID и GID зарегистрировавшегося пользователя
(сама программа login должна иметь доступ к файлу с <span style="font-size: 14pt;">шифрованными паролями, поэтому имеет UID=0).<o:p></o:p></span></p>

<h2 style="text-align: justify;"><span style="font-size: 14pt;">Командный
интерпретатор<o:p></o:p></span></h2>

<p style="text-align: justify;">Командный интерпретатор (оболочка, shell) – это
программа, обеспечивающая прием команд от пользователя или из командных файлов
(скриптов) и их выполнение. После запуска командный интерпретатор выполняет
скрипт инициализации и выводит в терминал «приглашение» на ввод команд.
Приглашение включает некоторую служебную информацию (например имя пользователя)
и специальный символ, за которым следует курсор для ввода. Пример приглашения:</p>

<p style="text-align: justify;"><b>root#</b></p>

<p style="text-align: justify;">Введенная после приглашения строка
интерпретируется оболочкой как команда.</p>

<p style="text-align: justify;">В UNIX существует несколько разновидностей
оболочек. Стандартной оболочкой для всех разновидностей UNIX является Bourne
shell, интерпретатор bash в LINUX полностью совмести с shell. В дальнейшем все
команды интерпретатора рассматриваются на примере bash.</p>

<p style="text-align: justify;">Команды реализованные в самой
программе-интрпретаторе называются внутренними. Если интерпретатору не удается
найти требуемую внутреннюю команду, то запускается внешняя команда - программа,
находящаяся в файле с указанным именем. Поиск файлов внешних команд
осуществляется только в каталогах, имена которых содержатся в переменной среды
PATH (переменные среды изучаются в следующих работах). Как правило в число этих
каталогав входят каталоги /usr/local/sbin; /usr/local/bin; /sbin; /bin;
/usr/sbin; /usr/bin.</p>

<p style="text-align: justify;">При записи правил использования команд в
справочной системе UNIX (и в этих методических указаниях) приняты следующие
обозначения: </p>

<table class="MsoNormalTable" style="width: 306pt;" border="0" cellpadding="0" cellspacing="0" width="408">
 <tbody><tr style="height: 15pt;">
  <td style="padding: 5.25pt; width: 73.5pt; height: 15pt;" valign="top" width="98">
  <p style="text-align: justify;"><b>[-p]</b></p>
  </td>
  <td style="padding: 5.25pt; width: 211.5pt; height: 15pt;" valign="top" width="282">
  <p style="text-align: justify;">в квадратных скобках указываются параметры,
  которые могут быть опущены</p>
  </td>
 </tr>
 <tr style="height: 15.75pt;">
  <td style="padding: 5.25pt; width: 73.5pt; height: 15.75pt;" valign="top" width="98">
  <p style="text-align: justify;"><b>имя пользователя | UID</b></p>
  </td>
  <td style="padding: 5.25pt; width: 211.5pt; height: 15.75pt;" valign="top" width="282">
  <p style="text-align: justify;">через символ | указывается список возможных
  альтернатив, то есть при записи команды может быть выбран только один из этих
  вариантов</p>
  </td>
 </tr>
</tbody></table>

<p style="text-align: justify;">Курсивом указываются шаблоны, которые при вводе
команд нужно заменить на настоящие значения параметра. После имени команды
через пробел могут быть указаны один или несколько ключей (опций), например
команда</p>

<p style="text-align: justify;"><b>ls directory</b></p>

<p style="text-align: justify;">выводит список содержимого каталога directory в
краткой форме, а та же команда с ключем -l</p>

<p style="text-align: justify;"><b>ls –l directory</b></p>

<p style="text-align: justify;">выводит его в развернутой форме.</p>

<p style="text-align: justify;">LINUX ключи состоящие из одной буквы указываются
со знаком -, из нескольких букв – с двумя знаками минус, например -l и --list.
Часто для одной и той же функции имеется длинное и короткое написание ключа.</p>

<p style="text-align: justify;">По окончании ввода команды следует нажать Enter.</p>

<h1 style="text-align: justify;"><span style="font-size: 14pt; line-height: 115%;">Справочная
система<o:p></o:p></span></h1>

<p style="text-align: justify;">Для вывода справки о команде как правило следует
ввести эту команду с ключом <b>–h</b> или <b>--help</b>. Если справочная
информация не убирается на экране, после ключа следует перенаправить вывод в
программу more (подробнее перенаправление результатов работы команды изучается
в работе 3), например</p>

<p style="text-align: justify;"><b>ls --help | more</b></p>

<p style="text-align: justify;">Более подробную справку по команде можно получить
в справочной системе, для этого следует подать команду <b>man</b>, а в качестве
параметра указать имя интересующей команды, например:</p>

<p style="text-align: justify;"><b>man ls</b></p>

<span style="font-size: 11pt; line-height: 115%; font-family: &quot;Calibri&quot;,&quot;sans-serif&quot;;">Перемещение
по тексту справочной системы осуществляется клавишами «вверх», «вниз», PgUp,
PgDn, выход клавишей q</span></body></html>