<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta HTTP-EQUIV=Cache-Control content=no-cache>
<meta name="author" content="S.V. Danilenko">
<meta http-equiv="refresh" content="360; URL=p06.html">
<title>Основы электроники и цифровой схемотехники</title>
<link href="../img/style02.css" rel="stylesheet" type="text/css">
</head>
<body oncopy="return false" onselectstart="return false">
<a name="ChapTop"></a>
<table width="98%" border="0" background="../img/bgkletka.gif" bgcolor="#FFFFFF">
  <tr>
    <td width="5%" height="58"><div align="center"></div></td>
    <td width="90%">&nbsp; <div align="center"><a href="../cont/ktp-el.html" title="Календарно-тематический план">К Т П</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; <a href="p00.html">План занятия</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="../img/book.jpg" alt="1" width="59" height="44">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Страницы&nbsp; | <a href="p01.html">1</a> | | <a href="p02.html">2</a> | | <a href="p03.html">3</a> | | <a href="p04.html">4</a> | | 5 | | <a href="p06.html">6</a> | | <a href="p07.html">7</a> | | <a href="p08.html">8</a> | | <a href="p09.html">9</a> |<br/>
    </div>
    <hr width="100%" size="5" noshade></td>
    <td width="5%"><div align="center"><form name="d"> <input type="text" size="4" name="d2"></form></div></td>
  </tr>
  <tr>
    <td height="79"><div align="center"></div></td>
    <td><div align="center">
      <h3>2.15.5.  Разработка вычислителя контрольной суммы</h3>
    </div></td>
    <td><div align="center"></div></td>
  </tr>
  <tr>
    <td height="100%"><div align="center"></div></td>
    <td align="left" valign="top"><p>Различные контрольные суммы широко применяются в цифровых устройствах и системах для контроля правильности хранения или передачи массивов информации. Суть этого метода контроля проста: к хранимому или передаваемому информационному массиву присоединяется небольшой контрольный код (обычно от 1 разряда до 32 разрядов), в котором в свернутом виде содержится информация обо всем массиве. При чтении или получении этого массива еще раз вычисляется тот же самый контрольный код по тому же самому алгоритму. Если этот вновь вычисленный код равен тому коду, который был присоединен к массиву, то считается, что массив сохранен или передан без ошибок. Логика здесь следующая: контрольный код (он же контрольная сумма ) гораздо меньше контролируемого массива, поэтому вероятность искажения контрольной суммы гораздо меньше, чем вероятность искажения массива. Если же исказятся как массив, так и контрольная сумма, то вероятность того, что эти искажения не будут замечены при повторном подсчете контрольной суммы, крайне мала. Существует, правда, вероятность, что массив будет искажен в нескольких местах таким образом, что контрольная сумма от этих искажений никак не изменится, но такая вероятность также обычно мала. </p>
    <p>Контрольные суммы применяются при хранении данных в памяти (оперативной и постоянной), при хранении данных на магнитных носителях (дисках, лентах), в локальных и глобальных сетях передачи информации. В случае защиты контрольной суммой хранимой информации можно определить, что данный массив (файл, сектор на диске) испорчен и его нельзя использовать. В случае защиты контрольной суммой передаваемой по сети информации приемник может потребовать от передатчика повторной передачи искаженного массива. </p>
    <p>Существует множество способов вычисления контрольной суммы, различающихся степенью сложности вычисления и надежностью выявления ошибок. Но наибольшее распространение получил в настоящее время так называемый &quot;циклический метод контроля по избыточности&quot; или <b>CRC</b> (Cyclic Redundancy Check), при котором применяется циклическая контрольная сумма. Вычисляется циклическая контрольная сумма следующим образом. Весь массив информации рассматривается как одно N-разрядное двоичное число, где <i><b>N</b></i> — количество бит во всех байтах массива. Для вычисления контрольной суммы это N-разрядное число делится на некоторое постоянное число ( полином ), выбранное специальным образом (но делится не просто, а по модулю 2). Частное от этого деления отбрасывается, а остаток как раз и используется в качестве контрольной суммы. </p>
    <p>Мы не будем углубляться в математическое обоснование этого метода. Интересующиеся читатели могут обратиться к специальной литературе. Здесь же мы отметим только, что данный метод выявляет одиночные ошибки в массиве с вероятностью 100%, а любое другое количество ошибок с вероятностью, примерно равной <b>1–2<sup>-n</sup></b>, где <b>n</b> — количество разрядов контрольной суммы (это верно только при условии, что <b>N</b> гораздо больше <b>n</b>, что, впрочем, почти всегда выполняется). Например, при <i><b>n = 8</b></i> данная вероятность составит <i>0,996</i>, для <i><b>n = 16</b></i> она будет равна 0,999985, а для <i><b>n = 32</b></i> она будет <i>0,9999999997672</i>. Иначе говоря, почти все ошибки будут выявляться.</p></td>
    <td><div align="center"></div></td>
  </tr>
  <tr>
    <td height="100%"><div align="center"></div></td>
    <td align="left" valign="top"><p>А теперь кратко поясним, что такое <i><b>деление по модулю 2</b></i>. Пусть массив (последовательность бит) имеет следующий вид: 101111001110 (для простоты берем небольшую разрядность). Число, на которое делим (называемое обычно образующим полиномом ) возьмем 10011. Как оно выбирается? Оно должно делиться по модулю <b>2</b> без остатка только на единицу и само на себя (то есть это должно быть простое число в смысле деления по модулю <b>2</b>). Разрядность полинома берется на единицу большая, чем требуемая разрядность контрольной суммы (остатка от деления). Так, чтобы получить 8-разрядный остаток (8-разрядную контрольную сумму), надо брать 9-разрядный полином. В нашем случае полином 5-разрядный, следовательно, остаток будет 4-разрядный. Для получения 8-разрядного остатка можно использовать, например, <i>полином 1</i> <b>0001 1101</b> или <b>11D</b> в 16-ричном коде. </p>
      <p>Деление по модулю <b>2</b> производится точно так же, как и привычное для нас деление &quot;в столбик&quot; (рис. 39.6), но вместо вычитания в данном случае используется поразрядное сложение по модулю <b>2</b>, то есть каждый результирующий бит представляет собой функцию <i>Исключающее</i> <i><b>ИЛИ</b></i> от соответствующих битов слагаемых. Частное от деления нас не интересует, а остаток, равный в нашем примере 1000, и будет циклической контрольной суммой.</p>
    </td>
    <td><div align="center"></div></td>
  </tr>
  <tr>
    <td height="100%">&nbsp;</td>
    <td align="center" valign="top"><img src="img/39-6.gif" width="496" height="169"><br><br>Рис. 39.6.  Вычисление циклической контрольной суммы.</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td height="100%"><div align="center"></div></td>
    <td align="center" valign="top"><p>Как практически реализовать вычисление этого остатка (контрольной суммы)? Можно сделать это по приведенному   здесь принципу деления в столбик (аппаратно или программно). Но в любом случае это довольно громоздко и медленно.   Ускорить процесс вычисления можно, воспользовавшись табличным методом. Для этого составляется таблица чисел размером <b>2<sup>n</sup>хn</b>, где n  — разрядность контрольной суммы. Принцип вычисления чисел в таблице очень прост (табл. 39.1).</p>
      <div id="id_57">
        <table width="660" border="0" cellpadding="2" cellspacing="1">
          <caption>
            Таблица 39.1.                      Табличный метод вычисления циклической контрольной суммы
          </caption>
          <tbody>
            <tr>
              <th width="209" bgcolor="#d8d8d8">Адрес в таблице </th>
              <th width="318" bgcolor="#d8d8d8"> Данные в таблице (числа)</th>
            </tr>
            <tr>
              <td bgcolor="#eaeaea" valign="top">0</td>
              <td bgcolor="#eaeaea" valign="top">0</td>
            </tr>
            <tr>
              <td bgcolor="#eaeaea" valign="top">1</td>
              <td bgcolor="#eaeaea" valign="top">Остаток от деления числа 1 0000 0000 на полином</td>
            </tr>
            <tr>
              <td bgcolor="#eaeaea" valign="top">2</td>
              <td bgcolor="#eaeaea" valign="top">Остаток от деления числа 10 0000 0000 на полином</td>
            </tr>
            <tr>
              <td bgcolor="#eaeaea" valign="top">3</td>
              <td bgcolor="#eaeaea" valign="top">Остаток от деления числа 11 0000 0000 на полином</td>
            </tr>
            <tr>
              <td bgcolor="#eaeaea" valign="top">4</td>
              <td bgcolor="#eaeaea" valign="top">Остаток от деления числа 100 0000 0000 на полином</td>
            </tr>
            <tr>
              <td bgcolor="#eaeaea" valign="top">5</td>
              <td bgcolor="#eaeaea" valign="top">Остаток от деления числа 101 0000 0000 на полином</td>
            </tr>
            <tr>
              <td bgcolor="#eaeaea" valign="top"></td>
              <td bgcolor="#eaeaea" valign="top"></td>
            </tr>
            <tr>
              <td bgcolor="#eaeaea" valign="top">255</td>
              <td bgcolor="#eaeaea" valign="top">Остаток от деления числа 1111 1111 0000 0000 на полином</td>
            </tr>
          </tbody>
        </table>
      </div>
      <div id="mark_57"></div>
      <p id="id_58">Числа представляют собой остаток от деления по модулю <b>2</b> числа с <b><i>n-</i></b><i>конечными </i>нулями (в нашем примере n = 8) и с <b><i>n-</i></b><i>начальными</i> разрядами, равными номеру числа (его адресу) в таблице. Деление производится на выбранный полином (в   нашем случае — 9-разрядный). Таблица вычисляется один раз и хранится на диске или в ПЗУ.</p>
      <div id="mark_58"></div>
      <p id="id_59">Алгоритм вычисления контрольной суммы с помощью этой таблицы следующий (рассматриваем случай n = 8). Берем   первый байт нашего информационного массива. Рассматриваем его как адрес в таблице (номер числа). Берем из таблицы   число с полученным номером — получаем остаток <b>О<sup>1</sup></b>. Берем второй байт массива и складываем его по модулю <b>2</b> с остатком <b>О<sup>1</sup></b>. Полученное число используем как адрес в таблице. По этому адресу выбираем из таблицы остаток <b>О<sup>2</sup></b>. Берем третий   байт массива, складываем его по модулю <b>2</b> с остатком <b>О<sup>2</sup></b>. Используя это число как адрес в таблице, выбираем из нее   остаток <b>О<sup>3</sup></b> и так продолжаем до последнего байта массива. Естественно, это будет гораздо быстрее, чем вычисление   "в столбик".</p>
      <p>Реализация этого алгоритма с помощью цифровых схем требует только <b>ПЗУ</b> с организацией 2<sup>n</sup>хn (256х8 при 8-разрядной контрольной сумме), n-разрядного регистра и n элементов Исключающее ИЛИ (рис. 39.7). В ПЗУ заносится таблица промежуточных остатков (табл. 39.1), на вход схемы подаются один за другим байты массива, сопровождаемые стробом. Адресом ПЗУ служит сумма по модулю 2 входных данных и содержимого выходного регистра, в который по сигналу строба записывается выходной код ПЗУ. Перед началом вычисления состояние регистра обнуляется. После окончания всего массива в регистре образуется циклическая контрольная сумма. </p>
      <p>Недостаток данной схемы параллельного вычислителя очевиден: в случае большого числа разрядов контрольной суммы требуется очень большой объем <b>ПЗУ</b> (64Кх16 для 16-разрядной суммы и 4Гх32 для 32-разрядной суммы). Поэтому она применяется сравнительно редко. Зато параллельный вычислитель обладает высоким быстродействием (байты могут поступать с периодом, равным сумме задержки выходного регистра, времени выборки адреса ПЗУ и задержки элемента Исключающее ИЛИ).</p>
    <p>&nbsp;</p></td>
    <td><div align="center"></div></td>
  </tr>
  <tr>
    <td height="100%">&nbsp;</td>
    <td align="center" valign="top"><img src="img/39-7.gif" width="498" height="195" alt="7"><br>Рис. 39.7.  Параллельный вычислитель 8-разрядной циклической контрольной суммы на ПЗУ.</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td><div align="center"></div></td>
    <td><div align="center">
      <hr width="100%" size="4" noshade>
      <a href='javascript:history.go(-1)'><img src="../img/nazad.jpg" alt="Предыдущая" width="31" height="20"></a>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; <a href="p05.html#ChapTop"><img src="../img/vverh.gif" alt="В начало страницы" width="20" height="31"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="p06.html"><img src="../img/vpr.jpg" alt="Следующая" width="31" height="20"></a>
      
    </div></td>
    <td><div align="center">5</div></td>
  </tr>
</table>
</body>

<script>
var milisec=0
var seconds=0
document.d.d2.value='0'
function display(){
if (milisec>=9){
milisec=0
seconds+=1
}
else
milisec+=1
document.d.d2.value=seconds+"."+milisec
setTimeout("display()",100)
}
display()
</script>

</html>
