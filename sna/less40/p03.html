<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta HTTP-EQUIV=Cache-Control content=no-cache>
<meta name="author" content="S.V. Danilenko">
<meta http-equiv="refresh" content="360; URL=p04.html">
<title>Основы электроники и цифровой схемотехники</title>
<link href="../img/style02.css" rel="stylesheet" type="text/css">
</head>
<body oncopy="return false" onselectstart="return false">
<a name="ChapTop"></a>
<table width="98%" border="0" background="../img/bgkletka.gif" bgcolor="#FFFFFF">
  <tr>
    <td width="5%" height="58"><div align="center"></div></td>
    <td width="90%">&nbsp; <div align="center"><a href="../cont/ktp-el.html" title="Календарно-тематический план">К Т П</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; <a href="p00.html">План занятия</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<img src="../img/book.jpg" alt="1" width="59" height="44">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; Страницы&nbsp; | <a href="p01.html">1</a> | | <a href="p02.html">2</a> | | 3 | | <a href="p04.html">4</a> | | <a href="p05.html">5</a> | | <a href="p06.html">6</a> | | <a href="p07.html">7</a> | | <a href="p08.html">8</a> | | <a href="p09.html">9</a> |<br/>
    </div>
    <hr width="100%" size="5" noshade></td>
    <td width="5%"><div align="center"><form name="d"> <input type="text" size="4" name="d2"></form></div></td>
  </tr>
  <tr>
    <td height="79"><div align="center"></div></td>
    <td><div align="center">
      <h3>2.16.3.  Организация предпусковой регистрации &nbsp;и счётчики анализатора</h3>
    </div></td>
    <td><div align="center"></div></td>
  </tr>
  <tr>
    <td height="100%"><div align="center"></div></td>
    <td align="left" valign="top"><p>От счетчика адресов памяти требуется максимальное быстродействие (можно взять, например, микросхемы синхронных счетчиков <b>КР531ИЕ17</b>, которые достаточно легко каскадируются без потери быстродействия). Кроме простого перебора адресов, счетчик должен также обеспечивать предпусковую регистрацию. Остановимся на этом несколько подробнее. Для того чтобы реализовать предпусковую регистрацию, необходимо обеспечить непрерывную перезапись по кругу содержимого буферной памяти до момента прихода запуска (рис. 40.3).</p>    </td>
    <td><div align="center"></div></td>
  </tr>
  <tr>
    <td height="100%"><div align="center"></div></td>
    <td align="center" valign="top"><img src="img/40-3.gif" width="605" height="140" alt="3"><br>Рис. 40.3.  Организация предпусковой регистрации.</td>
    <td><div align="center"></div></td>
  </tr>
  <tr>
    <td height="100%"><div align="center"></div></td>
    <td align="left" valign="top"><p>То есть после записи последнего <b>4095</b> адреса надо записывать информацию по нулевому адресу. Если мы выбираем глубину предпусковой регистрации <b><i>N</i></b><i> тактов</i>, то надо остановить регистрацию через (4096–N) тактов после момента прихода запуска. После остановки регистрации надо считывать содержимое памяти, начиная с точки остановки, с перебором адресов в том же самом направлении, что и при регистрации. Проведя 4096 операций чтения содержимого памяти, мы получим информацию о состоянии входных сигналов в течение <i>N тактов</i> до запуска и (4096–N) тактов после запуска, то есть моменту прихода запуска будет соответствовать содержимое адреса памяти, считанного N-ым. </p>
    <p>Однако все произойдет именно таким образом только в том случае, если от момента начала регистрации до момента прихода запуска логический анализатор успеет зафиксировать <i>N тактов</i>. Иначе, остановив регистрацию через (4096–N), мы не перепишем всю память, и в части его адресов будет находиться предыдущая информация. Чтобы избежать этого, надо запретить реакцию на запуск в течение N тактов после начала регистрации (выдержать своеобразное &quot;мертвое&quot; время). А что будет, если запуск придет в течение этого самого &quot;мертвого&quot; времени? </p>
    <p>Если исследуемый процесс — периодический (то есть все входные сигналы повторяются через какое-то время), то анализатор среагирует на следующий запуск после окончания &quot;мертвого&quot; времени. Если же исследуемый процесс — однократный, не повторяющийся, то надо начать процесс регистрации заведомо раньше (на &quot;мертвое&quot; время или больше), чем начнется изучаемый процесс (например, если мы исследуем старт компьютера при включении питания).</p>
    <p>В результате счетчики анализатора должны обеспечивать временную диаграмму, показанную на рис. 40.4.</p></td>
    <td><div align="center"></div></td>
  </tr>
  <tr>
    <td height="100%">&nbsp;</td>
    <td align="center" valign="top"><img src="img/40-4.gif" width="496" height="171" alt="4"><br><br>Рис. 40.4.  Временная диаграмма работы счетчиков логического анализатора.
    <p>Адреса памяти начинают перебираться с началом регистрации. В течение <i>N тактов</i> после начала регистрации реакция на запуск запрещается, а затем разрешается. Через (4096–N) тактов после прихода запуска регистрация прекращается.</p>
    <p>Отметим, что точно так же может быть реализована предпусковая регистрация в цифровом осциллографе. По сравнению с логическим анализатором, в схему надо будет добавить только один или несколько АЦП и некоторые другие цифро-аналоговые узлы. </p>
    <p>Схема счетчиков логического анализатора приведена на рис. 40.5.</p>
    </td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td height="100%">&nbsp;</td>
    <td align="center" valign="top"><img src="img/40-5a.gif" width="545" height="590" alt="5"><br><br>Рис. 40.5.  Схема счетчиков логического анализатора</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td height="100%">&nbsp;</td>
    <td align="center" valign="top"><p><b>Два 12-разрядных счетчика реализованы на шести микросхемах ИЕ17.</b> Первый счетчик (на рисунке вверху) работает в режиме инверсного счета, второй (на рисунке внизу) — в режиме прямого счета. Перед началом работы в оба счетчика по внешнему сигналу &quot;–Зап.&quot; записывается <i>код</i> <i>N</i>. Причем четыре младших разряда 12-разрядного <i>кода</i> <i>N</i> равны нулю, а записываются только 8 старших разрядов. Это приводит к тому, что глубина предпусковой регистрации может задаваться с точностью до 16 тактов и принимать значения из ряда: 0, 16, 32, 48, 64,..., 4080. При записи на входы счетчиков <b>–EWR</b> и <b>С</b> поступают отрицательные сигналы, причем сигнал <b>–EWR</b> задержан относительно сигнала <b>С</b> на двух инверторах и (при необходимости) на конденсаторе. В результате положительный фронт сигнала С приходит тогда, когда сигнал <b>–EWR</b> равен нулю, что и требуется для записи. </p>
      <p>На вход <b>С</b> обоих счетчиков могут приходить еще два сигнала: строб чтения из памяти <i>&quot;–Чт.&quot;</i> и тактовый сигнал <i>&quot;Такт&quot;</i>. Сигнал &quot;Такт&quot; приходит при регистрации (в режиме записи в память), а сигнал <i>&quot;–Чт.&quot;</i> поступает при чтении из памяти зарегистрированной информации. После того как в оба счетчика записан <i>код N</i>, необходимо начать регистрацию по внешнему сигналу <i>&quot;–Старт&quot;</i>. Этот сигнал сбрасывает в нуль <b>триггеры 1</b> и <b>2</b> и устанавливает в единицу <b>триггер 3</b>. Выходной сигнал <b>триггера 3</b> разрешает регистрацию (сигнал <i>&quot;Рег.&quot;</i> на рис. 40.4), то есть разрешает прохождение тактовых импульсов на входы счетчиков <b>С</b>. Это приводит к тому, что начинает работу первый счетчик, а второму счетчику работа запрещается по входу <b>–ECT</b> выходным сигналом <b>триггера 2</b>. </p>
      <p>Первый счетчик, выходной код которого используется как адрес памяти, отсчитывает <i><b>N</b></i> тактов в инверсном режиме и вырабатывает сигнал переноса <b>-CR</b>. Этим сигналом перебрасывается в единицу <b>триггер 1</b>. Затем первый счетчик продолжает перебирать адреса памяти по кругу, а запись нулей в <b>триггер 1</b> запрещается элементом <b>2И-НЕ</b> на входе триггера. Выходной сигнал триггера 1 (сигнал РЗ на рис. 40.4) разрешает работу <b>триггера 2</b> и тем самым разрешает реакцию схемы на сигнал запуска <i>&quot;Запуск&quot;</i> (положительный фронт). После прихода сигнал <i>&quot;Запуск&quot;</i> перебрасывается в единицу <b>триггер 2</b>, разрешая работу второго счетчика. Первый счетчик в это время продолжает считать. Второй счетчик начинает свой счет с <i>кода N</i>, досчитывает в режиме прямого счета до 4096 и своим сигналом переноса <b>–CR</b> перебрасывает в нуль <b>триггер 3</b>. Это приводит к запрету поступления тактовых импульсов на вход <b>С</b> счетчиков и к остановке регистрации. После этого может начаться чтение записанной информации по стробу <i>&quot;–Чт.&quot;</i>. По заднему (положительному) фронту этого сигнала первый счетчик будет перебирать адреса памяти в инверсном режиме. Второй счетчик также будет считать, но это не имеет никакого значения. После <b>4096 циклов</b> чтения вся информация из памяти будет прочитана, и схема будет готова к новой регистрации.</p>
    <p>&nbsp;</p></td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td><div align="center"></div></td>
    <td><div align="center">
      <hr width="100%" size="4" noshade>
      <a href='javascript:history.go(-1)'><img src="../img/nazad.jpg" alt="Предыдущая" width="31" height="20"></a>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; <a href="p03.html#ChapTop"><img src="../img/vverh.gif" alt="В начало страницы" width="20" height="31"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <a href="p04.html"><img src="../img/vpr.jpg" alt="Следующая" width="31" height="20"></a>
      
    </div></td>
    <td><div align="center">3</div></td>
  </tr>
</table>
</body>

<script>
var milisec=0
var seconds=0
document.d.d2.value='0'
function display(){
if (milisec>=9){
milisec=0
seconds+=1
}
else
milisec+=1
document.d.d2.value=seconds+"."+milisec
setTimeout("display()",100)
}
display()
</script>

</html>
