<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>Приложение C. Перечень изменений</title>
</head>
<body bgcolor=#d3d3d3>
<font face=Arial>
<hr>
<a name="cnt"></a><p><a href="index.html#content">Содержание</a></p>
<h2>Приложение B. Стандартная библиотека</h2>
<hr>
<a href="#b1">B1. Ввод-вывод: <b>&lt;stdio.h&gt;</b></a><br>
<a href="#b11">B1.1. Операции над файлами</a><br>
<a href="#b12">B1.2. Форматный вывод</a><br>
<a href="#b13">B1.3. Форматный ввод</a><br>
<a href="#b14">B1.4. Функции ввода-вывода символов</a><br>
<a href="#b15">B1.5. Функции прямого ввода-вывода</a><br>
<a href="#b16">B1.6. Функции позиционирования файла</a><br>
<a href="#b17">B1.7. Функции обработки ошибок</a><br>
<a href="#b2">B2. Проверки класса символа: <b>&lt;ctype.h&gt;</b></a><br>
<a href="#b3">B3. Функции, оперирующие со строками: <b>&lt;string.h&gt;</b></a><br>
<a href="#b4">B4. Математические функции: <b>&lt;math.h&gt;</b></a><br>
<a href="#b5">B5. Функции общего назначения: <b>&lt;stdlib.h&gt;</b></a><br>
<a href="#b6">B6. Диагностика: <b>&lt;assert.h&gt;</b></a><br>
<a href="#b7">B7. Списки аргументов переменной длины: <b>&lt;stdarg.h&gt;</b></a><br>
<a href="#b8">B8. Дальние переходы: <b>&lt;setjmp.h&gt;</b></a><br>
<a href="#b9">B9. Сигналы: <b>&lt;signal.h&gt;</b></a><br>
<a href="#b10">B10. Функции даты и времени: <b>&lt;time.h&gt;</b></a><br>
<a href="#b111">B11. Зависящие от реализации пределы: <b>&lt;limits.h&gt;</b> и <b>&lt;float.h&gt;</b></a><br><br>
<hr>
<p>
Настоящее приложение представляет собой краткое изложение библиотеки, 
утвержденной в качестве ANSI-стандарта. Сама по себе библиотека не является 
частью языка, однако, заложенный в ней набор функций, а также определений 
типов и макросов составляет системную среду, поддерживающую стандарт Си. Мы 
не приводим здесь несколько функций с ограниченной областью применения – те, 
которые легко синтезируются из других функций, а также опускаем все то, что 
касается многобайтовых символов и специфики, обусловленной языком, 
национальными особенностями и культурой.
</p>

<p>
Функции, типы и макросы объявляются в следующих стандартных заголовочных 
файлах:
</p>

<pre><b>
&lt;assert.h&gt;
&lt;ctype.h&gt;
&lt;errno.h&gt;

&lt;float.h&gt;
&lt;limits.h&gt;
&lt;locale.h&gt;

&lt;math.h&gt;
&lt;setjmp.h&gt;
&lt;signal.h&gt;

&lt;stdarg.h&gt;
&lt;stddef.h&gt;
&lt;stdio.h&gt;

&lt;stdlib.h&gt;
&lt;string.h&gt;
&lt;time.h&gt;
</b></pre>

<p>
Доступ к заголовочному файлу осуществляется с помощью строки препроцессора
</p>

<pre>
#include <i>&lt;заголовочный файл&gt;</i>
</pre>

<p>
Заголовочные файлы можно включать в любом порядке и сколько угодно раз. 
Строка <i>#include</i> не должна быть внутри внешнего объявления или определения и 
должна встретиться раньше, чем что-нибудь из включаемого заголовочного файла 
будет востребовано. В конкретной реализации заголовочный файл может и не 
быть исходным файлом.
</p>

<p>
Внешние идентификаторы, начинающиеся со знака подчеркивания, а также все 
другие идентификаторы, начинающиеся с двух знаков подчеркивания или с 
подчеркивания и заглавной буквы, зарезервированы для использования в 
библиотеке.
</p>
<hr>
<a name="b1"></a>
<a href="#cnt"><h3>B1. Ввод-вывод: &lt;stdio.h&gt;</h3></a>

<p>
Определенные в <b>&lt;stdio.h&gt;</b> функции ввода-вывода, а также типы и макросы 
составляют приблизительно одну треть библиотеки.
</p>

<p>
<i>Поток</i> - это источник или получатель данных; его можно связать с диском или с 
каким-то другим внешним устройством. Библиотека поддерживает два вида 
потоков: <i>текстовый</i> и <i>бинарный</i>, хотя на некоторых системах, в частности в 
UNIXe, они не различаются. <i>Текстовый поток</i> - это последовательность строк; 
каждая строка имеет нуль или более символов и заканчивается символом '\n'. 
Операционная среда может потребовать коррекции текстового потока (например, 
перевода '\n' в символы возврат-каретки и перевод-строки).
</p>

<p>
<i>Бинарный поток</i> - это последовательность непреобразованных байтов, 
представляющих собой некоторые промежуточные данные, которые обладают тем 
свойством, что если их записать, а затем прочесть той же системой ввода-
вывода, то мы получим информацию, совпадающую с исходной.
</p>

<p>
Поток соединяется с файлом или устройством посредством его <i>открытия</i>, 
указанная связь разрывается путем <i>закрытия</i> потока. Открытие файла возвращает 
указатель на объект типа <i>FILE</i>, который содержит всю информацию, необходимую 
для управления этим потоком. Если не возникает двусмысленности, мы будем 
пользоваться терминами "файловый указатель" и "поток" как равнозначными.
</p>

<p>
Когда программа начинает работу, уже открыты три потока: <b>stdin</b>, <b>stdout</b> и 
<b>stderr</b>.
</p>
<hr>
<a name="b11"></a>
<a href="#cnt"><h3>B1.1. Операции над файлами</h3></a>

<p>
Ниже перечислены функции, оперирующие с файлами. Тип <b>size_t</b> - беззнаковый 
целочисленный тип, используемый для описания результата оператора <b>sizeof</b>.
</p>

<pre>
FILE *fopen(const char *filename, const char *mode);
</pre>

<p>
<b>fopen</b> открывает файл с заданным именем и возвращает поток или NULL, если 
попытка открытия оказалась неудачной. Режим <i>mode</i> допускает следующие 
значения:
</p>

<table border=1 cellpadding=5>
<tr>
  <td>"r"</td>
  <td> - текстовый файл открывается для чтения (от <i>read</i> (англ.) - читать); </td>
</tr>
  <tr>
  <td>"w"</td>
  <td> - текстовый файл создается для записи; старое содержимое 
(если оно было) выбрасывается (от <i>write</i> (англ.) - писать); </td>
</tr>
<tr><td>"а"</td><td> - текстовый файл открывается или создается для записи в 
конец файла (от <i>append</i> (англ.) - добавлять); </td>
</tr>
<tr><td>"r+"</td><td> - текстовый файл открывается для исправления (т. е. для 
чтения и для записи); </td></tr>
<tr><td>"w+"</td><td> - текстовый файл создается для исправления; старое 
содержимое (если оно было) выбрасывается; </td></tr>
<tr><td>"a+"</td><td> - текстовый файл открывается или создается для 
исправления уже существующей информации и добавления новой в конец файла. 
</td></tr>
</table>

<p>
Режим "исправления" позволяет читать и писать в один и тот же файл; при 
переходах от операций чтения к операциям записи и обратно должны 
осуществляться обращения к <b>fflush</b> или к функции позиционирования файла. Если 
указатель режима дополнить буквой <i>b</i> (например "rb" или "w+b"), то это будет 
означать, что файл бинарный. Ограничение на длину имени файла задано 
константой FILENAME_MAX. Константа FOPEN_MAX ограничивает число одновременно 
открытых файлов.
</p>

<pre>
FILE *freopen(const char *filename, const char *mode, FILE *stream);
</pre>

<p>
<b>freopen</b> открывает файл с указанным режимом и связывает его с потоком <i>stream</i>. 
Она возвращает <i>stream</i> или, в случае ошибки, NULL. Обычно <i>freopen</i> используется 
для замены файлов, связанных с <i>stdin</i>, <i>stdout</i> или <i>stderr</i>, другими файлами.
</p>

<pre>
int fflush(FILE *stream);
</pre>

<p>
Применяемая к потоку вывода функция <b>fflush</b> производит дозапись всех 
оставшихся в буфере (еще не записанных) данных, для потока ввода эта функция 
не определена. Возвращает EOF в случае возникшей при записи ошибки или нуль в 
противном случае. Обращение вида <i>fflush</i>(NULL) выполняет указанные операции 
для всех потоков вывода.
</p>

<pre>
int fclose(FILE *stream);
</pre>

<p>
<b>fсlose</b> производит дозапись еще не записанных буферизованных данных, 
сбрасывает несчитанный буферизованный ввод, освобождает все автоматически 
запрошенные буфера, после чего закрывает поток. Возвращает EOF в случае 
ошибки и нуль в противном случае.
</p>

<pre>
int remove(const char *filename);
</pre>

<p>
<b>remove</b> удаляет файл с указанным именем; последующая попытка открыть файл с 
этим именем вызовет ошибку. Возвращает ненулевое значение в случае неудачной 
попытки.
</p>

<pre>
int rename(const char *oldname, const char *newname);
</pre>

<p>
<b>rename</b> заменяет имя файла; возвращает ненулевое значение в случае, если 
попытка изменить имя оказалась неудачной. Первый параметр задает старое имя, 
второй - новое.
</p>

<pre>
FILE *tmpfile(void);
</pre>

<p>
<b>tmpfile</b> создает временный файл с режимом доступа "wb+", который автоматически 
удаляется при его закрытии или обычном завершении программой своей работы. 
Эта функция возвращает поток или, если не смогла создать файл, NULL.
</p>

<pre>
char *tmpnam(char s[L_tmpnam]);
</pre>

<p>
<b>tmpnam</b>(NULL) создает строку, не совпадающую ни с одним из имен существующих 
файлов, и возвращает указатель на внутренний статический массив. <i>tmpnam(s)</i> 
запоминает строку в <i>s</i> и возвращает ее в качестве значения функции; длина <i>s</i> 
должна быть не менее <b>L_tmpnam</b>. При каждом вызове <i>tmpnam</i> генерируется новое 
имя; при этом гарантируется не более TMPMAX различных имен за один сеанс 
работы программы. Заметим, что <i>tmpnam</i> создает имя, а не файл.
</p>

<pre>
int setvbuf(FILE *stream, char *buf, int mode, size_t size);
</pre>

<p>
<b>setvbuf</b> управляет буферизацией потока; к ней следует обращаться прежде, чем 
будет выполняться чтение, запись или какая-либо другая операция, <i>mode</i> со 
значением <b>_IOFBF</b> вызывает полную буферизацию, с <b>_IOLBF</b> - "построчную" 
буферизацию текстового файла, a <i>mode</i> со значением <b>_IONBF</b> отменяет всякую 
буферизацию. Если параметр <i>buf</i> не есть NULL, то его значение - указатель на 
буфер, в противном случае под буфер будет запрашиваться память. Параметр <i>size</i> 
задает размер буфера. Функция <i>setvbuf</i> в случае ошибки выдает ненулевое 
значение.
</p>

<pre>
void setbuf(FILE *stream, char *buf);
</pre>

<p>
Если <i>buf</i> есть NULL, то для потока <i>stream</i> буферизация выключается. В противном 
случае вызов <b>setbuf</b> приведет к тем же действиям, что и вызов 
(void) setvbuf (stream, buf, _IOFBF, BUFSIZ).
</p>

<a name="b12"></a>
<a href="#cnt"><h3>B1.2. Форматный вывод</h3></a>

<p>
Функции <b>printf</b> осуществляют вывод информации по формату.
</p>

<pre>
int fprintf(FILE *stream, const char *format, ...);
</pre>

<p>
<b>fprintf</b> преобразует и пишет вывод в поток <i>stream</i> под управлением <i>format</i>. 
Возвращаемое значение - число записанных символов или, в случае ошибки, 
отрицательное значение.
</p>

<p>
<i>Форматная строка</i> содержит два вида объектов: <i>обычные символы</i>, копируемые в 
выводной поток, и <i>спецификации преобразования</i>, которые вызывают 
преобразование и печать остальных аргументов в том порядке, как они 
перечислены. Каждая спецификация преобразования начинается с <b>%</b> и 
заканчивается символом-спецификатором преобразования. Между % и символом-
спецификатором в порядке, в котором они здесь перечислены, могут быть 
расположены следующие элементы информации:
</p>

<dir>
<li> Флаги (в любом порядке), модифицирующие спецификацию:
</dir>

<table border=1 cellpadding=5>
<tr><td><b>-</b></td>
<td>- указывает на то, что преобразованный аргумент 
должен быть прижат к левому краю поля; </td></tr>
<tr><td><b>+</b></td>
<td>- предписывает печатать число всегда со знаком; 
</td></tr>
<tr><td><i>пробел</i></td>
<td>- если первый символ - не знак, то числу должен 
предшествовать пробел; </td></tr>
<tr><td><b>0</b></td>
<td>- указывает, что числа должны дополняться слева 
нулями до всей ширины поля; </td></tr>
<tr><td><b>#</b></td>
<td>- указывает на одну из следующих форм вывода: для <i>o</i> 
первой цифрой должен быть 0; для <i>x</i> или <i>X</i> ненулевому 
результату должны предшествовать 0x или 0X; для <i>e</i>, <i>E</i>, <i>f</i>, 
<i>g</i> и <i>G</i> вывод должен обязательно содержать десятичную 
точку; для <i>g</i> и <i>G</i> завершающие нули не отбрасываются. 
</td></tr>
</table>

<dir>
<li> Число, специфицирующее минимальную ширину поля. Преобразованный аргумент 
будет напечатан в поле, размер которого не меньше указанной ширины, а если 
потребуется, в поле большего размера. Если число символов преобразованного 
аргумента меньше ширины поля, то поле будет дополнено слева (или справа, если 
число прижимается к левому краю). Обычно поле дополняется пробелами (или 
нулями, если присутствует флаг дополнения нулями).
<li> Точка, отделяющая указатель ширины поля от указателя точности.
<li> Число, задающее точность, которое специфицирует максимальное количество 
символов, печатаемых из строки, или количество цифр после десятичной точки в 
преобразованиях e, E или f, или количество значащих цифр для g или G -
преобразования, или минимальное количество цифр при печати целого (до 
необходимой ширины поля число дополняется слева нулями).
<li> Модификаторы <b>h</b>, <b>l</b> (буква ell) или <b>L</b>. "h" указывает на то, что 
соответствующий аргумент должен печататься как <i>short</i> или <i>unsigned short</i>; "l" 
сообщает, что аргумент имеет тип <i>long</i> или <i>unsigned long</i>; "L" информирует, что 
аргумент принадлежит типу <i>long double</i>.
</dir>

<p>
Ширина, или точность, или обе эти характеристики могут быть специфицированы с 
помощью <b>*</b>; в этом случае необходимое число "извлекается" из следующего 
аргумента, который должен иметь тип <i>int</i> (в случае двух звездочек используются 
два аргумента).
</p>

<p>
Символы-спецификаторы и разъяснение их смысла приведены в <a href="#tableb1">таблице B-1</a>. Если 
за <b>%</b> нет правильного символа-спецификатора, результат не определен.
</p>

<pre>
int printf(const char *format, ...);
</pre>

<p>
<b>printf</b>(...) полностью эквивалентна <i>fprintf</i>(stdout, ...).
</p>

<pre>
int sprintf(char *s, const char *format, ...)
</pre>

<p>
<b>sprintf</b> действует так же, как и <i>printf</i>, только вывод осуществляет в строку <i>s</i>, 
завершая ее символом '\0'. Строка <i>s</i> должна быть достаточно большой, чтобы 
вмещать результат вывода. Возвращает количество записанных символов, в число 
которых символ '\0' не входит.
</p>

<pre>
int vprintf (const char *format, va_list arg)
int vfprintf (FILE *stream, const char *format, va_list arg)
int vsprintf (char *s, const char *format, va_list arg)
</pre>

<p>
Функции <b>vprintf</b>, <b>vfprintf</b> и <b>vsprintf</b> эквивалентны соответствующим <i>printf</i>-
функциям с той лишь разницей, что переменный список аргументов представлен 
параметром <i>arg</i>, инициализированным макросом <i>va_start</i> и, возможно, вызовами 
<i>va_arg</i> (см. в B7 описание <b>&lt;stdarg.h&gt;</b>).
</p>

<a name="tableb1"></a>
<p><b>Таблица B-1. Преобразования <i>printf</i></b></p>
<table border=1 cellpadding=5>
<tr><th>Символ</th>
<th>Тип аргумента; вид печати</th></tr>
<tr> <td><b>d</b>, <b>i</b></td>
<td><b>int</b>; знаковая десятичная запись</td></tr>
<tr> <td><b>o</b></td>
<td><b>unsigned int</b>; беззнаковая восьмеричная запись (без 0 слева) 
</td></tr>
<tr> <td><b>x</b>, <b>X</b></td>
<td><b>unsigned int</b>; беззнаковая шестнадцатеричная запись 
(без 0x или 0X слева), в качестве цифр от 10 до 15 
используются abcdef для x и ABCDEF для X</td></tr>
<tr> <td><b>u</b></td>
<td><b>unsigned int</b>; беззнаковое десятичное целое</td></tr>
<tr> <td><b>c</b></td>
<td><b>int</b>; единичный символ после преобразования в <i>unsigned 
char</i></td></tr>
<tr> <td><b>s</b></td>
<td><b>char *</b>; символы строки печатаются, пока не встретится 
'\0' или не исчерпается количество символов, указанное 
точностью</td></tr>
<tr> <td><b>f</b></td>
<td><b>double</b>; десятичная запись вида [-]mmm.ddd, где 
количество <i>d</i> специфицируется точностью. По умолчанию 
точность равна 6; нулевая точность подавляет печать 
десятичной точки</td></tr>
<tr><td><b>e</b>, <b>E</b></td>
<td><b>double</b>; десятичная запись вида [-]m.dddddde±xx или 
запись вида [-]m.ddddddE±xx, где количество <i>d</i> 
специфицируется точностью. По умолчанию точность равна 6; 
нулевая точность подавляет печать десятичной 
точки</td></tr>
<tr><td><b>g</b>, <b>G</b></td>
<td><b>double</b>; используется <b>%e</b> и <b>%E</b>, если порядок меньше -4 
или больше или равен точности; в противном случае 
используется <b>%f</b>. Завершающие нули и точка в конце не 
печатаются</td></tr>
<tr> <td><b>p</b></td>
<td><b>void *</b>; печатает в виде указателя (представление 
зависит от реализации</td></tr>
<tr> <td><b>n</b></td>
<td><b>int *</b>; число символов, напечатанных к данному моменту 
данным вызовом <i>printf</i>, <i>записывается</i> в аргумент. Никакие 
другие аргументы не преобразуются</td></tr>
<tr>
  <td><b>%</b></td>
  <td>никакие аргументы не преобразуются; печатается <b>%</b></td>
</tr>
</table>
<hr>
<a name="b13"></a>
<a href="#cnt"><h3>B1.3. Форматный ввод</h3></a>

<p>Функции <b>scanf</b> имеют дело с форматным преобразованием при вводе</p>

<pre>
int fscanf(FILE *stream, const char *format, ...);
</pre>

<p>
<b>fscanf</b> читает данные из потока <i>stream</i> под управлением <i>format</i> и 
преобразованные величины присваивает по порядку аргументам, каждый из которых 
должен быть указателем. Завершает работу, если исчерпался формат. Выдает EOF 
по исчерпании файла или перед любым преобразованием, если возникла ошибка; в 
остальных случаях функция возвращает количество преобразованных и введенных 
элементов.
</p>

<p>
Форматная строка обычно содержит спецификации преобразования, которые 
используются для управления вводом. В форматную строку могут входить:
</p>

<dir>
<li> пробелы и табуляции, которые игнорируются;
<li> обычные символы (кроме <b>%</b>), которые ожидаются в потоке ввода среди символов, отличных от символов-разделителей;
<li> спецификации преобразования, состоящие из <b>%</b>; необязательного знака <b>*</b>, 
подавляющего присваивание; необязательного числа, специфицирующего 
максимальную ширину поля; необязательных <b>h</b>, <b>l</b> или <b>L</b>, указывающих размер 
присваиваемого значения, и символа-спецификатора преобразования.
</dir>

<p>
Спецификация преобразования определяет преобразование следующего поля ввода. 
Обычно результат размещается в переменной, на которую указывает 
соответствующий аргумент. Однако если присваивание подавляется с помощью 
знака <b>*</b>, как, например, в %*s, то поле ввода просто пропускается, и никакого 
присваивания не происходят. Поле ввода определяется как строка символов, 
отличных от символов-разделителей; при этом ввод строки прекращается при 
выполнении любого из двух условий: если встретился символ-разделитель или 
если ширина поля (в случае, когда она указана) исчерпана. Из этого следует, 
что при переходе к следующему полю <i>scanf</i> может "перешагивать" через границы 
строк, поскольку символ новой строки является символом-разделителем. (Под 
символами-разделителями понимаются символы пробела, табуляции, новой строки, 
возврата каретки, вертикальной табуляции и смены страницы.)
</p>

<p>
Символ-спецификатор указывает на способ интерпретации поля ввода. 
Соответствующий аргумент должен быть указателем. Список допустимых символов-спецификаторов приводится в <a href="#tableb2">таблице B-2</a>.
</p>

<p>
Символам-спецификаторам <b>d</b>, <b>i</b>, <b>n</b>, <b>o</b>, <b>u</b> и <b>x</b> может предшествовать <b>h</b>, если 
аргумент есть указатель на <i>short</i> (а не <i>int</i>) или <b>l</b> (буква ell), если аргумент 
есть указатель на <i>long</i>. Символам-спецификаторам <b>e</b>, <b>f</b> и <b>g</b> может предшествовать 
<b>l</b>, если аргумент - указатель на <i>double</i> (а не <i>float</i>), или <b>L</b>, если аргумент - 
указатель на <i>long double</i>.
</p>

<pre>
int scanf (const char *format, ...);
</pre>

<p>
<b>scanf</b>(...) делает то же, что и <i>fscanf</i>(stdin, ...).
</p>

<pre>
int sscanf (const char *s, const char *format, ...);
</pre>

<p>
<b>sscanf</b>(s, ...) делает то же, что и <i>scanf</i>(...), только ввод символов 
осуществляет из строки <i>s</i>.
</p>
<a name="tableb2"></a>
<p><b>Таблица B-2. Преобразования <i>scanf</i></b></p>

<table border=1 cellpadding=5>
<tr><th>Символ</th>
<th>Данные на вводе; тип аргумента</th></tr>
<tr><td nowrap><b>d</b></td>
<td>десятичное целое; <b>int *</b></td></tr>
<tr><td nowrap><b>i</b></td>
<td>целое: <b>int *</b>. Целое может быть восьмеричным (с нулем 
слева) или шестнадцатеричным (с 0x или 0X слева) 
</td></tr>
<tr><td nowrap><b>o</b></td>
<td>восьмеричное целое (с нулем слева или без него); <b>int *</b></td></tr>
<tr><td nowrap><b>u</b></td>
<td>беззнаковое десятичное целое; <b>unsigned int *</b></td></tr>
<tr><td><b>x</b></td>
<td>шестнадцатеричное целое (с 0x или 0X слева или без них): <b>int *</b></td></tr>
<tr><td><b>c</b></td>
<td>символы, <b>char *</b>. Символы ввода размещаются в 
указанном массиве в количестве, заданном шириной поля; по 
умолчанию это количество равно 1. Символ'\0' не 
добавляется. Символы-разделители здесь рассматриваются 
как обычные символы и поступают в аргумент. Чтобы 
прочесть следующий символ-разделитель, используйте %1s</td></tr>
<tr><td><b>s</b></td>
<td>строка символов, отличных от символов-разделителей 
(записывается без кавычек); <b>char *</b>, указывающий на массив 
размера достаточного, чтобы вместить строку и добавляемый 
к ней символ '\0'</td></tr>
<tr><td><b>e</b>, <b>f</b>, <b>g</b></td>
<td>число с плавающей точкой; <b>float *</b>. Формат ввода для 
<i>float</i> состоит из необязательного знака, строки цифр, 
возможно с десятичной точкой, и необязательного порядка, 
состоящего из <b>E</b> или <b>e</b> и целого, возможно со 
знаком</td></tr>
<tr><td><b>p</b></td>
<td>значение указателя в виде, в котором printf ("%р") 
его напечатает; <b>void *</b></td></tr>
<tr><td><b>n</b></td>
<td>записывает в аргумент число символов, прочитанных к 
этому моменту в этом вызове; <b>int *</b>. Никакого чтения ввода 
не происходит. Счетчик числа введенных элементов не 
увеличивается</td></tr>
<tr><td> <b>[...]</b></td>
<td>выбирает из ввода самую длинную непустую строку, 
состоящую из символов, заданных в квадратных скобках: 
<b>char *</b>. В конец строки добавляется '\0'. Спецификатор 
вида <b>[]...]</b> включает <b>]</b> в задаваемое множество 
символов</td></tr>
<tr><td> 
<b>[^...]</b></td>
<td>выбирает из ввода самую длинную непустую строку, 
состоящую из символов, не входящих в заданное в скобках 
множество. В конец добавляется '\0'. Спецификатор вида 
<b>[^]...]</b> включает <b>]</b> в задаваемое множество 
символов</td></tr>
<tr><td><b>%</b></td>
<td>обычный символ <b>%</b>; присваивание не делается</td></tr>
</table>
<hr>
<a name="b14"></a>
<a href="#cnt"><h3>B1.4. Функции ввода-вывода символов</h3></a>

<pre>
int fgetc(FILE *stream);
</pre>

<p>
<b>fgetc</b> возвращает следующий символ из потока <i>stream</i> в виде <i>unsigned char</i> 
(переведенную в <i>int</i>) или EOF, если исчерпан файл или обнаружена ошибка.
</p>

<pre>
char *fgets(char *s, int n, FILE *stream);
</pre>

<p>
<b>fgets</b> читает не более <i>n-1</i> символов в массив <i>s</i>, прекращая чтение, если 
встретился символ новой строки, который включается в массив; кроме того, 
записывает в массив '\0'. Функция <i>fgets</i> возвращает <i>s</i> или, если исчерпан файл 
или обнаружена ошибка, NULL.
</p>

<pre>
int fputc(int с, FILE *stream);
</pre>

<p>
<b>fputc</b> пишет символ <i>c</i> (переведенный в <i>unsigned char</i>) в <i>stream</i>. Возвращает 
записанный символ или EOF в случае ошибки.
</p>

<pre>
int fputs(const char *s, FILE *stream);
</pre>

<p>
<b>fputs</b> пишет строку <i>s</i> (которая может не иметь '\n' ) в <i>stream</i>; возвращает 
неотрицательное целое или EOF в случае ошибки.
</p>

<pre>
int getc(FILE *stream);
</pre>

<p>
<b>getc</b> делает то же, что и <i>fgetc</i>, но в отличие от последней, если она - макрос, 
<i>stream</i> может браться более одного раза.
</p>

<pre>
int getchar(void);
</pre>

<p>
<b>getchar</b>() делает то же, что <i>getc</i>(stdin).
</p>

<pre>
char *gets(char *s);
</pre>

<p>
<b>gets</b> читает следующую строку ввода в массив <i>s</i>, заменяя символ новой строки на 
'\0'. Возвращает <i>s</i> или, если исчерпан файл или обнаружена ошибка, NULL.
</p>

<pre>
int putc(int с, FILE *stream);
</pre>

<p>
<b>putc</b> делает то же, что и <i>fputc</i>, но в отличие от последней, если <i>putc</i> - 
макрос, значение <i>stream</i> может браться более одного раза.
</p>

<pre>
int putchar(int c);
</pre>

<p>
<b>putchar</b>(c) делает тоже, что <i>putc</i>(c, stdout).
</p>

<pre>
int puts(const char *s);
</pre>

<p>
<b>puts</b> пишет строку <i>s</i> и символ новой строки в <i>stdout</i>. Возвращает EOF в случае 
ошибки, или неотрицательное значение, если запись прошла нормально.
</p>

<pre>
int ungetc(int с, FILE *stream);
</pre>

<p>
<b>ungetc</b> отправляет символ <i>c</i> (переведенный в <i>unsigned char</i>) обратно в <i>stream</i>; 
при следующем чтении из <i>stream</i> он будет получен снова. Для каждого потока 
вернуть можно не более одного символа. Нельзя возвращать EOF. В качестве 
результата <i>ungetc</i> выдает отправленный назад символ или, в случае ошибки, EOF. 
</p>
<hr>
<a name="b15"></a>
<a href="#cnt"><h3>B1.5. Функции прямого ввода-вывода</h3></a>

<pre>
size_t fread(void *ptr, size_t size, size_t nobj, FILE *stream);
</pre>
<p>
<b>fread</b> читает из потока <i>stream</i> в массив <i>ptr</i> не более <i>nobj</i> объектов размера 
<i>size</i>. Она возвращает количество прочитанных объектов, которое может быть 
меньше заявленного. Для индикации состояния после чтения следует использовать 
<i>feof</i> и <i>ferror</i>. </p>

<pre>
size_t fwrite(const void *ptr, size_t size, size_t nobj, FILE *stream);
</pre>

<p>
<b>fwrite</b> пишет из массива <i>ptr</i> в <i>stream nobj</i> объектов размера <i>size</i>; возвращает 
число записанных объектов, которое в случае ошибки меньше <i>nobj</i>.
</p>
<hr>
<a name="b16"></a>
<a href="#cnt"><h3>B1.6. Функции позиционирования файла</h3></a>

<pre>
int fseek(FILE *stream, long offset, int origin);
</pre>

<p>
<b>fseek</b> устанавливает позицию для <i>stream</i>; последующее чтение или запись будет 
производиться с этой позиции. В случае бинарного файла позиция 
устанавливается со смещением <i>offset</i> - относительно начала, если <i>origin</i> равен 
<b>SEEK_SET</b>; относительно текущей позиции, если <i>origin</i> равен <b>SEEK_CUR</b>; и 
относительно конца файла, если <i>origin</i> равен <b>SEEK_END</b>. Для текстового файла 
<i>offset</i> должен быть нулем или значением, полученным с помощью вызова функции 
<i>ftell</i>. При работе с текстовым файлом <i>origin</i> всегда должен быть равен 
<b>SEEK_SET</b>.
</p>

<pre>
long ftell(FILE *stream);
</pre>

<p>
<b>ftell</b> возвращает текущую позицию потока <i>stream</i> или -1L, в случае ошибки.
</p>

<pre>
void rewind(FILE *stream);
</pre>

<p>
<b>rewind</b>(fp) делает то же, что и fseek(fp, 0L, SEEK_SET); clearerr(fp).
</p>

<pre>
int fgetpos(FILE *stream, fpos_t *ptr);
</pre>
<p>
<b>fgetpos</b> записывает текущую позицию потока <i>stream</i> в <i>*ptr</i> для последующего 
использования ее в <i>fsetpos</i>. Тип <b>fpos_t</b> позволяет хранить такого рода 
значения, В случае ошибки <i>fgetpos</i> возвращает ненулевое значение.
</p>

<pre>
int fsetpos(FILE *stream, const fpos_t *ptr);
</pre>

<p>
<b>fsetpos</b> устанавливает позицию в <i>stream</i>, читая ее из <i>*ptr</i>, куда она была 
записана ранее с помощью <i>fgetpos</i>. В случае ошибки <i>fsetpos</i> возвращает 
ненулевое значение.
</p>
<hr>

<a name="b17"></a>
<a href="#cnt"><h3>B1.7. Функции обработки ошибок</h3></a>

<p>
Многие функции библиотеки в случае ошибки или конца файла устанавливают 
индикаторы состояния. Эти индикаторы можно проверять и изменять. Кроме того, 
целое выражение <b>errno</b> (объявленное в <b>&lt;errno.h&gt;</b>) может содержать номер 
ошибки, который дает дополнительную информацию о последней из обнаруженных 
ошибок.
</p>

<pre>
void clearerr(FILE *stream);
</pre>

<p><b>clearerr</b> очищает индикаторы конца файла и ошибки потока <i>stream</i>. </p>

<pre>
int feof(FILE *stream);
</pre>

<p>
<b>feof</b> возвращает ненулевое значение, если для потока <i>stream</i> установлен 
индикатор конца файла.
</p>

<pre>
int ferror(FILE *stream);
</pre>

<p>
<b>ferror</b> возвращает ненулевое значение, если для потока <i>stream</i> установлен 
индикатор ошибки.
</p>

<pre>
void perror(const char *s);
</pre>

<p>
<b>perror</b>(s) печатает <i>s</i> и зависимое от реализации сообщение об ошибке, 
соответствующее целому значению в <i>errno</i>, т. е. делает то же, что и обращение 
к функции <i>fprintf</i> вида</p>

<pre>
fprintf(stderr, "%s: %s\n", s, "сообщение об ошибке")
</pre>

<p>См. <i>strerror</i> в <a href="b.html#b3">параграфе B3</a>.</p>
<hr>

<a name="b2"></a>
<a href="#cnt"><h3>B2. Проверки класса символа: <b>&lt;ctype.h&gt;</b></h3></a>

<p>
Заголовочный файл <b>&lt;ctype.h&gt;</b> объявляет функции, предназначенные для 
проверок символов. Аргумент каждой из них имеет тип <i>int</i> и должен либо 
представлять собой EOF, либо быть значением <i>unsigned char</i>, приведенным к <i>int</i>; 
возвращаемое значение тоже имеет тип <i>int</i>. Функции возвращают ненулевое 
значение ("истина"), когда аргумент c удовлетворяет описанному условию или 
принадлежит указанному классу символов, и нуль в противном случае. </p>

<table border=1 cellpadding=5>
<tr><td nowrap><b>isalnum</b>(c)</td>
<td><b>isalpha</b>(c) или <b>isdigit</b>(c) есть истина</td>
</tr>
<tr><td nowrap><b>isalpha</b>(c) 
</td>
<td nowrap><b>isupper</b>(c) или <b>islower</b>(c) есть истина</td></tr>
<tr><td><b>iscntrl</b>(c) 
</td>
<td>управляющий символ</td></tr>
<tr><td nowrap><b>isdigit</b>(c)</td>
<td>десятичная цифра</td></tr>
<tr><td nowrap><b>isgraph</b>(c)</td>
<td>печатаемый символ кроме пробела</td></tr>
<tr><td nowrap><b>islower</b>(c)</td>
<td>буква нижнего регистра</td></tr>
<tr><td nowrap><b>isprint</b>(c)</td>
<td>печатаемый символ, включая пробел</td></tr>
<tr><td nowrap><b>ispunct</b>(c)</td>
<td>печатаемый символ кроме пробела, буквы или цифры</td></tr>
<tr><td nowrap><b>isspace</b>(c)</td>
<td>пробел, смена страницы, новая строка, возврат каретки, табуляция, вертикальная табуляция</td></tr>
<tr><td nowrap><b>isupper</b>(c)</td>
<td>буква верхнего регистра</td></tr>
<tr><td nowrap><b>isxdigit</b>(c)<td>шестнадцатеричная цифра</td></tr>
</table>

<p>
В наборе семибитовых ASCII-символов печатаемые символы находятся в диапазоне 
от <b>0x20</b> (' ') до <b>0x7E</b> ('~'); управляющие символы - от <b>0</b> (<i>NUL</i>) до <b>0x1F</b> (<i>US</i>) и 
0x7F (<i>DEL</i>).
</p>

<p>
Помимо перечисленных есть две функции, приводящие буквы к одному из 
регистров: </p>

<pre>
int <b>tolower</b>(int c) – переводит <i>c</i> на нижний регистр;
int <b>toupper</b>(int c) - переводит <i>c</i> на верхний регистр.
</pre>

<p>
Если <i>c</i> - буква на верхнем регистре, то <i>tolower</i>(c) выдаст эту букву на нижнем 
регистре; в противном случае она вернет <i>c</i>. Если <i>c</i> - буква на нижнем регистре, 
то <i>toupper</i>(c) выдаст эту букву на верхнем регистре; в противном случае она 
вернет <i>c</i>. </p>
<hr>
<a name="b3"></a>
<a href="#cnt"><h3>B3. Функции, оперирующие со строками: <b>&lt;string.h&gt;</b></h3></a>

<p>
Имеются две группы функций, оперирующих со строками. Они определены в 
заголовочном файле <b>&lt;string.h&gt;</b>. Имена функций первой группы начинаются с 
букв <i>str</i>, второй - с <i>mem</i>. Если копирование имеет дело с объектами, 
перекрывающимися по памяти, то, за исключением <b>memmove</b>, поведение функций не 
определено. Функции сравнения рассматривают аргументы как массивы элементов 
типа <i>unsigned char</i>.
</p>

<p>
В таблице на с. 321 переменные <i>s</i> и <i>t</i> принадлежат типу <i>char *</i>, <i>cs</i> и <i>ct</i> – типу 
<i>const char *</i>, <i>n</i> - типу <i>size_t</i>, а <i>c</i> - значение типа <i>int</i>, приведенное к типу 
<i>char</i>.
</p>

<p>
Последовательные вызовы <b>strtok</b> разбивают строку <i>s</i> на лексемы. Ограничителем 
лексемы служит любой символ из строки <i>ct</i>. В первом вызове указатель <i>s</i> не 
равен NULL. Функция находит в строке <i>s</i> первую лексему, состоящую из символов, 
не входящих в <i>ct</i>; ее работа заканчивается тем, что поверх следующего символа 
пишется '\0' и возвращается указатель на лексему. Каждый последующий вызов, в 
котором указатель <i>s</i> равен NULL, возвращает указатель на следующую лексему, 
которую функция будет искать сразу за концом предыдущей. Функция <i>strtok</i> 
возвращает NULL, если далее никакой лексемы не обнаружено. Параметр <i>ct</i> от 
вызова к вызову может варьироваться. </p>
<p>Здесь и ниже под такими выражениями как cs&lt;ct не следует понимать 
арифметическое сравнение указателей. Подразумевается лексикографическое 
сравнение, т. е. <i>cs</i> меньше (больше) <i>ct</i>, если первый несовпавший элемент в <i>cs</i> 
арифметически меньше (больше) соответствующего элемента из <i>ct</i>.— <i>Примеч. ред.</i> 
</p>

<table border=1 cellpadding=5>
<tr>
  <td nowrap>char *<b>strcpy</b>(s,ct) </td>
  <td>копирует строку <i>ct</i> в строку <i>s</i>, включая '\0'; возвращает <i>s</i></td></tr>
<tr>
  <td nowrap>char *<b>strncpy</b>(s,ct,n) </td>
  <td>копирует не более <i>n</i> символов строки <i>ct</i> в <i>s</i>; возвращает <i>s</i>. Дополняет результат символами '\0', если символов в <i>ct</i> меньше <i>n</i></td></tr>
<tr>
  <td>char *<b>strcat</b>(s,ct) </td>
  <td>приписывает <i>ct</i> к <i>s</i>; возвращает <i>s</i></td></tr>
<tr>
  <td nowrap>char *<b>strncat</b>(s,ct,n) </td>
  <td>приписывает не более <i>n</i> символов <i>ct</i> к <i>s</i>, завершая <i>s</i> символом '\0'; возвращает <i>s</i></td></tr>
<tr>
  <td nowrap>char <b>strcmp</b>(cs,st) </td>
  <td>сравнивает <i>cs</i> и <i>ct</i>; возвращает &lt;0, если cs&lt;ct; 0, если cs==ct; и &gt;0, если cs&gt;ct (<i>I.B.: вообще-то, функция возвращает int</i>)</td></tr>
<tr>
  <td nowrap>char <b>strncmp</b>(cs,ct) </td>
  <td>сравнивает не более <i>n</i> символов <i>cs</i> и <i>ct</i>; 
возвращает &lt;0, если cs&lt;ct, 0, если cs==ct, и &gt;0, если cs&gt;ct (<i>I.B.: тоже int должна возвращать</i>)</td></tr>
<tr>
  <td nowrap>char *<b>strchr</b>(cs,c) </td>
  <td>возвращает указатель на первое вхождение <i>c</i> в <i>cs</i> или, если такового не оказалось, NULL</td></tr>
<tr>
  <td nowrap>char *<b>strrchr</b>(cs,c) </td>
  <td>возвращает указатель на последнее вхождение <i>c</i> в <i>cs</i> или, если такового не оказалось, NULL</td></tr>
<tr>
  <td>size_t <b>strspn</b>(cs,ct) </td>
  <td>возвращает длину начального сегмента <i>cs</i>, состоящего из символов, входящих в строку <i>ct</i></td></tr>
<tr>
  <td>size_t <b>strcspn</b>(cs,ct) </td>
  <td>возвращает длину начального сегмента <i>cs</i>, состоящего из символов, не входящих в строку <i>ct</i></td></tr>
<tr>
  <td>char *<b>strpbrk</b>(cs,ct) </td>
  <td>возвращает указатель в <i>cs</i> на первый символ, который совпал с одним из символов, входящих в <i>ct</i>, или, если такового не оказалось, NULL</td></tr>
<tr>
  <td>char *<b>strstr</b>(cs, ct) </td>
  <td>возвращает указатель на первое вхождение <i>ct</i> в <i>cs</i> или, если такового не оказалось, NULL</td></tr>
<tr>
  <td>size_t <b>strlen</b>(cs) </td>
  <td>возвращает длину <i>cs</i></td></tr>
<tr>
  <td>char * <b>strerror</b>(n) </td>
  <td>возвращает указатель на зависящую от реализации строку, соответствующую номеру ошибки <i>n</i></td></tr>
<tr>
  <td>char * <b>strtok</b>(s, ct) </td>
  <td><i>strtok</i> ищет в <i>s</i> лексему, ограниченную символами из <i>ct</i>; более подробное описание этой функции см. ниже</td></tr>
</table>

<p>
Функции <b>mem...</b> предназначены для манипулирования с объектами как с массивами 
символов; их назначение - получить интерфейсы к эффективным программам. В 
приведенной ниже таблице <i>s</i> и <i>t</i> принадлежат типу <i>void *</i>; <i>cs</i> и <i>ct</i> - типу <i>const 
void *</i>; <i>n</i> - типу <i>size_t</i>; а <i>c</i> имеет значение типа <i>int</i>, приведенное к типу 
<i>char</i>.
</p>

<table border=1 cellpadding=5>
<tr>
  <td nowrap>void *<b>memcpy</b>(s,ct, n) </td>
  <td>копирует <i>n</i> символов из <i>ct</i> в <i>s</i> и возвращает <i>s</i></td></tr>
<tr>
  <td nowrap>void *<b>memmove</b>(s,ct,n) </td>
  <td>делает то же самое, что и <i>memcpy</i>, но работает и в случае "перекрывающихся" объектов. </td>
</tr>
<tr>
  <td nowrap>int <b>memcmp</b>(cs, ct, n) </td>
  <td>сравнивает первые <i>n</i> символов <i>cs</i> и <i>ct</i>; выдает тот же результат, что и функция <i>strcmp</i></td>
</tr>
<tr>
  <td nowrap>void *<b>memchr</b>(cs, c, n) </td>
  <td>возвращает указатель на первое вхождение символа <i>c</i> в <i>cs</i> или, если среди первых <i>n</i> символов <i>c</i> не встретилось, NULL</td>
</tr>
<tr>
  <td nowrap>void *<b>memset</b>(s, c, n) </td>
  <td> размещает символ <i>c</i> в первых <i>n</i> позициях строки <i>s</i> и возвращает <i>s</i></td>
</tr>
</table>
<hr>

<a name="b4"></a>
<a href="#cnt"><h3>B4. Математические функции: <b>&lt;math.h&gt;</b></h3></a>

<p>В заголовочном файле <b>&lt;math.h&gt;</b> описываются математические функции и 
определяются макросы. </p>

<p>
Макросы <b>EDOM</b> и <b>ERANGE</b> (находящиеся в <b>&lt;errno.h&gt;</b>) задают отличные от нуля 
целочисленные константы, используемые для фиксации ошибки области и ошибки 
диапазона; <b>HUGE_VAL</b> определена как положительное значение типа <b>double</b>. <i>Ошибка 
области</i> возникает, если аргумент выходит за область значений, для которой 
определена функция. Фиксация ошибки области осуществляется присвоением <i>errno</i> 
значения <i>EDOM</i>; возвращаемое значение зависит от реализации. Ошибка диапазона 
возникает тогда, когда результат функции не может быть представлен в виде 
<i>double</i>. В случае переполнения функция возвращает <i>HUGE_VAL</i> с правильным знаком 
и в <i>errno</i> устанавливается значение <i>ERANGE</i>. Если результат оказывается меньше, 
чем возможно представить данным типом, функция возвращает нуль, а 
устанавливается ли в этом случае <i>errno</i> в <i>ERANGE</i>, зависит от реализации. Далее 
<i>x</i> и <i>y</i> имеют тип <i>double</i>, <i>n</i> - тип <i>int</i>, и все функции возвращают значения типа 
<i>double</i>. Углы в тригонометрических функциях задаются в <i>радианах</i>. </p>

<table border=1 cellpadding=5>
<tr>
  <td><b>sin</b>(x) </td>
  <td>синус <i>x</i></td>
</tr>
<tr>
  <td><b>cos</b>(x) </td>
  <td>косинус <i>x</i></td>
</tr>
<tr>
  <td><b>tan</b>(x) </td>
  <td>тангенс <i>x</i></td>
</tr>
<tr>
  <td><b>asin</b>(x) </td>
  <td>арксинус <i>x</i> в диапазоне <i>[-pi/2,pi/2]</i>, <i>x</i> в диапазоне <i>[-1,1]</i> </td>
</tr>
<tr>
  <td><b>acos</b>(x) </td>
  <td>арккосинус <i>x</i> в диапазоне <i>[0, pi]</i>, <i>x</i> в диапазоне <i>[-1,1]</i> </td>
</tr>
<tr>
  <td><b>atan</b>(x) </td>
  <td>арктангенс <i>x</i> в диапазоне <i>[-pi/2, pi/2]</i> </td>
</tr>
<tr>
  <td><b>atan2</b>(y,x) </td>
  <td>арктангенс <i>y/x</i> в диапазоне <i>[-pi, pi]</i> </td>
</tr>
<tr>
  <td><b>sinh</b>(x) </td>
  <td>гиперболический синус <i>x</i></td>
</tr>
<tr>
  <td><b>cosh</b>(x) </td>
  <td>гиперболический косинус <i>x</i></td>
</tr>
<tr>
  <td><b>tanh</b>(x) </td>
  <td>гиперболический тангенс <i>x</i></td>
</tr>
<tr>
  <td><b>exp</b>(x) </td>
  <td>Экспоненциальная функция <i>e<sup>x</sup></i></td>
</tr>
<tr>
  <td><b>log</b>(x) </td>
  <td>натуральный логарифм <i>ln(x)</i>, <i>x &gt; 0</i></td>
</tr>
<tr>
  <td><b>log10</b>(x) </td>
  <td>десятичный логарифм <i>lg(x)</i>, <i>x &gt; 0</i></td>
</tr>
<tr>
  <td><b>pow</b>(x,y) </td>
  <td><i>x<sup>y</sup></i>, ошибка области, если <i>x = 0</i> или <i>y&lt;=0</i> или <i>x&lt;0</i> и <i>y</i> – не целое</td>
</tr>
<tr>
  <td><b>sqrt</b>(x) </td>
  <td>квадратный корень <i>x</i>, <i>x &gt;= 0</i></td>
</tr>
<tr>
  <td nowrap><b>ceil</b>(x) </td>
  <td>наименьшее целое в виде <i>double</i>, которое не меньше <i>x</i></td>
</tr>
<tr>
  <td nowrap><b>floor</b>(x) </td>
  <td>наибольшее целое в виде <i>double</i>, которое не больше <i>x</i></td>
</tr>
<tr>
  <td><b>fabs</b>(x) </td>
  <td>абсолютное значение |x|</td>
</tr>
<tr>
  <td nowrap><b>ldexp</b>(x, n) </td>
  <td>x * 2<sup>n</sup></td>
</tr>
<tr>
  <td nowrap><b>frexp</b>(x, int *еxр) </td>
  <td>
разбивает <i>x</i> на два сомножителя, первый из которых - 
нормализованная дробь в интервале [1/2, 1), которая 
возвращается, а второй - степень двойки, эта степень 
запоминается в <i>*exp</i>. Если <i>x</i> - нуль, то обе части 
результата равны нулю
  </td>
</tr>
<tr>
  <td nowrap><b>modf</b>(x,double *ip) </td>
  <td>
разбивается на целую и дробную части, обе имеют тот же 
знак, что и <i>x</i>. Целая часть запоминается в <i>*ip</i>, дробная 
часть выдается как результат
  </td>
</tr>
<tr>
  <td nowrap><b>fmod</b>(x, y)</td>
  <td>
остаток от деления <i>x</i> на <i>y</i> в виде числа с плавающей 
точкой. Знак результата совпадает со знаком <i>x</i>. Если <i>y</i> 
равен нулю, результат зависит от реализации
  </td>
</tr>
</table>
<hr>

<a name="b5"></a>
<a href="#cnt"><h3>B5. Функции общего назначения: <b>&lt;stdlib.h&gt;</b></h3></a>

<p>
Заголовочный файл <b>&lt;stdlib.h&gt;</b> объявляет функции, предназначенные для 
преобразования чисел, запроса памяти и других задач. </p>

<pre>
double atof(const char *s)
</pre>

<p>
<b>atof</b> переводит <i>s</i> в <i>double</i>; эквивалентна strtod(s, (char**) NULL). </p>

<pre>
int atoi(const char *s)
</pre>

<p>
<b>atoi</b> переводит <i>s</i> в <i>int</i>; эквивалентна (int)strtol(s, (char**)NULL, 10). </p>

<pre>
int atol(const char *s)
</pre>

<p>
<b>atol</b> переводит <i>s</i> в <i>long</i>; эквивалентна strtol(s, (char**) NULL, 10). </p>

<pre>
double strtod(const char *s, char **endp)
</pre>

<p>
<b>strtod</b> преобразует первые символы строки <i>s</i> в <i>double</i>, игнорируя начальные 
символы-разделители; запоминает указатель на непреобразованный конец в <i>*endp</i> 
(если <i>endp</i> не NULL), при переполнении она выдает <i>HUGE_VAL</i> с соответствующим 
знаком, в случае, если результат оказывается меньше, чем возможно представить 
данным типом, возвращается 0; в обоих случаях в <i>errno</i> устанавливается <i>ERANGE</i>. 
</p>

<pre>
long strtol(const char *s, char **endp, int base)
</pre>

<p>
<b>strtol</b> преобразует первые символы строки <i>s</i> в <i>long</i>, игнорируя начальные 
символы-разделители; запоминает указатель на непреобразованный конец в <i>*endp</i> 
(если <i>endp</i> не NULL). Если <i>base</i> находится в диапазоне от 2 до 36, то 
преобразование делается в предположении, что на входе - запись числа по 
основанию <i>base</i>. Если <i>base</i> равно нулю, то основанием числа считается 8, 10 или 
16; число, начинающееся с цифры 0, считается восьмеричным, а с 0x или 0X - 
шестнадцатеричным. Цифры от 10 до <i>base-1</i> записываются начальными буквами 
латинского алфавита в любом регистре. При основании, равном 16, в начале 
числа разрешается помещать 0x или 0X. В случае переполнения функция 
возвращает LONG_MAX или LONG_MIN (в зависимости от знака), a в <i>errno</i> 
устанавливается ERANGE. </p>

<pre>
unsigned long strtoul(const char *s, char **endp, int base)
</pre>
<p>
<b>strtoul</b> работает так же, как и <i>strtol</i>, с той лишь разницей, что возвращает 
результат типа <i>unsigned long</i>, а в случае переполнения - ULONG_MAX. </p>

<pre>
int rand(void)
</pre>
<p>
<b>rand</b> выдает псевдослучайное число в диапазоне от 0 до RAND_MAX; RAND_MAX не 
меньше 32767. </p>

<pre>
void srand(unsigned int seed)
</pre>
<p>
<b>srand</b> использует <i>seed</i> в качестве семени для новой последовательности 
псевдослучайных чисел. Изначально параметр <i>seed</i> равен 1. </p>

<pre>
void *calloc(size_t nobj, size_t size)
</pre>
<p>
<b>calloc</b> возвращает указатель на место в памяти, отведенное для массива <i>nobj</i> 
объектов, каждый из которых размера <i>size</i>, или, если памяти запрашиваемого 
объема нет, NULL. Выделенная область памяти обнуляется. </p>

<pre>
void *malloc(size_t size)
</pre>
<p>
<b>malloc</b> возвращает указатель на место в памяти для объекта размера <i>size</i> или, 
если памяти запрашиваемого объема нет, NULL. Выделенная область памяти не 
инициализируется. </p>

<pre>
void *realloc(void *p, size_t size)
</pre>
<p>
<b>realloc</b> заменяет на <i>size</i> размер объекта, на который указывает <i>p</i>. Для части, 
размер которой равен наименьшему из старого и нового размеров, содержимое не 
изменяется. Если новый размер больше старого, дополнительное пространство не 
инициализируется, <i>realloc</i> возвращает указатель на новое место памяти или, 
если требования не могут быть удовлетворены, NULL (<i>*p</i> при этом не 
изменяется). </p>

<pre>
void free(void *р)
</pre>
<p>
<b>free</b> освобождает область памяти, на которую указывает <i>p</i>; эта функция ничего 
не делает, если <i>p</i> равно NULL. В <i>p</i> должен стоять указатель на область памяти, 
ранее выделенную одной из функций: <i>calloc</i>, <i>malloc</i> или <i>realloc</i>. </p>

<pre>
void abort(void *р)
</pre>
<p>
<b>abort</b> вызывает аварийное завершение программы, ее действия эквивалентны 
вызову <b>raise</b>(SIGABRT). </p>

<pre>
void exit(int status)
</pre>
<p>
<b>exit</b> вызывает нормальное завершение программы. Функции, зарегистрированные с 
помощью <b>atexit</b>, выполняются в порядке, обратном их регистрации. Производится 
опорожнение буферов открытых файлов, открытые потоки закрываются, и 
управление возвращается в среду, из которой был произведен запуск программы. 
Значение <i>status</i>, передаваемое в среду, зависит от реализации, однако при 
успешном завершении программы принято передавать нуль. Можно также 
использовать значения EXIT_SUCCESS (в случае успешного завершения) и 
EXIT_FAILURE (в случае ошибки). </p>

<pre>
int atexit(void (*fcn)(void))
</pre>

<p>
<b>atexit</b> регистрирует <i>fcn</i> в качестве функции, которая будет вызываться при 
нормальном завершении программы; возвращает ненулевое значение, если 
регистрация не может быть выполнена. </p>

<pre>
int system(const char *s)
</pre>
<p>
<b>system</b> пepeдaeт cтpoку <i>s</i> oпepaциoннoй cpeдe для выпoлнeния. Если <i>s</i> есть NULL 
и существует командный процессор, то <i>system</i> возвращает ненулевое значение. 
Если <i>s</i> не NULL, то возвращаемое значение зависит от реализации. </p>

<pre>
char *getenv(const char *name)
</pre>
<p>
<b>getenv</b> возвращает строку среды, связанную с <i>name</i>, или, если никакой строки не 
существует, NULL. Детали зависят от реализации. </p>

<pre>
void *bsearch(const void *key, const void *base,
    size_t n, size_t size,
    int (*cmp)(const void *keyval, const void *datum))
</pre>

<p>
<b>bsearch</b> ищет среди <i>base[0]...base[n-1]</i> элемент с подходящим ключом <i>*key</i>. 
Функция <i>cmp</i> должна сравнивать первый аргумент (ключ поиска) со своим вторым 
аргументом (значением ключа в таблице) и в зависимости от результата 
сравнения выдавать отрицательное число, нуль или положительное значение. 
Элементы массива <i>base</i> должны быть упорядочены в возрастающем порядке, <i>bsearch</i> 
возвращает указатель на элемент с подходящим ключом или, если такого не 
оказалось, NULL.
</p>

<pre>
void qsort(void *base, size_t n, size_t size,
    int (*cmp)(const void *, const void *))
</pre>

<p>
<b>qsort</b> сортирует массив <i>base[0]...base[n-1]</i> объектов размера <i>size</i> в 
возрастающем порядке. Функция сравнения <i>cmp</i> - такая же, как и в <i>bsearch</i>.
</p>

<pre>
int abs(int n)
</pre>

<p>
<b>abs</b> возвращает абсолютное значение аргумента типа <i>int</i>.
</p>

<pre>
long labs(long n)
</pre>

<p><b>labs</b> возвращает абсолютное значение аргумента типа <i>long</i>. </p>

<pre>
div_t div(int num, int denom)
</pre>

<p>
<b>div</b> вычисляет частное и остаток от деления <i>num</i> на <i>denom</i>. Результаты типа <i>int</i> 
запоминаются в элементах <i>quot</i> и <i>rem</i> структуры <i>div_t</i>.
</p>

<pre>
ldiv_t ldiv(long num, long denom)
</pre>

<p>
<b>ldiv</b> вычисляет частное и остаток от деления <i>num</i> на <i>denom</i>. Результаты типа 
<i>long</i> запоминаются в элементах <i>quot</i> и <i>rem</i> структуры <i>ldiv_t</i>.
</p>
<hr>

<a name="b6"></a>
<a href="#cnt"><h3>B6. Диагностика: <b>&lt;assert.h&gt;</b></h3></a>

<p>
Макрос <b>assert</b> используется для включения в программу диагностических 
сообщений.
</p>

<pre>
void assert (int <i>выражение</i>)
</pre>

<p>Если <i>выражение</i> имеет значение нуль, то</p>

<pre>
assert (<i>выражение</i>)
</pre>

<p>
напечатает в <i>stderr</i> сообщение следующего вида:
</p>
<pre>
Assertion failed: <i>выражение</i>, file <i>имя-файла</i>, line <i>nnn</i>
</pre>

<p>
после чего будет вызвана функция <i>abort</i>, которая завершит вычисления. Имя 
исходного файла и номер строки будут взяты из макросов __FILE__ и __LINE__.
</p>

<p>
Если в момент включения файла <b>&lt;assert.h&gt;</b> было определено имя <b>NDEBUG</b>, то 
макрос <i>assert</i> игнорируется. </p>
<hr>

<a name="b7"></a>

<a href="#cnt"><h3>B7. Списки аргументов переменной длины: <b>&lt;stdarg.h&gt;</b></h3></a>

<p>
Заголовочный файл <b>&lt;stdarg.h&gt;</b> предоставляет средства для перебора 
аргументов функции, количество и типы которых заранее не известны. Пусть 
<i>lastarg</i> - последний именованный параметр функции <i>f</i> с переменным числом 
аргументов. Внутри <i>f</i> объявляется переменная <i>ap</i> типа <b>va_list</b>, предназначенная 
для хранения указателя на очередной аргумент: </p>

<pre>
va_list ар;
</pre>

<p>
Прежде чем будет возможен доступ к безымянным аргументам, необходимо один раз 
инициализировать <i>ap</i>, обратившись к макросу <b>va_start</b>: </p>

<pre>va_start(va_list ap, lastarg);
</pre>

<p>
С этого момента каждое обращение к макросу: </p>

<pre>
type <b>va_arg</b>(va_list ap, type);
</pre>

<p>
будет давать значение очередного безымянного аргумента указанного типа, и 
каждое такое обращение будет вызывать автоматическое приращение указателя <i>ap</i>, 
чтобы последний указывал на следующий аргумент. Один раз после перебора 
аргументов, но до выхода из <i>f</i> необходимо обратиться к макросу 
</p>
<pre>
void <b>va_end</b>(va_list ap);
</pre>
<hr>

<a name="b8"></a>
<a href="#cnt"><h3>B8. Дальние переходы: <b>&lt;setjmp.h&gt;</b></h3></a>

<p>
Объявления в <b>&lt;setjmp.h&gt;</b> предоставляют способ отклониться от обычной 
последовательности "вызов - возврат"; типичная ситуация - необходимость 
вернуться из "глубоко вложенного" вызова функции на верхний уровень, минуя 
промежуточные возвраты.
</p>
<pre>
int setjmp(jmp_buf env);
</pre>
<p>
Макрос <b>setjmp</b> сохраняет текущую информацию о вызовах в <i>env</i> для последующего 
ее использования в <b>longjmp</b>. Возвращает нуль, если возврат осуществляется 
непосредственно из <i>setjmp</i>, и не нуль, если - от последующего вызова <i>longjmp</i>. 
Обращение к <i>setjmp</i> возможно только в определенных контекстах, в основном это 
проверки в <i>if</i>, <i>switсh</i> и циклах, причем только в простых выражениях отношения.
</p>
<pre>
if (setjmp() == 0)
    /* после прямого возврата */
else
    /* после возврата из longjmp */


void longjmp(jmp_buf env, int val);
</pre>

<p>
<b>longjmp</b> восстанавливает информацию, сохраненную в самом последнем вызове 
<i>setjmp</i>, по информации из <i>env</i>; выполнение программы возобновляется, как если 
бы функция <i>setjmp</i> только что отработала и вернула ненулевое значение <i>val</i>. 
Результат будет непредсказуемым, если в момент обращения к <i>longjmp</i> функция, 
содержащая вызов <i>setjmp</i>, уже "отработала" и осуществила возврат. Доступные ей 
объекты имеют те значения, которые они имели в момент обращения к <i>longjmp</i>; 
<i>setjmp</i> не сохраняет значений.
</p>
<hr>
<a name="b9"></a>
<a href="#cnt"><h3>B9. Сигналы: <b>&lt;signal.h&gt;</b></h3></a>

<p>Заголовочный файл <b>&lt;signal.h&gt;</b> предоставляет средства для обработки 
исключительных ситуаций, возникающих во время выполнения программы, таких как 
прерывание, вызванное внешним источником или ошибкой в вычислениях. </p>

<pre>
void (*signal(int sig, void (*handler)(int)))(int)
</pre>

<p><b>signal</b> устанавливает, как будут обрабатываться последующие сигналы. Если 
параметр <i>handler</i> имеет значение <b>SIG_DFL</b>, то используется зависимая от 
реализации "обработка по умолчанию"; если значение <i>handler</i> равно <b>SIG_IGN</b>, то 
сигнал игнорируется; в остальных случаях будет выполнено обращение к функции, 
на которую указывает <i>handler</i> с типом сигнала в качестве аргумента. В число 
допустимых видов сигналов входят: </p>

<table border=1 cellpadding=5>
<tr><td><b>SIGABRT</b></td>
<td>- аварийное завершение, например от <i>abort</i>; </td></tr>
<tr><td><b>SIGFPE</b></td>
<td>- арифметическая ошибка: деление на 0 или 
переполнение; </td></tr>
<tr><td><b>SIGILL</b></td>
<td>- неверный код функции (недопустимая команда); 
</td></tr>
<tr><td><b>SIGINT</b></td>
<td>- запрос на взаимодействие, например прерывание; 
</td></tr>
<tr><td><b>SIGSEGV</b></td>
<td>- неверный доступ к памяти, например выход за 
границы; </td></tr>
<tr><td><b>SIGTERM</b></td>
<td>- требование завершения, посланное в программу. 
</td></tr>
</table>

<p><i>signal</i> возвращает предыдущее значение <i>handler</i> в случае специфицированного 
сигнала, или <b>SIGERR</b> в случае возникновения ошибки. </p>
<p>
Когда в дальнейшем появляется сигнал <i>sig</i>, сначала восстанавливается 
готовность поведения "по умолчанию", после чего вызывается функция, заданная 
в параметре <i>handler</i>, т.е. как бы выполняется вызов (*<i>handler</i>)(sig). Если 
функция <i>handler</i> вернет управление назад, то вычисления возобновятся с того 
места, где застал программу пришедший сигнал. Начальное состояние сигналов 
зависит от реализации. </p>

<pre>
int raise(int sig)
</pre>

<p><b>raise</b> посылает в программу сигнал <i>sig</i>. В случае неудачи возвращает 
ненулевое значение. </p>
<hr>

<a name="b10"></a>
<a href="#cnt"><h3>B10. Функции даты и времени: <b>&lt;time.h&gt;</b></h3></a>

<p>
Заголовочный файл <b>&lt;time.h&gt;</b> объявляет типы и функции, связанные с датой 
и временем. Некоторые функции имеют дело с местным временем, которое может 
отличаться от календарного, например в связи с зонированием времени. Типы 
<b>clосk_t</b> и <b>time_t</b> - арифметические типы для представления времени, a <i>struct tm</i> 
содержит компоненты календарного времени: </p>

<pre>
int tm_sec;   - секунды от начала минуты (0,61); -- I.B.: все же наверно от 0 до 59
int tm_min;   - минуты от начала часа (0,59);
int tm_hour;  - часы от полуночи (0,23);
int tm_mday;  - число месяца (1,31);
int tm_mon;   - месяцы с января(0,11);
int tm_year;  - годы с 1900;
int tm_wday;  - дни с воскресенья (0,6);
int tm_yday;  - дни с 1 января (0,365);
int tm_isdst; - признак летнего времени.
</pre>

<p>
Значение <i>tm_isdst</i> - положительное, если время приходится на сезон, когда 
время суток сдвинуто на 1 час вперед, нуль в противном случае и 
отрицательное, если информация не доступна.
</p>
<pre>
clock_t clock(void)
</pre>
<p>
<b>clock</b> возвращает время, фиксируемое процессором от начала выполнения 
программы, или -1, если оно не известно. Для выражения этого времени в 
секундах применяется формула clock()/CLOCKS_PER_SEC. </p>

<pre>
time_t time(time_t *tp)
</pre>
<p>
<b>time</b> возвращает текущее календарное время (т. е. время, прошедшее после 
определенной даты, - обычно после 0 ч 00 мин 00 с GMT 1-го января 1970 г. -
примеч. ред.) или -1, если время не известно. Если <i>tp</i> не равно NULL, то 
возвращаемое значение записывается и в <i>*tp</i>. </p>

<pre>
double difftime(time_t time2, time_t time1)
</pre>
<p>
<b>difftime</b> возвращает разность <i>time2 - time1</i>, выраженную в секундах. </p>

<pre>
time_t mktime(struct tm *tp)
</pre>
<p>
<b>mktime</b> преобразует местное время, заданное структурой <i>*tp</i>, в календарное, 
выдавая его в том же виде, что и функция <i>time</i>. Компоненты будут иметь 
значения в указанных диапазонах. Функция <i>mktime</i> возвращает календарное время 
или -1, если оно не представимо. </p>

<p>
Следующие четыре функции возвращают указатели на статические объекты, каждый 
из которых может быть изменен другими вызовами. </p>

<pre>
char *asctime(const struct tm *tp)
</pre>
<p><b>asctime</b> переводит время в структуре <i>*tp</i> в строку вида
</p>
<pre>
    Sun Jan 3 15:14:13 1988\n\0
</pre>
<pre>
char *ctime(const time_t *tp)
</pre>
<p><b>ctime</b> переводит календарное время в местное, что эквивалентно 
выполнению asctime(localtime(tp))</p>

<pre>
struct tm *gmtime(const time_t *tp)
</pre>

<p>
<b>gmtime</b> переводит календарное время во Всемирное координированное время 
(Coordinated Universal Time - UTC). Выдаст NULL, если UTC не известно. Имя 
этой функции, <i>gmtime</i>, происходит от Greenwich Mean Time (среднее время по 
Гринвичскому меридиану).
</p>

<pre>
struct tm *localtime(const time_t *tp)
</pre>
<p>
<b>localtime</b> переводит календарное время <i>*tp</i> в местное. </p>

<pre>
size_t strftime(char *s, size_t smax, const char *fmt, const struct tm *tp)
</pre>
<p>
<b>strftime</b> форматирует информацию о дате и времени из <i>*tp</i> в строку <i>s</i> согласно 
формату <i>fmt</i>, который имеет много общих черт с форматом, задаваемым в функции 
<i>printf</i>. Обычные символы (включая и завершающий символ '\0') копируются в <i>s</i>. 
Каждая пара, состоящая из <b>%</b> и буквы, заменяется, как показано ниже, с 
использованием значений по форме, соответствующей местным традициям. В <i>s</i> 
размещается не более <i>smax</i> символов; <i>strftime</i> возвращает число символов без 
учета '\0' или нуль, если число сгенерированных символов больше <i>smax</i>.
</p>

<table border=1 cellpadding=5>
<tr>
  <td>%a</td><td>сокращенное название дня недели</td>
</tr>
<tr>
  <td>%A</td><td>полное название дня недели</td>
</tr>
<tr>
  <td>%b</td><td>сокращенное название месяца </td>
</tr>
<tr>
  <td>%B</td><td>полное название месяца</td>
</tr>
<tr>
  <td>%c</td><td>местное представление даты и времени</td>
</tr>
<tr>
  <td>%d</td><td>день месяца (01-31) </td>
</tr>
<tr>
  <td>%H</td><td>час (24-часовое время) (00-23) </td>
</tr>
<tr>
  <td>%I</td><td>час (12-часовое время) (01-12) </td>
</tr>
<tr>
  <td>%j</td><td>день от начала года (001-366) </td>
</tr>
<tr>
  <td>%m</td><td>месяц (01-12) </td>
</tr>
<tr>
  <td>%M</td><td>минута (00-59) </td>
</tr>
<tr>
  <td>%p</td><td>местное представление AM или РМ (до или после полудня) </td>
</tr>
<tr>
  <td>%S</td><td>секунда (00-61) </td>
</tr>
<tr>
  <td>%U</td><td>неделя от начала года (считая, что воскресенье - 1-й день недели) (00-53) </td>
</tr>
<tr>
  <td>%w</td><td>день недели (0-6, номер воскресенья - 0) </td>
</tr>
<tr>
  <td>%W</td><td>неделя от начала года (считая, что понедельник - 1-й день недели) (00-53)</td>
</tr>
<tr>
  <td>%x</td><td>местное представление даты</td>
</tr>
<tr>
  <td>%X</td><td>местное представление времени</td>
</tr>
<tr>
  <td>%y</td><td>год без указания века (00-99) </td>
</tr>
<tr>
  <td>%Y</td><td>год с указанием века</td>
</tr>
<tr>
  <td>%Z</td><td>название временной зоны, если она есть</td>
</tr>
<tr>
  <td>%%</td><td>%</td>
</tr>
</table>
<hr>

<a name="b111"></a>
<a href="#cnt"><h3>B11. Зависящие от реализации пределы: <b>&lt;limits.h&gt;</b> и <b>&lt;float.h&gt;</b></h3></a>

<p>
Заголовочный файл <b>&lt;limits.h&gt;</b> определяет константы для размеров 
целочисленных типов. Ниже перечислены минимальные приемлемые величины, но в 
конкретных реализациях могут использоваться и большие значения.
</p>

<table border=1 cellpadding=5>
<tr>
  <td><b>CHAR_BIT</b><td>8</td><td>битов в значении <b>char</b></td>
</tr>
<tr>
  <td><b>SCHAR_MAX</b></td><td><b>UCHAR_MAX</b> или <b>SCHAR_MAX</b></td><td>максимальное значение <i>char</i></td>
</tr>
<tr>
  <td><b>CHAR_MIN</b></td><td>0 или <b>CHAR_MIN</b></td><td>минимальное значение <i>char</i></td>
</tr>
<tr>
  <td><b>INT_MAX</b></td><td>+32767</td><td>максимальное значение <i>int</i></td>
</tr>
<tr>
  <td><b>INT_MIN</b></td><td>-32767 (I.B.:<i>обычно это значение -32768</i>)</td><td>минимальное значение <i>int</i></td>
</tr>
<tr>
  <td><b>LONG_MAX</b></td><td>+2147463647</td><td>максимальное значение <i>long</i></td>
</tr>
<tr>
  <td><b>LONG_MIN</b></td><td>-2147483647 (I.B.:<i>обычно это значение -2147483648</i>)</td><td>минимальное значение <i>long</i></td>
</tr>
<tr>
  <td><b>SCHAR_MAX</b></td><td>+127</td><td>максимальное значение <i>signed char</i></td>
</tr>
<tr>
  <td><b>SCHAR_MIN</b></td><td>-127 (I.B.:<i>обычно это значение -128</i>)</td><td>минимальное значение <i>signed char</i></td>
</tr>
<tr>
  <td><b>SHRT_MAX</b></td><td>+32767</td><td>максимальное значение <i>short</i></td>
</tr>
<tr>
  <td><b>SHRT_MIN</b></td><td>-32767 (I.B.:<i>обычно это значение -32768</i>)</td><td>минимальное значение <i>short</i></td>
</tr>
<tr>
  <td><b>UCHAR_MAX</b></td><td>255</td><td>максимальное значение <i>unsigned char</i></td>
</tr>
<tr>
  <td><b>UINT_MAX</b></td><td>65535</td><td>максимальное значение <i>unsigned int</i></td>
</tr>
<tr>
  <td><b>ULONG_MAX</b></td><td>4294967295</td><td>максимальное значение <i>unsigned long</i></td>
</tr>
<tr>
  <td><b>USHRT_MAX</b></td><td>65535</td><td>максимальное значение <i>unsigned short</i></td>
</tr>
</table>

<p>
Имена, приведенные в следующей таблице, взяты из <b>&lt;float.h&gt;</b> и являются 
константами, имеющими отношение к арифметике с плавающей точкой. Значения 
(если они есть) представляют собой минимальные значения для соответствующих 
величин. В каждой реализации устанавливаются свои значения.
</p>

<table border=1 cellpadding=5>
<tr>
  <td><b>FLT_RADIX</b></td><td>2</td><td>основание для представления порядка, например: 2, 16</td>
</tr>
<tr>
  <td><b>FLT_ROUNDS</b></td><td></td><td>способ округления при сложении чисел с плавающей точкой</td>
</tr>
<tr>
  <td><b>FLT_DIG</b></td><td>6</td><td>количество верных десятичных цифр</td>
</tr>
<tr>
  <td><b>FLT_EPSILON</b></td><td>1E-5</td><td>минимальное х, такое, что 1.0 + х != 1.0</td>
</tr>
<tr>
  <td><b>FLT_MANT_DIG</b></td><td></td><td>количество цифр по основанию <b>FLT_RADIX</b> в мантиссе</td>
</tr>
<tr>
  <td><b>FLT_MAX</b></td><td>1E+37</td><td>максимальное число с плавающей точкой</td>
</tr>
<tr>
  <td><b>FLT_MAX_EXP</b></td><td></td><td>максимальное n, такое, что <b>FLT_RADIX</b><sup>n</sup>-1 представимо</td>
</tr>
<tr>
  <td><b>FLT_MIN</b></td><td>1E-37</td><td>минимальное нормализованное число с плавающей точкой</td>
</tr>
<tr>
  <td><b>FLT_MIN_EXP</b></td><td></td><td>минимальное n, такое, что 10<sup>n</sup> представимо в виде нормализованного числа</td>
</tr>
<tr>
  <td><b>DBL_DIG</b></td><td>10</td><td>количество верных десятичных цифр для типа <i>double</i></td>
</tr>
<tr>
  <td><b>DBL_EPSILON</b></td><td>1E-9</td><td>минимальное х, такое, что 1.0 + x != 1.0, где x принадлежит типу <i>double</i> </td>
</tr>
<tr>
  <td><b>DBL_MANT_DIG</b></td><td></td><td>количество цифр по основанию <b>FLT_RADIX</b> в мантиссе для чисел типа <i>double</i></td>
</tr>
<tr>
  <td><b>DBL_MAX</b></td><td>1E+37</td><td>максимальное число с плавающей точкой типа <i>double</i></td>
</tr>
<tr>
  <td><b>DBL_MAX_EXP</b></td><td></td><td>максимальное n, такое, что <b>FLT_RADIX</b><sup>n</sup>-1 представимо в виде числа типа <i>double</i></td>
</tr>
<tr>
  <td><b>DBL_MIN</b></td><td>1E-37</td><td>минимальное нормализованное число с плавающей точкой типа <i>double</i></td>
</tr>
<tr>
  <td><b>DBL_MIN_EXP</b></td><td></td><td>минимальное n, такое, что 10<sup>n</sup> представимо в виде нормализованного числа типа <i>double</i></td>
</tr>
</table>

