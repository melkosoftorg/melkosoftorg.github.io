<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>Глава 6. Структуры</title>
</head>
<body bgcolor=#d3d3d3>
<font face=Arial>
<hr>
<a name="cnt"></a><p><a href="index.html#content">Содержание</a></p>
<h2>Глава 6. Структуры</h2>
<hr>
<a href="#p61">6.1 Основные сведения о структурах</a><br>
<a href="#p62">6.2 Структуры и функции</a><br>
<a href="#p63">6.3 Массивы структур</a><br>
<a href="#p64">6.4 Указатели на структуры</a><br>
<a href="#p65">6.5 Структуры со ссылками на себя</a><br>
<a href="#p66">6.6 Просмотр таблиц</a><br>
<a href="#p67">6.7 Средство typedef</a><br>
<a href="#p68">6.8 Объединения</a><br>
<a href="#p69">6.9 Битовые поля</a><br>
<hr>

<p>
<i>Структура</i> - это одна или несколько переменных (возможно, различных типов), 
которые для удобства работы с ними сгруппированы под одним именем. (В 
некоторых языках, в частности в Паскале, структуры называются записями.) 
Структуры помогают в организации сложных данных (особенно в больших 
программах), поскольку позволяют группу связанных между собой переменных 
трактовать не как множество отдельных элементов, а как единое целое.
</p>
<p>
Традиционный пример структуры - строка платежной ведомости. Она содержит 
такие сведения о служащем, как его полное имя, адрес, номер карточки 
социального страхования, зарплата и т. д. Некоторые из этих характеристик 
сами могут быть структурами: например, полное имя состоит из нескольких 
компонент (фамилии, имени и отчества); аналогично адрес, и даже зарплата. 
Другой пример (более типичный для Си) - из области графики: точка есть пара 
координат, прямоугольник есть пара точек и т. д.
</p>
<p>
Главные изменения, внесенные стандартом ANSI в отношении структур, - это 
введение для них операции присваивания. Структуры могут копироваться, над 
ними могут выполняться операции присваивания, их можно передавать функциям в 
качестве аргументов, а функции могут возвращать их в качестве результатов. В 
большинстве компиляторов уже давно реализованы эти возможности, но теперь они 
точно оговорены стандартом. Для автоматических структур и массивов теперь 
также допускается инициализация.
</p>
<hr>
<a name="p61"></a>
<h3><a href="#cnt">6.1 Основные сведения о структурах</a></h3>

<p>
Сконструируем несколько графических структур. В качестве основного объекта 
выступает точка с координатами <i>x</i> и <i>y</i> целого типа.
</p>

<img src="./krfigs/fig6_1.jpg"></img>

<p>
Указанные две компоненты можно поместить в структуру, объявленную, например, 
следующим образом:
</p>

<pre>
struct point {
    int x;
    int y;
};
</pre>

<p>
Объявление структуры начинается с ключевого слова <b>struct</b> и содержит список 
объявлений, заключенный в фигурные скобки. За словом <b>struct</b> может следовать 
имя, называемое <i>тегом  структуры</i> (от английского слова tag — ярлык, этикетка. 
— Примеч. пер.), <i>point</i> в нашем случае. Тег дает название 
структуре данного вида и далее может служить кратким обозначением той части 
объявления, которая заключена в фигурные скобки.
</p>
<p>
Перечисленные в структуре переменные называются <i>элементами</i> (<i>members</i> - 
В некоторых изданиях, в том числе во 2-м издании на русским языке этой 
книги structure members переводится как члены структуры. - Примеч. ред). Имена 
элементов и тегов без каких-либо коллизий могут совпадать с именами обычных 
переменных (т. е. не элементов), так как они всегда различимы по контексту. 
Более того, одни и те же имена элементов могут встречаться в разных 
структурах, хотя, если следовать хорошему стилю программирования, лучше 
одинаковые имена давать только близким по смыслу объектам.
</p>
<p>
Объявление структуры определяет тип. За правой фигурной скобкой, закрывающей 
список элементов, могут следовать переменные точно так же, как они могут быть 
указаны после названия любого базового типа. Таким образом, выражение
</p>

<pre>
struct {...} x, y, z;
</pre>

<p>
с точки зрения синтаксиса аналогично выражению
</p>

<pre>
int х, у, z;
</pre>

<p>
в том смысле, что и то и другое объявляет <i>x</i>, <i>y</i> и <i>z</i> переменными указанного 
типа; и то и другое приведет к выделению памяти соответствующего размера.
</p>
<p>
Объявление структуры, не содержащей списка переменных, не резервирует памяти; 
оно просто описывает шаблон, или образец структуры. Однако если структура 
имеет тег, то этим тегом далее можно пользоваться при определении структурных 
объектов. Например, с помощью заданного выше описания структуры <i>point</i> строка
</p>

<pre>
struct point pt;
</pre>

<p>
определяет структурную переменную <i>pt</i> типа <i>struct point</i>. Структурную 
переменную при ее определении можно инициализировать, формируя список 
инициализаторов ее элементов в виде константных выражений:
</p>

<pre>
struct point maxpt = {320, 200};
</pre>

<p>
Инициализировать автоматические структуры можно также присваиванием или 
обращением к функции, возвращающей структуру соответствующего типа.
</p>
<p>
Доступ к отдельному элементу структуры осуществляется посредством конструкции 
вида:
</p>

<pre>
<i>имя-структуры</i>.<i>элемент</i>
</pre>

<p>
Оператор доступа к элементу структуры <b>.</b> соединяет имя структуры и имя 
элемента. Чтобы напечатать, например, координаты точки <i>pt</i>, годится следующее 
обращение к <i>printf</i>:
</p>

<pre>
printf("%d, %d", pt.x, pt.y);
</pre>

<p>
Другой пример: чтобы вычислить расстояние от начала координат (0,0) до <i>pt</i>, 
можно написать
</p>

<pre>
double dist, sqrt(double);

dist = sqrt((double)pt.x * pt.x + (double)pt.y * pt.y);
</pre>

<p>
Структуры могут быть вложены друг в друга. Одно из возможных представлений 
прямоугольника - это пара точек на углах одной из его диагоналей:
</p>

<img src="./krfigs/fig6_2.jpg"></img>


<pre>
struct rect {
    struct point pt1;
    struct point pt2;
};
</pre>

<p>
Структура <i>rect</i> содержит две структуры <i>point</i>. Если мы объявим <i>screen</i> как
</p>

<pre>
struct rect screen;
</pre>

<p>
то
</p>

<pre>
screen.pt1.x
</pre>

<p>
обращается к координате <i>x</i> точки <i>pt1</i> из <i>screen</i>.
</p>
<hr>
<a name="p62"></a>
<h3><a href="#cnt">6.2 Структуры и функции</a></h3>


<p>
Единственно возможные операции над структурами - это их копирование, 
присваивание, взятие адреса с помощью & и осуществление доступа к ее 
элементам. Копирование и присваивание также включают в себя передачу функциям 
аргументов и возврат ими значений. Структуры нельзя сравнивать. 
Инициализировать структуру можно списком константных значений ее элементов; 
автоматическую структуру также можно инициализировать присваиванием.
</p>
<p>
Чтобы лучше познакомиться со структурами, напишем несколько функций, 
манипулирующих точками и прямоугольниками. Возникает вопрос: а как передавать 
функциям названные объекты? Существует по крайней мере три подхода: 
передавать компоненты по отдельности, передавать всю структуру целиком и 
передавать указатель на структуру. Каждый подход имеет свои плюсы и минусы.
</p>
<p>
Первая функция, <i>makepoint</i>, получает два целых значения и возвращает структуру 
<i>point</i>.
</p>

<pre>
/* makepoint: формирует точку по компонентам x и y */
struct point makepoint(int х, int у)
{
    struct point temp;

    temp.x = х;
    temp.у = у;
    return temp;
}
</pre>

<p>
Заметим: никакого конфликта между именем аргумента и именем элемента 
структуры не возникает; более того, сходство подчеркивает родство 
обозначаемых им объектов.
</p>
<p>
Теперь с помощью <i>makepoint</i> можно выполнять динамическую инициализацию любой 
структуры или формировать структурные аргументы для той или иной функции:
</p>

<pre>
struct rect screen;
struct point middle;
struct point makepoint(int, int);

screen.pt1 = makepoint(0, 0);
screen.pt2 = makepoint(XMAX, YMAX);
middle = makepoint((screen.pt1.x + screen.pt2.x)/2,
                   (screen.pt1.y + screen.pt2.y)/2);
</pre>

<p>
Следующий шаг состоит в определении ряда функций, реализующих различные 
операции над точками. В качестве примера рассмотрим следующую функцию:
</p>

<pre>
/* addpoint: сложение двух точек */
struct point addpoint(struct point p1, struct point p2)
{
    p1.x += p2.x;
    p1.y += p2.y;
    return p1;
}
</pre>
<p>
Здесь оба аргумента и возвращаемое значение - структуры. Мы увеличиваем 
компоненты прямо в р1 и не используем для этого временной переменной, чтобы 
подчеркнуть, что структурные параметры передаются по значению так же, как и 
любые другие.
</p>
<p>
В качестве другого примера приведем функцию <i>ptinrect</i>, которая проверяет: 
находится ли точка внутри прямоугольника, относительно которого мы принимаем 
соглашение, что в него входят его левая и нижняя стороны, но не входят 
верхняя и правая.
</p>

<pre>
/* ptinrect: возвращает 1, если p в r, и 0 в противном случае */
int ptinrect(struct point р, struct rect r)
{
    return p.x >= r.pt1.x && p.x < r.pt2.x
        && p.y >= r.pt1.y && p.y < r.pt2.y;
}
</pre>

<p>
Здесь предполагается, что прямоугольник представлен в стандартном виде, т.е. 
координаты точки <i>pt1</i> меньше соответствующих координат точки <i>pt2</i>. Следующая 
функция гарантирует получение прямоугольника в каноническом виде.
</p>

<pre>
#define min(a, b) ((a) < (b) ? (a) : (b))
#define max(a, b) ((a) > (b) ? (a) : (b))

/* canonrect: канонизация координат прямоугольника */
struct rect canonrect(struct rect r)
{
    struct rect temp;

    temp.pt1.x = min(r.pt1.x, r.pt2.x);
    temp.ptl.y = min(r.pt1.y, r.pt2.у);
    temp.pt2.x = max(r.pt1.x, r.pt2.x);
    temp.pt2.y = max(r.pt1.y, r.pt2.y);
    return temp;
}
</pre>

<p>
Если функции передается большая структура, то, чем копировать ее целиком, 
эффективнее передать указатель на нее. Указатели на структуры ничем не 
отличаются от указателей на обычные переменные. Объявление
</p>

<pre>
struct point *pp;
</pre>

<p>
сообщает, что <i>pp</i> - это указатель на структуру типа <i>struct point</i>. Если <i>pp</i> 
указывает на структуру <i>point</i>, то <i>*pp</i> - это сама структура, а <i>(*pp).x</i> и <i>(*pp).y</i> 
- ее элементы. Используя указатель <i>pp</i>, мы могли бы написать
</p>

<pre>
struct point origin, *pp;

pp = &origin;
printf("origin: (%d,%d)\n", (*pp).x, (*pp).y);
</pre>

<p>
Скобки в <i>(*pp).x</i> необходимы, поскольку приоритет оператора <b>.</b> выше, чем 
приоритет <b>*</b>. Выражение <i>*pp.x</i> будет проинтерпретировано как <i>*(pp.x)</i>, что 
неверно, поскольку <i>pp.x</i> не является указателем.
</p>
<p>
Указатели на структуры используются весьма часто, поэтому для доступа к ее 
элементам была придумана еще одна, более короткая форма записи. Если <i>p</i> — 
указатель на структуру, то
</p>

<pre>
р-><i>элемент-структуры</i> 
</pre>

<p>
есть ее отдельный элемент. (Оператор <b>-&gt;</b> состоит из знака -, за которым сразу 
следует знак &gt;.) Поэтому <i>printf</i> можно переписать в виде
</p>

<pre>
printf("origin: (%d,%d)\n", pp->х, pp->y);
</pre>

Операторы <b>.</b> и <b>-></b> выполняются слева направо. Таким образом, при наличии 
объявления

<pre>
struct rect r, *rp = &r;
</pre>

<p>
следующие четыре выражения будут эквивалентны:
</p>

<pre>
r.pt1.x
rp->pt1.x
(r.pt1).x
(rp->pt1).x
</pre>

<p>
Операторы доступа к элементам структуры <b>.</b> и <b>-&gt;</b> вместе с операторами вызова 
функции <b>()</b> и индексации массива <b>[]</b> занимают самое высокое положение в 
иерархии приоритетов и выполняются раньше любых других операторов. Например, 
если задано объявление
</p>

<pre>
struct {
    int len;
    char *str;
} *p;
</pre>

<p>
то
</p>

<pre>
++p->len
</pre>

<p>
увеличит на 1 значение элемента структуры <i>len</i>, а не указатель <i>p</i>, поскольку в 
этом выражении как бы неявно присутствуют скобки: <i>++(p->len)</i>. Чтобы изменить 
порядок выполнения операций, нужны явные скобки. Так, в <i>(++р)->len</i>, прежде 
чем взять значение <i>len</i>, программа прирастит указатель <i>p</i>. В <i>(р++)->len</i> 
указатель <i>p</i> увеличится после того, как будет взято значение <i>len</i> (в последнем 
случае скобки не обязательны).
</p>
<p>
По тем же правилам <i>*p->str</i> обозначает содержимое объекта, на который 
указывает <i>str</i>; <i>*p->str++</i> прирастит указатель <i>str</i> после получения значения 
объекта, на который он указывал (как и в выражении <i>*s++</i>), <i>(*p->str)++</i> 
увеличит значение объекта, на который указывает <i>str</i>; <i>*p++->str</i> увеличит <i>p</i> 
после получения того, на что указывает <i>str</i>.
</p>
<hr>
<a name="p63"></a>
<h3><a href="#cnt">6.3 Массивы структур</a></h3>

<p>
Рассмотрим программу, определяющую число вхождений каждого ключевого слова в 
текст Си-программы. Нам нужно уметь хранить ключевые слова в виде массива 
строк и счетчики ключевых слов в виде массива целых. Один из возможных 
вариантов - это иметь два параллельных массива:
</p>

<pre>
char *keyword[NKEYS];
int keycount[NKEYS];
</pre>

<p>
Однако именно тот факт, что они параллельны, подсказывает нам другую 
организацию хранения - через массив структур. Каждое ключевое слово можно 
описать парой характеристик
</p>

<pre>
char *word;
int count;
</pre>

<p>
Такие пары составляют массив. Объявление
</p>

<pre>
struct key {
    char *word;
    int count;
} keytab[NKEYS];
</pre>

<p>
объявляет структуру типа <i>key</i> и определяет массив <i>keytab</i>, каждый элемент 
которого является структурой этого типа и которому где-то будет выделена 
память. Это же можно записать и по-другому:
</p>
<pre>
struct key {
    char *word;
    int count;
};
struct key keytab[NKEYS];
</pre>
<p>
Так как <i>keytab</i> содержит постоянный набор имен, его легче всего сделать 
внешним массивом и инициализировать один раз в момент определения. 
Инициализация структур аналогична ранее демонстрировавшимся инициализациям - 
за определением следует список инициализаторов, заключенный в фигурные 
скобки:
</p>
<pre>
struct key {
    char *word;
    int count;
} keytab[] = {
    "auto", 0,
    "break", 0,
    "case", 0,
    "char", 0,
    "const", 0,
    "continue", 0,
    "default", 0,
    /*...*/
    "unsigned", 0,
    "void", 0,
    "volatile", 0,
    "while", 0
};
</pre>
<p>
Инициализаторы задаются парами, чтобы соответствовать конфигурации структуры. 
Строго говоря, пару инициализаторов для каждой отдельной структуры следовало 
бы заключить в фигурные скобки, как, например, в
</p>
<pre>
{ "auto", 0 },
{ "break", 0 },
{ "case", 0 },
    ...
</pre>
<p>
Однако когда инициализаторы - простые константы или строки символов и все они 
имеются в наличии, во внутренних скобках нет необходимости. Число элементов 
массива <i>keytab</i> будет вычислено по количеству инициализаторов, поскольку они 
представлены полностью, а внутри квадратных скобок "[]" ничего не задано.
</p>
<p>
Программа подсчета ключевых слов начинается с определения <i>keytab</i>. Программа 
<i>main</i> читает ввод, многократно обращаясь к функции <i>getword</i> и получая на каждом 
ее вызове очередное слово. Каждое слово ищется в <i>keytab</i>. Для этого 
используется функция бинарного поиска, которую мы написали в <a href="ch3kr.html">главе 3</a>. Список 
ключевых слов должен быть упорядочен в алфавитном порядке.
</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;

#define MAXWORD 100

int getword(char *, int);
int binsearch(char *, struct key *, int);

/* подсчет ключевых слов Си */
main()
{
    int n;
    char word[MAXWORD];

    while(getword(word, MAXWORD) != EOF)
        if (isalpha(word[0]))
            if ((n = binsearch(word, keytab, NKEYS)) >= 0)
                keytab[n].count++;
    for (n = 0; n < NKEYS; n++)
        if (keytab[n].count > 0)
            printf("%4d %s\n", keytab[n].count, keytab[n].word);
    return 0;
}

/* binsearch: найти слово в tab[0]...tab[n-1] */
int binsearch(char *word, struct key tab[], int n)
{
    int cond;
    int low, high, mid;

    low = 0;
    high = n-1;
    while (low &lt;= high) {
        mid = (low + high)/2;
        if ((cond = strcmp(word, tab[mid].word)) < 0)
            high = mid - 1;
        else if (cond > 0)
            low = mid + 1;
        else
            return mid;
    }
    return -1;
}
</pre>
<p>
Чуть позже мы рассмотрим функцию <i>getword</i>, а сейчас нам достаточно знать, что 
при каждом ее вызове получается очередное слово, которое запоминается в 
массиве, заданном первым аргументом.
</p>
<p>
NKEYS - количество ключевых слов в <i>keytab</i>. Хотя мы могли бы подсчитать число 
таких слов вручную, гораздо легче и безопасней сделать это с помощью машины, 
особенно если список ключевых слов может быть изменен. Одно из возможных 
решений — поместить в конец списка инициализаторов пустой указатель (NULL) и 
затем перебирать в цикле элементы <i>keytab</i>, пока не встретится концевой 
элемент.
</p>
<p>
Но возможно и более простое решение. Поскольку размер массива полностью 
определен во время компиляции и равен произведению количества элементов 
массива на размер его отдельного элемента, число элементов массива можно 
вычислить по формуле
</p>
<pre>
<i>размер</i> keytab / <i>размер</i> struct key
</pre>
<p>
В Си имеется унарный оператор <b>sizeof</b>, который работает во время компиляции. 
Его можно применять для вычисления размера любого объекта. Выражения
</p>
<pre>
sizeof <i>объект</i> 
</pre>
<p>
и 
</p>
<pre>
sizeof (<i>имя типа</i>)
</pre>
<p>
выдают целые значения, равные размеру указанного объекта или типа в байтах. 
(Строго говоря, <b>sizeof</b> выдает беззнаковое целое, тип которого <b>size_t</b> 
определена заголовочном файле <b>&lt;stddef.h&gt;</b>.) Что касается объекта, то это может 
быть переменная, массив или структура. В качестве имени типа может выступать 
имя базового типа (<i>int</i>, <i>double</i> ...) или имя производного типа, например 
структуры или указателя.
</p>
<p>
В нашем случае, чтобы вычислить количество ключевых слов, размер массива надо 
поделить на размер одного элемента. Указанное вычисление используется в 
инструкции <i>#define</i> для установки значения NKEYS:
</p>
<pre>
#define NKEYS (sizeof keytab / sizeof(struct key))
</pre>
<p>
Этот же результат можно получить другим способом - поделить размер массива на 
размер какого-то его конкретного элемента:
</p>
<pre>
#define NKEYS (sizeof keytab / sizeof keytab[0])
</pre>
<p>
Преимущество такого рода записей в том, что их не надо коppектировать при 
изменении типа.
</p>
<p>
Поскольку препроцессор не обращает внимания на имена типов, оператор <b>sizeof</b> 
нельзя применять в <b>#if</b>. Но в <b>#define</b> выражение препроцессором не вычисляется, 
так что предложенная нами запись допустима.
</p>
<p>
Теперь поговорим о функции <i>getword</i>. Мы написали <i>getword</i> в несколько более 
общем виде, чем требуется для нашей программы, но она от этого не стала 
заметно сложнее. Функция <i>getword</i> берет из входного потока следующее "слово". 
Под словом понимается цепочка букв-цифр, начинающаяся с буквы, или отдельный 
символ, отличный от символа-разделителя. В случае конца файла функция 
возвращает EOF, в остальных случаях ее значением является код первого символа 
слова или сам символ, если это не буква.
</p>
<pre>
/* getword: принимает следующее слово или символ из ввода */
int getword (char *word, int lim)
{
    int c, getch(void);
    void ungetch(int);
    char *w = word;

    while (isspace(c = getch()))
        ;
    if (c != EOF)
        *w++ = c;
    if (!isalpha(c)) {
        *w = '\0';
        return c;
    }
    for ( ; --lim > 0; w++)
        if (!isalnum(*w = getch())) {
            ungetch(*w);
            break;
        }
    *w = '\0';
    return word[0];
}
</pre>
<p>
Функция <i>getword</i> обращается к <i>getch</i> и <i>ungetch</i>, которые мы написали в <a href="ch4kr.html">главе 4</a>. 
По завершении набора букв-цифр оказывается, что <i>getword</i> взяла лишний символ. 
Обращение к <i>ungetch</i> позволяет вернуть его назад во входной поток. В <i>getword</i> 
используются также <b>isspace</b> - для пропуска символов-разделителей, <b>isalpha</b> - 
для идентификации букв и <b>isalnum</b> - для распознавания букв-цифр. Все они 
описаны в стандартном заголовочном файле <b>&lt;ctype.h&gt;</b>.
</p>
<p>
<b>Упражнение 6.1</b>. Haшa вepcия <i>getword</i> не обрабатывает должным образом знак 
подчеркивания, строковые константы, комментарии и управляющие строки 
препроцессора. Напишите более совершенный вариант программы.
</p>
<hr>
<a name="p64"></a>
<h3><a href="#cnt">6.4 Указатели на структуры</a></h3>

<p>
Для иллюстрации некоторых моментов, касающихся указателей на структуры и 
массивов структур, перепишем программу подсчета ключевых слов, пользуясь для 
получения элементов массива вместо индексов указателями.
</p>
<p>
Внешнее объявление массива <i>keytab</i> остается без изменения, a <i>main</i> и <i>binsearch</i> 
нужно модифицировать.
</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;
#define MAXWORD 100

int getword(char *, int);
struct key *binsearch(char *, struct key *, int);

/* подсчет ключевых слов Си: версия с указателями */
main()
{
    char word[MAXWORD];
    struct key *p;
    while (getword(word, MAXWORD) != EOF)
        if (isalpha(word[0]))
            if ((p = binsearch(word, keytab, NKEYS)) != NULL)
                p->count++;
    for (p = keytab; p < keytab + NKEYS; p++)
        if (p->count > 0)
            printf("%4d %s\n", p->count, p->word);
    return 0;
}

/* binsearch: найти слово word в tab[0]...tab[n-1] */
struct key *binsearch(char *word, struct key *tab, int n)
{
    int cond;
    struct key *low = &tab[0];
    struct key *high = &tab[n];
    struct key *mid;
    while (low < high) {
        mid = low + (high - low) / 2;
        if ((cond = strcmp(word, mid->word)) < 0)
            high = mid;
        else if (cond > 0)
            low = mid + 1;
        else
            return mid;
    }
    return NULL;
}
</pre>
<p>
Некоторые детали этой программы требуют пояснений. Во-первых, описание 
функции <i>binsearch</i> должно отражать тот факт, что она возвращает указатель на 
<i>struct key</i>, а не целое, это объявлено как в прототипе функции, так и в 
функции <i>binsearch</i>. Если <i>binsearch</i> находит слово, то она выдает указатель на 
него, в противном случае она возвращает NULL. Во-вторых, к элементам <i>keytab</i> 
доступ в нашей программе осуществляется через указатели. Это потребовало 
значительных изменений в <i>binsearch</i>. Инициализаторами для <i>low</i> и <i>high</i> теперь 
служат указатели на начало и на место сразу после конца массива. Вычисление 
положения среднего элемента с помощью формулы
</p>
<pre>
mid = (low + high) / 2     /* НЕВЕРНО */
</pre>
<p>
не годится, поскольку указатели нельзя складывать. Однако к ним можно 
применить операцию вычитания, и так как <i>high-low</i> есть число элементов, 
присваивание
</p>
<pre>
mid = low + (high-low) / 2
</pre>
<p>
превратит <i>mid</i> в указатель на элемент, лежащий посередине между <i>low</i> и <i>high</i>.
</p>
<p>
Самое важное при переходе на новый вариант программы - сделать так, чтобы не 
генерировались неправильные указатели и не было попыток обратиться за пределы 
массива. Проблема в том, что и <i>&tab[-1]</i>, и <i>&tab[n]</i> находятся вне границ 
массива. Первый адрес определенно неверен, нельзя также осуществить доступ и 
по второму адресу. По правилам языка, однако, гарантируется, что адрес ячейки 
памяти, следующей сразу за концом массива (т. е. <i>&tab[n]</i>), в арифметике с 
указателями воспринимается правильно.
</p>
<p>
В главной программе <i>main</i> мы написали
</p>
<pre>
for (р = keytab; р < keytab + NKEYS; р++)
</pre>
<p>
Если <i>p</i> - это указатель на структуру, то при выполнении операций с <i>р</i> 
учитывается размер структуры. Поэтому <i>р++</i> увеличит р на такую величину, чтобы 
выйти на следующий структурный элемент массива, а проверка условия вовремя 
остановит цикл. </p>
<p>
Не следует, однако, полагать, что размер структуры равен сумме размеров ее 
элементов. Вследствие выравнивания объектов разной длины в структуре могут 
появляться безымянные "дыры". Например, если переменная типа <i>char</i> занимает 
один байт, а <i>int</i> - четыре байта, то для структуры
</p>
<pre>
struct {
    char с;
    int i;
};
</pre>
<p>
может потребоваться восемь байтов, а не пять. Оператор <i>sizeof</i> возвращает 
правильное значение.
</p>
<p>
Наконец, несколько слов относительно формата программы. Если функция 
возвращает значение сложного типа, как, например, в нашем случае она 
возвращает указатель на структуру:
</p>
<pre>
struct key *binsearch(char *word, struct key *tab, int n)
</pre>
<p>
то "высмотреть" имя функции оказывается совсем не просто. В подобных случаях 
иногда пишут так:
</p>
<pre>
struct key * 
binsearch(char *word, struct key *tab, int n)
</pre>
<p>
Какой форме отдать предпочтение - дело вкуса. Выберите ту, которая больше 
всего вам нравится, и придерживайтесь ее.
</p>
<hr>
<a name="p65"></a>
<h3><a href="#cnt">6.5 Структуры со ссылками на себя</a></h3>

<p>
Предположим, что мы хотим решить более общую задачу - написать программу, 
подсчитывающую частоту встречаемости для любых слов входного потока. Так как 
список слов заранее не известен, мы не можем предварительно упорядочить его и 
применить бинарный поиск. Было бы неразумно пользоваться и линейным поиском 
каждого полученного слова, чтобы определять, встречалось оно ранее или нет - 
в этом случае программа работала бы слишком медленно. (Более точная оценка: 
время работы такой программы пропорционально квадрату количества слов.) Как 
можно организовать данные, чтобы эффективно справиться со списком 
произвольных слов?
</p>
<p>
Один из способов - постоянно поддерживать упорядоченность уже полученных 
слов, помещая каждое новое слово в такое место, чтобы не нарушалась имеющаяся 
упорядоченность. Делать это передвижкой слов в линейном массиве не следует, - 
хотя бы потому, что указанная процедура тоже слишком долгая. Вместо этого мы 
воспользуемся структурой данных, называемой бинарным деревом.
</p>
<p>
В дереве на каждое отдельное слово предусмотрен "узел", который содержит:
</p>
<pre>
    - указатель на текст слова;
    - счетчик числа встречаемости;
    - указатель на левый сыновний узел;
    - указатель на правый сыновний узел.
</pre>
<p>
У каждого узла может быть один или два сына, или узел вообще может не иметь 
сыновей.
</p>
<p>
Узлы в дереве располагаются так, что по отношению к любому узлу левое 
поддерево содержит только те слова, которые лексикографически меньше, чем 
слово данного узла, а правое - слова, которые больше него. Вот как выглядит 
дерево, построенное для фразы "<i>now is the time for all good men to come to 
the aid of their party</i>" ("настало время всем добрым людям помочь своей 
партии"), по завершении процесса, в котором для каждого нового слова в него 
добавлялся новый узел:
</p>
<img src="./krfigs/fig6_3.jpg"></img>
<p>
Чтобы определить, помещено ли уже в дерево вновь поступившее слово, начинают 
с корня, сравнивая это слово со словом из корневого узла. Если они совпали, 
то ответ на вопрос — положительный. Если новое слово меньше слова из дерева, 
то поиск продолжается в левом поддереве, если больше, то — в правом. Если же 
в выбранном направлении поддерева не оказалось, то этого слова в дереве нет, 
а пустующая позиция, говорящая об отсутствии поддерева, как раз и есть то 
место, куда нужно "подвесить" узел с новым словом. Описанный процесс по сути 
рекурсивен, так как поиск в любом узле использует результат поиска в одном из 
своих сыновних узлов. В соответствии с этим для добавления узла и печати 
дерева здесь наиболее естественно применить рекурсивные функции.
</p>
<p>
Вернемся к описанию узла, которое удобно представить в виде структуры с 
четырьмя компонентами:
</p>
<pre>
struct tnode {           /* узел дерева */
    char *word;          /* указатель на текст */
    int count;           /* число вхождений */ 
    struct tnode *left;  /* левый сын */
    struct tnode *right; /* правый сын */
};
</pre>
<p>
Приведенное рекурсивное определение узла может показаться рискованным, но оно 
правильное. Структура не может включать саму себя, но ведь
</p>
<pre>
struct tnode *left;
</pre>
<p>
объявляет <i>left</i> как указатель на <i>tnode</i>, а не сам <i>tnode</i>.
</p>
<p>
Иногда возникает потребность во взаимоссылающихся структурах: двух 
структурах, ссылающихся друг на друга. Прием, позволяющий справиться с этой 
задачей, демонстрируется следующим фрагментом:
</p>
<pre>
struct t {
    ...
    struct s *p; /* р указывает на s */
};
struct s {
    ...
    struct t *q; /* q указывает на t */
}
</pre>
<p>
Вся программа удивительно мала - правда, она использует вспомогательные 
программы вроде <i>getword</i>, уже написанные нами. Главная программа читает слова 
с помощью <i>getword</i> и вставляет их в дерево посредством <i>addtree</i>.
</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#include &lt;string.h&gt;

#define MAXWORD 100

struct tnode *addtree(struct tnode *, char *);
void treeprint(struct tnode *);
int getword(char *, int);

/* подсчет частоты встречаемости слов */
main()
{
    struct tnode *root;
    char word[MAXWORD];

    root = NULL;
    while (getword (word, MAXWORD) != EOF)
        if (isalpha(word[0]))
            root = addtree(root, word);
    treeprint(root);
    return 0;
}
</pre>
<p>
Функция <i>addtree</i> рекурсивна. Первое слово функция <i>main</i> помещает на верхний 
уровень дерева (корень дерева). Каждое вновь поступившее слово сравнивается 
со словом узла и "погружается" или в левое, или в правое поддерево с помощью 
рекурсивного обращения к <i>addtree</i>. Через некоторое время это слово обязательно 
либо совпадет с каким-нибудь из имеющихся в дереве слов (в этом случае к 
счетчику будет добавлена 1), либо программа встретит пустую позицию, что 
послужит сигналом для создания нового узла и добавления его к дереву. 
Создание нового узла сопровождается тем, что <i>addtree</i> возвращает на него 
указатель, который вставляется в узел родителя.
</p>
<pre>
struct tnode *talloc(void);
char *strdup(char *);

/* addtree: добавляет узел со словом w в р или ниже него */
struct tnode *addtree(struct tnode *p, char *w)
{
    int cond;

    if (р == NULL) {  /* слово встречается впервые */
        p = talloc(); /* создается новый узел */
        p->word = strdup(w);
        p->count = 1;
        p->left = p->right = NULL;
    } else if ((cond = strcmp(w, p->word)) == 0) 
        p->count++;           /* это слово уже встречалось */
    else if (cond < 0)        /* меньше корня левого поддерева */
        p->left = addtree(p->left, w);
    else                      /* больше корня правого поддерева */
        p->right = addtree(p->right, w);
    return p;
}
</pre>
<p>
Память для нового узла запрашивается с помощью программы <i>talloc</i>, которая 
возвращает указатель на свободное пространство, достаточное для хранения 
одного узла дерева, а копирование нового слова в отдельное место памяти 
осуществляется с помощью <i>strdup</i>. (Мы рассмотрим эти программы чуть позже.) В 
тот (и только в тот) момент, когда к дереву подвешивается новый узел, 
происходит инициализация счетчика и обнуление указателей на сыновей. Мы 
опустили (что неразумно) контроль ошибок, который должен выполняться при 
получении значений от <i>strdup</i> и <i>talloc</i>.
</p>
<p>
Функция <i>treeprint</i> печатает дерево в лексикографическом порядке: для каждого 
узла она печатает его левое поддерево (все слова, которые меньше слова 
данного узла), затем само слово и, наконец, правое поддерево (слова, которые 
больше слова данного узла).
</p>
<pre>
/* treeprint: упорядоченная печать дерева р */
void treeprint(struct tnode *p)
{
    if (p != NULL) {
        treeprint (p->left);
        printf("%4d %s\n", p->count, p->word);
        treeprint(p->right);
    }
}
</pre>
<p>
Если вы не уверены, что досконально разобрались в том, как работает рекурсия, 
"проиграйте" действия <i>treeprint</i> на дереве, приведенном выше. Практическое 
замечание: если дерево "несбалансировано" (что бывает, когда слова поступают 
не в случайном порядке), то время работы программы может сильно возрасти. 
Худший вариант, когда слова уже упорядочены; в этом случае затраты на 
вычисления будут такими же, как при линейном поиске. Существуют обобщения 
бинарного дерева, которые не страдают этим недостатком, но здесь мы их не 
описываем.
</p>
<p>
Прежде чем завершить обсуждение этого примера, сделаем краткое отступление от 
темы и поговорим о механизме запроса памяти. Очевидно, хотелось бы иметь 
всего лишь одну функцию, выделяющую память, даже если эта память 
предназначается для разного рода объектов. Но если одна и та же функция 
обеспечивает память, скажем) и для указателей на <i>char</i>, и для указателей на 
<i>struct tnode</i>, то возникают два вопроса. Первый: как справиться с требованием 
большинства машин, в которых объекты определенного типа должны быть выровнены 
(например, <i>int</i> часто должны размещаться, начиная с четных адресов)? И второе: 
как объявить функцию-распределитель памяти, которая вынуждена в качестве 
результата возвращать указатели разных типов?
</p>
<p>
Вообще говоря, требования, касающиеся выравнивания, можно легко выполнить за 
счет некоторого перерасхода памяти. Однако для этого возвращаемый указатель 
должен быть таким, чтобы удовлетворялись любые ограничения, связанные с 
выравниванием. Функция <i>alloc</i>, описанная в <a href="ch5kr.html">главе 5</a>, не гарантирует нам любое 
конкретное выравнивание, поэтому мы будем пользоваться стандартной 
библиотечной функцией <b>malloc</b>, которая это делает. В <a href="ch8kr.html">главе 8</a> мы покажем один 
из способов ее реализации.
</p>
<p>
Вопрос об объявлении типа таких функций, как <b>malloc</b>, является камнем 
преткновения в любом языке с жесткой проверкой типов. В Си вопрос решается 
естественным образом: <b>malloc</b> объявляется как функция, которая возвращает 
указатель на <b>void</b>. Полученный указатель затем явно приводится к желаемому 
типу (Замечание о приведении типа величины, возвращаемой функцией <i>malloc</i>, 
нужно переписать. Пример коpректен и работает, но совет является спорным в 
контексте стандартов ANSI/ISO 1988-1989 г. На самом деле это не обязательно 
(при условии что приведение <i>void*</i> к <i>ALMOSTANYTYPE*</i> выполняется автоматически) 
и возможно даже опасно, если <i>malloc</i> или ее заместитель не может быть объявлен 
как функция, возвращающая <i>void*</i>. Явное приведение типа может скрыть случайную 
ошибку. В другие времена (до появления стандарта ANSI) приведение считалось 
обязательным, что также справедливо и для C++. — Примеч. авт.). Описания 
<i>malloc</i> и связанных с ней функций находятся в стандартном заголовочном файле 
<b>&lt;stdlib.h&gt;</b>. Таким образом, функцию <i>talloc</i> можно записать так:
</p>
<pre>
#include &lt;stdlib.h&gt;

/* talloc: создает tnode */
struct tnode *talloc(void)
{
    return (struct tnode *) malloc(sizeof(struct tnode));
}
</pre>
<p>
Функция <i>strdup</i> просто копирует строку, указанную в аргументе, в место, 
полученное с помощью <i>malloc</i>: </p>

<pre>
char *strdup(char *s) /* делает дубликат s */
{
    char *p;

    p = (char *) malloc(strlen(s)+1); /* +1 для '\0' */
    if (p != NULL)
        strcpy(p, s);
    return p;
}
</pre>
<p>
Функция <i>malloc</i> возвращает NULL, если свободного пространства нет; <i>strdup</i> 
возвращает это же значение, оставляя заботу о выходе из ошибочной ситуации 
вызывающей программе.
</p>
<p>
Память, полученную с помощью <i>malloc</i>, можно освободить для повторного 
использования, обратившись к функции <i>free</i> (см. <a href="ch7kr.html">главы 7</a> и <a href="ch8kr.html">8</a>).
</p>
<p>
<b>Упражнение 6.2</b>. Напишите программу, которая читает текст Си-программы и 
печатает в алфавитном порядке все группы имен переменных, в которых совпадают 
первые 6 символов, но последующие в чем-то различаются. Не обрабатывайте 
внутренности закавыченных строк и комментариев. Число 6 сделайте параметром, 
задаваемым в командной строке.
</p>
<p>
<b>Упражнение 6.3</b>. Напишите программу печати таблицы "перекрестных ссылок", 
которая будет печатать все слова документа и указывать для каждого из них 
номера строк, где оно встретилось. Программа должна игнорировать "шумовые" 
слова, такие как "и", "или" и пр.
</p>
<p>
<b>Упражнение 6.4</b>. Напишите программу, которая печатает весь набор различных 
слов, образующих входной поток, в порядке возрастания частоты их 
встречаемости. Перед каждым словом должно быть указано число вхождений.
</p>
<hr>

<a name="p66"></a>
<h3><a href="#cnt">6.6 Просмотр таблиц</a></h3>


<p>В этом параграфе, чтобы проиллюстрировать новые аспекты применения 
структур, мы напишем ядро пакета программ, осуществляющих вставку элементов в 
таблицы и их поиск внутри таблиц. Этот пакет - типичный набор программ, с 
помощью которых работают с таблицами имен в любом макропроцессоре или 
компиляторе. Рассмотрим, например, инструкцию <b>#define</b>. Когда встречается 
строка вида
</p>

<pre>
#define IN 1
</pre>
<p>
имя IN и замещающий его текст 1 должны запоминаться в таблице. Если затем имя 
IN встретится в инструкции, например в
</p>
<pre>
state = IN;
</pre>
<p>
это должно быть заменено на 1.
</p>
<p>
Существуют две программы, манипулирующие с именами и замещающими их текстами. 
Это <i>install(s,t)</i>, которая записывает имя <i>s</i> и замещающий его текст <i>t</i> в 
таблицу, где <i>s</i> и <i>t</i> - строки, и <i>lookup(s)</i>, осуществляющая поиск <i>s</i> в таблице и 
возвращающая указатель на место, где имя <i>s</i> было найдено, или NULL, если <i>s</i> в 
таблице не оказалось.
</p>
<p>
Алгоритм основан на <i>хэш-поиске</i>: поступающее имя свертывается в 
неотрицательное число (хэш-код), которое затем используется в качестве 
индекса в массиве указателей. Каждый элемент этого массива является 
указателем на начало связанного списка блоков, описывающих имена с данным 
хэш-кодом. Если элемент массива равен NULL, это значит, что имен с 
соответствующим хэш-кодом нет.
</p>
<img src="./krfigs/fig6_4.jpg"></img>

<p>
Блок в списке - это структура, содержащая указатели на имя, на замещающий 
текст и на следующий блок в списке; значение NULL в указателе на следующий 
блок означает конец списка.
</p>
<pre>
struct nlist {          /* элемент таблицы */
    struct nlist *next; /* указатель на следующий элемент */
     char *name;        /* определенное имя */
     char *defn;        /* замещающий текст */
};
</pre>
<p>
А вот как записывается определение массива указателей:
</p>
<pre>
#define HASHSIZE 101
static struct nlist *hashtab[HASHSIZE]; /* таблица указателей */
</pre>
<p>
Функция хэширования, используемая в <i>lookup</i> и <i>install</i>, суммирует коды символов 
в строке и в качестве результата выдаст остаток от деления полученной суммы 
на размер массива указателей. Это не самая лучшая функция хэширования, но 
достаточно лаконичная и эффективная.
</p>
<pre>
/* hash: получает хэш-код для строки s */
unsigned hash(char *s)
{
    unsigned hashval;

    for (hashval = 0; *s != '\0'; s++)
        hashval = *s + 31 * hashval;
    return hashval % HASHSIZE;
}
</pre>
<p>
Беззнаковая арифметика гарантирует, что хэш-код будет неотрицательным.
</p>
<p>
Хэширование порождает стартовый индекс для массива <i>hashtab</i>; если 
соответствующая строка в таблице есть, она может быть обнаружена только в 
списке блоков, на начало которого указывает элемент массива <i>hashtab</i> с этим 
индексом. Поиск осуществляется с помощью <i>lookup</i>. Если <i>lookup</i> находит элемент 
с заданной строкой, то возвращает указатель на нее, если не находит, то 
возвращает NULL.
</p>
<pre>
/* lookup: ищет s */
struct nlist *lookup(char *s)
{
    struct nlist *np;

    for (np = hashtab[hash(s)]; np != NULL; np = np->next)
        if (strcmp(s, np->name) == 0)
            return np; /* нашли */
    return NULL; /* не нашли */
}
</pre>
<p>
В <i>for</i>-цикле функции <i>lookup</i> для просмотра списка используется стандартная 
конструкция
</p>
<pre>
for (ptr = head; ptr != NULL; ptr = ptr->next)
    ...
</pre>
<p>
Функция <i>install</i> обращается к <i>lookup</i>, чтобы определить, имеется ли уже 
вставляемое имя. Если это так, то старое определение будет заменено новым. В 
противном случае будет образован новый элемент. Если запрос памяти для нового 
элемента не может быть удовлетворен, функция <i>install</i> выдает NULL.
</p>

<pre>
struct nlist *lookup(char *);
char *strdup(char *);

/* install: заносит имя и текст (name, defn) в таблицу */
struct nlist *install(char *name, char *defn)
{
    struct nlist *np;
    unsigned hashval;

    if ((np = lookup(name)) == NULL) { /* не найден */
        np = (struct nlist *) malloc(sizeof(*np));
        if (np == NULL || (np->name = strdup(name)) == NULL)
            return NULL;
        hashval = hash(name);
        np->next = hashtab[hashval];
        hashtab[hashval] = np;
    } else /* уже имеется */
        free((void *) np->defn); /* освобождаем прежний defn */
    if ((np->defn = strdup(defn)) == NULL)
        return NULL;
    return np;
}
</pre>
<p>
<b>Упражнение 6.5</b>. Напишите функцию <i>undef</i>, удаляющую имя и определение из 
таблицы, организация которой поддерживается функциями <i>lookup</i> и <i>install</i>.
</p>
<p>
<b>Упражнение 6.6</b>. Реализуйте простую версию <i>#define</i>-npoцeccopa (без 
аргументов), которая использовала бы программы этого параграфа и годилась бы 
для Си-программ. Вам могут помочь программы <i>getch</i> и <i>ungetch</i>.
</p>
<hr>

<a name="p67"></a>
<h3><a href="#cnt">6.7 Средство <b>typedef</b></a></h3>

<p>
Язык Си предоставляет средство, называемое <b>typedef</b>, которое позволяет давать 
типам данных новые имена. Например, объявление
</p>
<pre>
typedef int Length;
</pre>
<p>
делает имя <i>Length</i> синонимом <i>int</i>. С этого момента тип <i>Length</i> можно применять в 
объявлениях, в операторе приведения и т. д. точно так же, как тип <i>int</i>:
</p>
<pre>
Length len, maxlen;
Length *lengths[];
</pre>
<p>
Аналогично объявление
</p>
<pre>
typedef char *String;
</pre>
<p>
делает <i>String</i> синонимом <i>char *</i>, т. e. указателем на <i>char</i>, и правомерным 
будет, например, следующее его использование:
</p>
<pre>
String р, lineptr[MAXLINES], alloc(int);
int strcmp(String, String);
p = (String) malloc(100);
</pre>
<p>
Заметим, что объявляемый в <b>typedef</b> тип стоит на месте имени переменной в 
обычном объявлении, а не сразу за словом <b>typedef</b>. С точки зрения синтаксиса 
слово <i>typedef</i> напоминает класс памяти - <i>extern</i>, <i>static</i> и т. д. Имена типов 
записаны с заглавных букв для того, чтобы они выделялись.
</p>
<p>
Для демонстрации более сложных примеров применения <i>typedef</i> воспользуемся этим 
средством при задании узлов деревьев, с которыми мы уже встречались в данной 
главе.
</p>
<pre>
typedef struct tnode *Treeptr;

typedef struct tnode { /* узел дерева: */
    char *word;        /* указатель на текст */ 
    int count;         /* число вхождений */ 
    Treeptr left;      /* левый сын */ 
    Treeptr right;     /* правый сын */
} Treenode;
</pre>
<p>
В результате создаются два новых названия типов: <i>Treenode</i> (структура) и 
<i>Treeptr</i> (указатель на структуру). Теперь программу <i>talloc</i> можно записать в 
следующем виде:
</p>
<pre>
Treeptr talloc(void)
{
    return (Treeptr) malloc(sizeof(Treenode));
}
</pre>
<p>
Следует подчеркнуть, что объявление <i>typedef</i> не создает объявления нового 
типа, оно лишь сообщает новое имя уже существующему типу. Никакого нового 
смысла эти новые имена не несут, они объявляют переменные в точности с теми 
же свойствами, как если бы те были объявлены напрямую без переименования 
типа. Фактически <i>typedef</i> аналогичен <i>#define</i> с тем лишь отличием, что при 
интерпретации компилятором он может справиться с такой текстовой 
подстановкой, которая не может быть обработана препроцессором. Например
</p>
<pre>
typedef int (*PFI)(char *, char *);
</pre>
<p>
создает тип <i>PFI</i> - "указатель на функцию (двух аргументов типа <i>char *</i>), 
возвращающую <i>int</i>", который, например, в программе сортировки, описанной в 
<a href="ch5kr.html">главе 5</a>, можно использовать в таком контексте:
</p>
<pre>
PFI strcmp, numcmp;
</pre>
<p>
Помимо просто эстетических соображений, для применения <i>typedef</i> существуют две 
важные причины. Первая - параметризация программы, связанная с проблемой 
переносимости. Если с помощью <i>typedef</i> объявить типы данных, которые, 
возможно, являются машинно-зависимыми, то при переносе программы на другую 
машину потребуется внести изменения только в определения <i>typedef</i>. Одна из 
распространенных ситуаций - использование <i>typedef</i>-имен для варьирования целыми 
величинами. Для каждой конкретной машины это предполагает соответствующие 
установки <i>short</i>, <i>int</i> или <i>long</i>, которые делаются аналогично установкам 
стандартных типов, например <i>size_t</i> и <i>ptrdiff_t</i>.
</p>
<p>
Вторая причина, побуждающая к применению <i>typedef</i>,- желание сделать более 
ясным текст программы. Тип, названный <i>Тreeptr</i> (от английских слов tree - 
дерево и pointer - указатель), более понятен, чем тот же тип, записанный как 
указатель на некоторую сложную структуру.
</p>
<hr>

<a name="p68"></a>
<h3><a href="#cnt">6.8 Объединения</a></h3>

<p>
<i>Объединение</i> - это переменная, которая может содержать (в разные моменты 
времени) объекты различных типов и размеров. Все требования относительно 
размеров и выравнивания выполняет компилятор. Объединения позволяют хранить 
разнородные данные в одной и той же области памяти без включения в программу 
машинно-зависимой информации. Эти средства аналогичны вариантным записям в 
Паскале.
</p>
<p>
Примером использования объединений мог бы послужить сам компилятор, 
заведующий таблицей символов, если предположить, что константа может иметь 
тип <i>int</i>, <i>float</i> или являться указателем на символ и иметь тип <i>char *</i>. Значение 
каждой конкретной константы должно храниться в переменной соответствующего 
этой константе типа. Работать с таблицей символов всегда удобнее, если 
значения занимают одинаковую по объёму память и запоминаются в одном и том же 
месте независимо от своего типа. Цель введения в программу объединения - 
иметь переменную, которая бы на законных основаниях хранила в себе значения 
нескольких типов. Синтаксис объединений аналогичен синтаксису структур. 
Приведем пример объединения.
</p>
<pre>
union u_tag {
    int ival;
    float fval;
    char *sval;
} u;
</pre>
<p>
Переменная <i>u</i> будет достаточно большой, чтобы в ней поместилась любая 
переменная из указанных трех типов: точный ее размер зависит от реализации. 
Значение одного из этих трех типов может быть присвоено переменной <i>u</i> и далее 
использовано в выражениях, если это правомерно, т. е. если тип взятого ею 
значения совпадает с типом последнего присвоенного ей значения. Выполнение 
этого требования в каждый текущий момент - целиком на совести программиста. В 
том случае, если нечто запомнено как значение одного типа, а извлекается как 
значение другого типа, результат зависит от реализации. Синтаксис доступа к 
элементам объединения следующий:
</p>
<pre>
<i>имя-объединения</i>.<i>элемент</i> 
</pre>
<p>
или
</p>
<pre>
<i>указатель-на-объединение</i>-><i>элемент</i>
</pre>
<p>
т. е. в точности такой, как в структурах. Если для хранения типа текущего 
значения <i>u</i> использовать, скажем, переменную <i>utype</i>, то можно написать такой 
фрагмент программы:
</p>
<pre>
if (utype == INT)
    printf("%d\n", u.ival);
else if (utype === FLOAT)
    printf("%f\n", u.fval);
else if (utype == STRING)
    printf("%s\n", u.sval);
else
    printf ("неверный тип %d в utype\n", utype);
</pre>
<p>
Объединения могут входить в структуры и массивы, и наоборот. Запись доступа к 
элементу объединения, находящегося в структуре (как и структуры, находящейся 
в объединении), такая же, как и для вложенных структур. Например, в массиве 
структур
</p>
<pre>
struct {
    char *name;
    int flags;
    int utype;
    union {
        int ival;
        float fval;
        char *sval;
    } u;
} symtab[NSYM];
</pre>
<p>
к <i>ival</i> обращаются следующим образом:
</p>
<pre>
symtab[i].u.ival
</pre>
<p>
а к первому символу строки <i>sval</i> можно обратиться любым из следующих двух 
способов:
</p>
<pre>
*symtab[i].u.sval
symtab[i].u.sval[0]
</pre>
<p>
Фактически объединение - это структура, все элементы которой имеют нулевое 
смещение относительно ее базового адреса и размер которой позволяет 
поместиться в ней самому большому ее элементу, а выравнивание этой структуры 
удовлетворяет всем типам объединения. Операции, применимые к структурам, 
годятся и для объединений, т. е. законны присваивание объединения и 
копирование его как единого целого, взятие адреса от объединения и доступ к 
отдельным его элементам.
</p>
<p>
Инициализировать объединение можно только значением, имеющим тип его первого 
элемента; таким образом, упомянутую выше переменную <i>u</i> можно инициализировать 
лишь значением типа <i>int</i>.
</p>
<p>
В <a href="ch8kr.html">главе 8</a> (на примере программы, заведующей выделением памяти) мы покажем, 
как, применяя объединение, можно добиться, чтобы расположение переменной было 
выровнено по соответствующей границе в памяти.
</p>
<hr>

<a name="p69"></a>
<h3><a href="#cnt">6.9 Битовые поля</a></h3>
<p>
При дефиците памяти может возникнуть необходимость запаковать несколько 
объектов в одно слово машины. Одна из обычных ситуаций, встречающаяся в 
задачах обработки таблиц символов для компиляторов, - это объединение групп 
однобитовых флажков. Форматы некоторых данных могут от нас вообще не зависеть 
и диктоваться, например, интерфейсами с аппаратурой внешних устройств: здесь 
также возникает потребность адресоваться к частям слова.
</p>
<p>
Вообразим себе фрагмент компилятора, который заведует таблицей символов. 
Каждый идентификатор программы имеет некоторую связанную с ним информацию: 
например, представляет ли он собой ключевое слово и, если это переменная, к 
какому классу принадлежит: внешняя и/или статическая и т. д. Самый компактный 
способ кодирования такой информации - расположить однобитовые флажки в одном 
слове типа <i>char</i> или <i>int</i>.
</p>
<p>
Один из распространенных приемов работы с битами основан на определении 
набора "масок", соответствующих позициям этих битов, как, например, в
</p>
<pre>
#define KEYWORD 01     /* ключевое слово */
#define EXTERNAL 02    /* внешний */
#define STATIC 04      /* статический */
</pre>
<p>
или в 
</p>
<pre>
enum { KEYWORD = 01, EXTERNAL = 02, STATIC = 04 };
</pre>
<p>
Числа должны быть степенями двойки. Тогда доступ к битам становится делом 
"побитовых операций", описанных в <a href="ch2kr.html">главе 2</a> (сдвиг, маскирование, взятие 
дополнения). Некоторые виды записи выражений встречаются довольно часто. Так,
</p>
<pre>
flags |= EXTERNAL | STATIC;
</pre>
<p>
устанавливает 1 в соответствующих битах переменной <i>flags</i>,
</p>
<pre>
flags &= ~(EXTERNAL | STATIC);
</pre>
<p>
обнуляет их, a
</p>
<pre>
if ((flags & (EXTERNAL | STATIC)) == 0) ...
</pre>
<p>
оценивает условие как истинное, если оба бита нулевые.
</p>
<p>
Хотя научиться писать такого рода выражения не составляет труда, вместо 
побитовых логических операций можно пользоваться предоставляемым Си другим 
способом прямого определения и доступа к полям внутри слова. Битовое поле 
(или для краткости просто поле) - это некоторое множество битов, лежащих 
рядом внутри одной, зависящей от реализации единицы памяти, которую мы будем 
называть "словом". Синтаксис определения полей и доступа к ним базируется на 
синтаксисе структур. Например, строки <i>#define</i>, фигурировавшие выше при 
задании таблицы символов, можно заменить на определение трех полей:
</p>
<pre>
struct {
    unsigned int is_keyword : 1;
    unsigned int is_extern  : 1;
    unsigned int is_static  : 1;
} flags;
</pre>
<p>
Эта запись определяет переменную <i>flags</i>, которая содержит три однобитовых 
поля. Число, следующее за двоеточием, задает ширину поля. Поля объявлены как 
<i>unsigned int</i>, чтобы они воспринимались как беззнаковые величины.
</p>
<p>
На отдельные поля ссылаются так же, как и на элементы обычных структур: 
<i>flags.is_keyword</i>, <i>flags.is_extern</i> и т.д. Поля "ведут себя" как малые целые и 
могут участвовать в арифметических выражениях точно так же, как и другие 
целые. Таким образом, предыдущие примеры можно написать более естественно:
</p>
<pre>
flags.is_extern = flags.is_static = 1;
</pre>
<p>
устанавливает 1 в соответствующие биты;
</p>
<pre>
flags.is_extern = flags.is_static = 0;
</pre>
<p>
их обнуляет, а
</p>
<pre>
if (flags.is_extern == 0 && flags.is_ststic == 0)
    ...
</pre>
<p>
проверяет их.
</p>
<p>
Почти все технические детали, касающиеся полей, в частности, возможность поля 
перейти границу слова, зависят от реализации. Поля могут не иметь имени; с 
помощью безымянного поля (задаваемого только двоеточием и шириной) 
организуется пропуск нужного количества разрядов. Особая ширина, равная нулю, 
используется, когда требуется выйти на границу следующего слова.
</p>
<p>
На одних машинах поля размещаются слева направо, на других - справа налево. 
Это значит, что при всей полезности работы с ними, если формат данных, с 
которыми мы имеем дело, дан нам свыше, то необходимо самым тщательным образом 
исследовать порядок расположения полей; программы, зависящие от такого рода 
вещей, не переносимы. Поля можно определять только с типом <i>int</i>, а для того 
чтобы обеспечить переносимость, надо явно указывать <i>signed</i> или <i>unsigned</i>. Они 
не могут быть массивами и не имеют адресов, и, следовательно, оператор <b>&</b> к 
ним не применим.
</p>
</body>
</html>
