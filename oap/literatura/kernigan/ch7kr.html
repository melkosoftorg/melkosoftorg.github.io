<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>Глава 7. Ввод и вывод</title>
</head>
<body bgcolor=#d3d3d3>
<font face=Arial>
<hr>
<a name="cnt"></a><p><a href="index.html#content">Содержание</a></p>
<h2>Глава 7. Ввод и вывод</h2>
<hr>
<a href="#p71">7.1 Стандартный ввод-вывод</a><br>
<a href="#p72">7.2 Форматный вывод (<b>printf</b>)</a><br>
<a href="#p73">7.3 Списки аргументов переменной длины</a><br>
<a href="#p74">7.4 Форматный ввод (<b>scanf</b>)</a><br>
<a href="#p75">7.5 Доступ к файлам</a><br>
<a href="#p76">7.6 Управление ошибками (<b>stderr</b> и <b>exit</b>)</a><br>
<a href="#p77">7.7 Ввод-вывод строк</a><br>
<a href="#p78">7.8 Другие библиотечные функции</a><br>
<a href="#p781">7.8.1 Операции со строками</a><br>
<a href="#p782">7.8.2 Анализ класса символов и преобразование символов</a><br>
<a href="#p783">7.8.3 Функция <b>ungetc</b></a><br>
<a href="#p784">7.8.4 Исполнение команд операционной системы</a><br>
<a href="#p785">7.8.5 Управление памятью</a><br>
<a href="#p786">7.8.6 Математические функции</a><br>
<a href="#p787">7.8.7 Генератор случайных чисел</a><br>
<hr>

<p>
Возможности для ввода и вывода не являются частью самого языка Си, поэтому мы 
подробно и не рассматривали их до сих пор. Между тем реальные программы 
взаимодействуют со своим окружением гораздо более сложным способом, чем те, 
которые были затронуты ранее. В этой главе мы опишем стандартную библиотеку, 
содержащую набор функций, обеспечивающих ввод-вывод, работу со строками, 
управление памятью, стандартные математические функции и разного рода 
сервисные Си-программы. Но особое внимание уделим вводу-выводу.
</p>
<p>
Библиотечные функции ввода-вывода точно определяются стандартом ANSI, так что 
они совместимы на любых системах, где поддерживается Си. Программы, которые в 
своем взаимодействии с системным окружением не выходят за рамки возможностей 
стандартной библиотеки, можно без изменений переносить с одной машины на 
другую.
</p>
<p>
Свойства библиотечных функций специфицированы в более чем дюжине заголовочных 
файлов; вам уже встречались некоторые из них, в том числе <b>&lt;stdio.h&gt;</b>, 
<b>&lt;string.h&gt;</b> и <b>&lt;ctype.h&gt;</b>. Мы не рассматриваем здесь всю библиотеку, 
так как нас больше интересует написание Си-программ, чем использование 
библиотечных функций. Стандартная библиотека подробно описана в <a href="b.html">приложении B</a>.
</p>

<hr>
<a name="p71"></a>
<h3><a href="#cnt">7.1 Стандартный ввод-вывод</a></h3>
<p>
Как уже говорилось в <a href="ch1kr.html">главе 1</a>, библиотечные функции реализуют простую модель 
текстового ввода-вывода. Текстовый поток состоит из последовательности строк; 
каждая строка заканчивается символом новой строки. Если система в чем-то не 
следует принятой модели, библиотека сделает так, чтобы казалось, что эта 
модель удовлетворяется полностью. Например, пара символов - <i>возврат-каретки</i> и 
<i>перевод-строки</i> - при вводе могла бы быть преобразована в один символ новой 
строки, а при выводе выполнялось бы обратное преобразование.
</p>
<p>
Простейший механизм ввода - это чтение одного символа из <i>стандартного ввода</i> 
(обычно с клавиатуры) функцией <i>getchar</i>:
</p>
<pre>
int getchar(void)
</pre>

<p>
В качестве результата каждого своего вызова функция <i>getchar</i> возвращает 
следующий символ ввода или, если обнаружен конец файла, <b>EOF</b>. Именованная 
константа EOF (аббревиатура от <i>end of file</i> - конец файла) определена в 
<b>&lt;stdio.h&gt;</b>. Обычно значение <b>EOF</b> равно -1, но, чтобы не зависеть от конкретного 
значения этой константы, обращаться к ней следует по имени (EOF).
</p>

<p>
Во многих системах клавиатуру можно заменить файлом, перенаправив ввод с 
помощью значка <b>&lt;</b>. Так, если программа <i>prog</i> использует <i>getchar</i>, то командная 
строка</p>
<pre>
prog &lt; infile
</pre>

<p>
предпишет программе <i>prog</i> читать символы из <i>infile</i>, а не с клавиатуры. 
Переключение ввода делается так, что сама программа <i>prog</i> не замечает подмены; 
в частности строка <i>"&lt; infile"</i> не будет включена в аргументы командной строки 
<i>argv</i>. Переключение ввода будет также незаметным, если ввод исходит от другой 
программы и передается конвейерным образом. В некоторых системах командная 
строка</p>
<pre>
otherprog | prog
</pre>
<p>
приведет к тому, что запустится две программы, <i>otherprog</i> и <i>prog</i>, и 
стандартный выход <i>otherprog</i> поступит на стандартный вход <i>prog</i>. Функция</p>
<pre>
int putchar(int)
</pre>
<p>
используется для вывода: <i>putchar(c)</i> отправляет символ <i>c</i> в <i>стандартный вывод</i>, 
под которым по умолчанию подразумевается экран. Функция <i>putchar</i> в качестве 
результата возвращает посланный символ или, в случае ошибки, <i>EOF</i>. То же и в 
отношении вывода: с помощью записи вида <i>&gt; имя-файла</i> вывод можно перенаправить 
в файл. Например, если <i>prog</i> использует для вывода функцию <i>putchar</i>, то</p>
<pre>
prog &gt; outfile
</pre>
<p>
будет направлять стандартный вывод не на экран, а в <i>outfile</i>. А командная 
строка</p>
<pre>
prog | anotherprog
</pre>

<p>
соединит стандартный вывод программы <i>prog</i> со стандартным вводом программы 
<i>anotherprog</i>.
</p>

<p>
Вывод, осуществляемый функцией <i>printf</i>, также отправляется в стандартный 
выходной поток. Вызовы <i>putchar</i> и <i>printf</i> могут как угодно чередоваться, при 
этом вывод будет формироваться в той последовательности, в которой 
происходили вызовы этих функций.
</p>

<p>
Любой исходный Си-файл, использующий хотя бы одну функцию библиотеки 
ввода-вывода, должен содержать в себе строку
</p>

<pre>
#include &lt;stdio.h&gt;
</pre>

<p>
причем она должна быть расположена до первого обращения к вводу-выводу. Если 
имя заголовочного файла заключено в угловые скобки &lt; и &gt;, это значит, что 
поиск заголовочного файла ведется в стандартном месте (например в системе 
UNIX это обычно директорий <i>/usr/include</i>).
</p>

<p>
Многие программы читают только из одного входного потока и пишут только в 
один выходной поток. Для организации ввода-вывода таким программам вполне 
хватит функций <i>getchar</i>, <i>putchar</i> и <i>printf</i>, а для начального обучения уж точно 
достаточно ознакомления с этими функциями. В частности, перечисленных функций 
достаточно, когда требуется вывод одной программы соединить с вводом 
следующей. В качестве примера рассмотрим программу <i>lower</i>, переводящую свой 
ввод на нижний регистр:
</p>
<pre>
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

main() /* lower: переводит ввод на нижний регистр */
{
    int с;
    while ((с = getchar()) != EOF)
        putchar(tolower(c));
    return 0;
}
</pre>
<p>
Функция <i>tolower</i> определена в <b>&lt;ctype.h&gt;</b>. Она переводит буквы верхнего регистра 
в буквы нижнего регистра, а остальные символы возвращает без изменений. Как 
мы уже упоминали, "функции" вроде <i>getchar</i> и <i>putchar</i> из библиотеки <b>&lt;stdio.h&gt;</b> и 
функция <i>tolower</i> из библиотеки <b>&lt;ctype.h&gt;</b> часто реализуются в виде макросов, 
чтобы исключить накладные расходы от вызова функции на каждый отдельный 
символ. В <a href="ch8kr.html#p85">параграфе 8.5</a> мы покажем, как это делается. Независимо от того, как 
на той или иной машине реализованы функции библиотеки <b>&lt;ctype.h&gt;</b>, использующие 
их программы могут ничего не знать о кодировке символов.
</p>

<p>
<b>Упражнение 7.1</b>. Напишите программу, осуществляющую перевод ввода с верхнего 
регистра на нижний или с нижнего на верхний в зависимости от имени, по 
которому она вызывается и текст которого находится в <i>arg[0]</i>.
</p>
<hr>

<a name="p72"></a>
<h3><a href="#cnt">7.2 Форматный вывод (<b>printf</b>)</a></h3>

<p>Функция <b>printf</b> переводит внутренние значения в текст. </p>
<pre>
int printf(char *format, arg<sub>1</sub>, arg<sub>2</sub>, ...)
</pre>
<p>
В предыдущих главах мы использовали <i>printf</i> неформально. Здесь мы покажем 
наиболее типичные случаи применения этой функции: полное ее описание дано в 
<a href="b.html">приложении B</a>.
</p>

<p>
Функция <i>printf</i> преобразует, форматирует и печатает свои аргументы в 
стандартном выводе под управлением формата. Возвращает она количество 
напечатанных символов.
</p>

<p>
Форматная строка содержит два вида объектов: обычные символы, которые 
напрямую копируются в выходной поток, и спецификации преобразования, каждая 
из которых вызывает преобразование и печать очередного аргумента <i>printf</i>. 
Любая спецификация преобразования начинается знаком <b>%</b> и заканчивается 
<i>символом-спецификатором</i>. Между <i>%</i> и символом-спецификатором могут быть 
расположены (в указанном ниже порядке) следующие элементы:
</p>

<dir>
<li> Знак минус, предписывающий выравнивать преобразованный аргумент по левому краю поля.
<li> Число, специфицирующее минимальную ширину поля. Преобразованный аргумент 
будет занимать поле по крайней мере указанной ширины. При необходимости 
лишние позиции слева (или справа при левостороннем расположении) будут 
заполнены пробелами.
<li> Точка, отделяющая ширину поля от величины, устанавливающей точность.
<li> Число (точность), специфицирующее максимальное количество печатаемых 
символов в строке, или количество цифр после десятичной точки - для чисел с 
плавающей запятой, или минимальное количество цифр - для целого.
<li> Буква <i>h</i>, если печатаемое целое должно рассматриваться как <i>short</i>, или <i>l</i> 
(латинская буква ell), если целое должно рассматриваться как <i>long</i>.
</dir>
<p>
Символы-спецификаторы перечислены в таблице 7.1. Если за <b>%</b> не помещен символ-
спецификатор, поведение функции <i>printf</i> будет не определено. Ширину и точность 
можно специфицировать с помощью <b>*</b>; значение ширины (или точности) в этом 
случае берется из следующего аргумента (который должен быть типа <i>int</i>). 
Например, чтобы напечатать не более <i>max</i> символов из строки <i>s</i>, годится 
следующая запись: </p>
<pre>
printf("%.*s", max, s);
</pre>
<p><a name="table71"></a><b>Таблица 7.1 Основные преобразования printf</b></p>

<table>
<tr>
    <th>Символ</th>
    <th>Тип аргумента; вид печати</th>
</tr>
    <td><b>d</b>, <b>i</b></td>
    <td><b>int</b>; десятичное целое</td>
<tr>
    <td><b>o</b></td>
    <td><b>unsigned int</b>; беззнаковое восьмеричное (<i>octal</i>) целое (без нуля слева)</td>
</tr>
<tr>
    <td><b>x</b>, <b>X</b></td>
    <td> <b>unsigned int</b>; беззнаковое шестнадцатеричное целое (без 0x или 0X 
         слева), для 10...15 используются abcdef или ABCDEF</td>
</tr>
<tr>
    <td><b>u</b></td>
    <td> <b>unsigned int</b>; беззнаковое десятичное целое</td>
</tr>
<tr>
    <td><b>c</b></td>
    <td><b>int</b>; одиночный символ</td>
</tr>
<tr>
    <td><b>s</b></td>
    <td><b>char *</b>; печатает символы, расположенные до знака \0, или в количестве, заданном точностью</td>
</tr>
<tr>
    <td><b>f</b></td>
    <td><b>double</b>; <b>[-]m.dddddd</b>, где количество цифр <b>d</b> задается точностью (по умолчанию равно <i>6</i>)</td>
</tr>
<tr>
    <td><b>e</b>, <b>E</b></td>
    <td><b>double</b>; <b>[-]m.dddddde±xx</b> или <b>[-]m.ddddddE±xx</b>, где количество цифр <b>d</b> 
         задается точностью (по умолчанию равно <i>6</i>)</td>
</tr>
<tr>
    <td><b>g</b>, <b>G</b></td>
    <td><b>double</b>; использует <b>%e</b> или <b>%E</b>, если порядок меньше, чем -4, или больше или равен точности; в противном случае использует <b>%f</b>. 
Завершающие нули и завершающая десятичная точка не печатаются</td>
</tr>
<tr>
    <td><b>p</b></td>
    <td><b>void *</b>; указатель (представление зависит от реализации)</td>
</tr>
<tr>
    <td><b>%</b></td>
    <td>Аргумент не преобразуется; печатается знак <b>%</b></td>
</tr>
</table>

<p>Большая часть форматных преобразований была продемонстрирована в 
предыдущих главах. Исключение составляет задание точности для строк. Далее 
приводится перечень спецификаций и показывается их влияние на печать строки 
"hello, world", состоящей из 12 символов. Поле специально обрамлено 
двоеточиями, чтобы была видна его протяженность.
</p>

<pre>
:%s:        :hello, world:
:%10s       :hello, world:
:%.10s:     :hello, wor:
:%-10s:     :hello, world:
:%.15s:     :hello, world:
:%-15s:     :hello, world     :
:%15.10s:   :       hello, wor:
:%-15.10s:  :hello, wor       :
</pre>
<p>
Предостережение: функция <i>printf</i> использует свой первый аргумент, чтобы 
определить, сколько еще ожидается аргументов и какого они будут типа. Вы не 
получите правильного результата, если аргументов будет не хватать или они 
будут принадлежать не тому типу. Вы должны также понимать разницу в следующих 
двух обращениях:
</p>

<pre>
printf(s); /* НЕВЕРНО, если в s есть % */ 
printf("%s", s); /* ВЕРНО всегда */
</pre>

<p>
Функция <b>sprintf</b> выполняет те же преобразования, что и <i>printf</i>, но вывод 
запоминает в строке
</p>

<pre>
int sprintf(char *string, char *format, arg<sub>1</sub>, arg<sub>2</sub>, ...)
</pre>

<p>
Эта функция форматирует <i>arg<sub>1</sub></i>, <i>arg<sub>2</sub></i> и т. д. в соответствии с информацией, 
заданной аргументом <i>format</i>, как мы описывали ранее, но результат помещает не 
в стандартный вывод, а в <i>string</i>. Заметим, что строка <i>string</i> должна быть 
достаточно большой, чтобы в ней поместился результат.
</p>

<p>
<b>Упражнение 7.2</b>. Напишите программу, которая будет печатать разумным способом 
любой ввод. Как минимум она должна уметь печатать неграфические символы в 
восьмеричном или шестнадцатеричном виде (в форме, принятой на вашей машине), 
обрывая длинные текстовые строки.
</p>
<hr>

<a name="p73"></a>
<h3><a href="#cnt">7.3 Списки аргументов переменной длины</a></h3>

<p>
Этот параграф содержит реализацию минимальной версии <i>printf</i>. Приводится она 
для того, чтобы показать, как надо писать функции со списками аргументов 
переменной длины, причем такие, которые были бы переносимы. Поскольку нас 
главным образом интересует обработка аргументов, функцию <i>minprintf</i> напишем 
таким образом, что она в основном будет работать с задающей формат строкой и 
аргументами; что же касается форматных преобразований, то они будут 
осуществляться с помощью стандартного <i>printf</i>.
</p>

<p>
Объявление стандартной функции <i>printf</i> выглядит так:
</p>

<pre>
int printf(char *fmt, ...)
</pre>

<p>
Многоточие в объявлении означает, что число и типы аргументов могут 
изменяться. Знак многоточие может стоять только в конце списка аргументов. 
Наша функция <i>minprintf</i> объявляется как
</p>

<pre>
void minprintf(char *fmt, ...)
</pre>

<p>
поскольку она не будет выдавать число символов, как это делает <i>printf</i>.
</p>

<p>
Вся сложность в том, каким образом <i>minprintf</i> будет продвигаться вдоль списка 
аргументов, - ведь у этого списка нет даже имени. Стандартный заголовочный 
файл <b>&lt;stdarg.h&gt;</b> содержит набор макроопределений, которые устанавливают, как 
шагать по списку аргументов. Наполнение этого заголовочного файла может 
изменяться от машины к машине, но представленный им интерфейс везде одинаков.
</p>

<p>
Тип <b>va_list</b> служит для описания переменной, которая будет по очереди 
указывать на каждый из аргументов; в <i>minprintf</i> эта переменная имеет имя <i>ap</i> 
(от "<i>argument pointer</i>" - указатель на аргумент). Макрос <b>va_start</b> 
инициализирует переменную <i>ap</i>) чтобы она указывала на первый безымянный 
аргумент. К <b>va_start</b> нужно обратиться до первого использования <i>ap</i>. Среди 
аргументов по крайней мере один должен быть именованным: от последнего 
именованного аргумента этот макрос "отталкивается" при начальной установке.
</p>

<p>
Макрос <b>va_arg</b> на каждом своем вызове выдает очередной аргумент, а <i>ap</i> 
передвигает на следующий: но имени типа он определяет тип возвращаемого 
значения и размер шага для выхода на следующий аргумент. Наконец, макрос 
<b>va_end</b> делает очистку всего, что необходимо. К <b>va_end</b> следует обратиться 
перед самым выходом из функции.
</p>

<p>
Перечисленные средства образуют основу нашей упрощенной версии <i>prinf</i>.
</p>
<pre>
#include &lt;stdarg.h&gt;

/* minprintf: минимальный printf с переменным числом аргументов */
void minprintf(char *fmt, ...)
{
    va_list ap;        /* указывает на очередной безымянный аргумент */ 
    char *p, *sval;
    int ival;
    double dval;

    va_start(ap, fmt); /* устанавливает ap на 1-й безымянный аргумент */ 
    for (p=fmt; *p; p++) {
        if (*p !='%') {
            putchar(*p);
            continue;
        }
        switch (*++p) {
        case 'd':
            ival = va_arg(ap, int);
            printf ("%d", ival);
            break;
        case 'f':
            dval = va_arg(ap, double);
            printf("%f", dval);
            break;
        case 's':
            for (sval = va_arg(ap, char *); *sval; sval++)
                putchar(*sval);
            break;
        default:
            putchar(*p);
            break;
        }
    }
    va_end(ap); /* очистка, когда все сделано */
}
</pre>
<p>
<b>Упражнение 7.3</b>. Дополните <i>minprintf</i> другими возможностями <i>printf</i>.
</p>
<hr>

<a name="p74"></a>
<h3><a href="#cnt">7.4 Форматный ввод (<b>scanf</b>)</a></h3>

<p>
Функция <b>scanf</b>, обеспечивающая ввод, является аналогом <i>printf</i>; она выполняет 
многие из упоминавшихся преобразований, но в противоположном направлении. Ее 
объявление имеет следующий вид: </p>
<pre>
int scanf(char *format, ...)
</pre>
<p>
Функция <i>scanf</i> читает символы из стандартного входного потока, интерпретирует 
их согласно спецификациям строки <i>format</i> и рассылает результаты в свои 
остальные аргументы. Аргумент <i>format</i> мы опишем позже; другие аргументы, 
каждый из которых должен быть указателем, определяют, где будут запоминаться 
должным образом преобразованные данные. Как и для <i>printf</i>, в этом параграфе 
дается сводка наиболее полезных, но отнюдь не всех возможностей данной 
функции.
</p>

<p>
Функция <i>scanf</i> прекращает работу, когда оказывается, что исчерпался формат или 
вводимая величина не соответствует управляющей спецификации. В качестве 
результата <i>scanf</i> возвращает количество успешно введенных элементов данных. По 
исчерпании файла она выдает <i>EOF</i>. Существенно то, что значение EOF не равно 
нулю, поскольку нуль <i>scanf</i> выдает, когда вводимый символ не соответствует 
первой спецификации форматной строки. Каждое очередное обращение к <i>scanf</i> 
продолжает ввод символа, следующего сразу за последним обработанным.
</p>
<p>
Существует также функция <i>sscanf</i>, которая читает из строки (а не из 
стандартного ввода). </p>
<pre>
int sscanf(char *string, char *format, arg<sub>1</sub>, arg<sub>2</sub>, ...)
</pre>
<p>
Функция <i>sscanf</i> просматривает строку <i>string</i> согласно формату <i>format</i> и 
рассылает полученные значения в <i>arg<sub>1</sub></i>, <i>arg<sub>2</sub></i> и т. д. Последние должны быть 
указателями.
</p>

<p>
Формат обычно содержит спецификации, которые используются для управления 
преобразованиями ввода. В него могут входить следующие элементы:
</p>

<dir>
<li>Пробелы или табуляции, которые игнорируются.
<li>Обычные символы (исключая %), которые, как ожидается, совпадут с очередными 
символами, отличными от символов-разделителей входного потока.
<li>Спецификации преобразования, каждая из которых начинается со знака <i>%</i> и 
завершается символом-спецификатором типа преобразования. В промежутке между 
этими двумя символами в любой спецификации могут располагаться, причем в том 
порядке, как они здесь указаны: знак <i>*</i> (признак подавления присваивания); 
число, определяющее ширину поля; буква <i>h</i>, <i>l</i> или <i>L</i>, указывающая на размер 
получаемого значения; и символ преобразования (<i>o</i>, <i>d</i>, <i>x</i>).
</dir>

<p>
Спецификация преобразования управляет преобразованием следующего вводимого 
поля. Обычно результат помещается в переменную, на которую указывает 
соответствующий аргумент. Однако если в спецификации преобразования 
присутствует <i>*</i>, то поле ввода пропускается и никакое присваивание не 
выполняется. Поле ввода определяется как строка без символов-разделителей; 
оно простирается до следующего символа-разделителя или же ограничено шириной 
поля, если она задана. Поскольку символ новой строки относится к символам-
разделителям, то <i>sscanf</i> при чтении будет переходить с одной строки на другую. 
(<b>Символами-разделителями являются символы пробела, табуляции, новой строки, 
возврата каретки, вертикальной табуляции и перевода страницы.</b>)
</p>

<p>
Символ-спецификатор указывает, каким образом следует интерпретировать 
очередное поле ввода. Соответствующий аргумент должен быть указателем, как 
того требует механизм передачи параметров по значению, принятый в Си. 
Символы-спецификаторы приведены в таблице 7.2.
</p>

<p>
Перед символами-спецификаторами <b>d</b>, <b>l</b>, <b>o</b>, <b>u</b> и <b>x</b> может стоять буква <b>h</b>, 
указывающая на то, что соответствующий аргумент должен иметь тип <i>short *</i> (а 
не <i>int *</i>),или <b>l</b> (латинская ell), указывающая на тип <i>long *</i>. Аналогично, перед 
символами-спецификаторами <b>e</b>, <b>f</b> и <b>g</b> может стоять буква <b>l</b>, указывающая, что тип 
аргумента - <i>double *</i> (а не <i>float *</i>).
</p>

<p><a name ="table72"></a><b>Таблица 7.2 Основные преобразования scanf</b></p>
<table>
<tr>
    <th>Символ</th>
    <th>Вводимые данные; тип аргумента</th>
</tr>
<tr>
    <td><b>d</b></td>
    <td>десятичное целое: <b>int *</b></td>
</tr>
<tr>
    <td><b>i</b></td>
    <td>целое: <b>int *</b>. Целое может быть восьмеричным (с 0 слева) или шестнадцатеричным (с 0x или 0X слева)</td>
</tr>
<tr>
    <td><b>o</b></td>
    <td>восьмеричное целое (с нулем слева или без него); <b>int *</b></td>
</tr>
<tr>
    <td><b>u</b></td>
    <td>беззнаковое десятичное целое; <b>unsigned int *</b></td>
</tr>
<tr>
    <td><b>x</b></td>
    <td>шестнадцатеричное целое (с 0x или 0X слева или без них); <b>int *</b></td>
</tr>
<tr>
    <td><b>c</b></td>
    <td>символы; <b>char *</b>. Следующие символы ввода (по умолчанию один) 
размещаются в указанном месте. Обычный пропуск символов-
разделителей подавляется; чтобы прочесть очередной символ, 
отличный от символа-разделителя, используйте %1s</td>
</tr>
<tr>
    <td><b>s</b></td>
    <td>Строка символов(без обрамляющих кавычек); <b>char *</b>, указывающая на 
массив символов, достаточный для строки и завершающего символа '\0', который будет добавлен</td>
</tr>
<tr>
    <td><b>e</b>, <b>f</b>, <b>g</b></td>
    <td>число с плавающей точкой, возможно, со знаком; обязательно 
присутствие либо десятичной точки, либо экспоненциальной части, а 
возможно, и обеих вместе; <b>float *</b></td>
</tr>
<tr>
    <td><b>%</b></td>
    <td>сам знак <b>%</b>, никакое присваивание не выполняется</td>
</tr>
</table>

<p>
Чтобы построить первый пример, обратимся к программе калькулятора из <a href="ch4kr.html">главы 4</a>, 
в которой организуем ввод с помощью функции <i>scanf</i>:
</p>

<pre>
#include &lt;stdio.h&gt;
main() /* программа-калькулятор */
{
    double sum, v;

    sum = 0;
    while (scanf ("%lf", &v) == 1)
        printf("\t%.2f\n", sum += v);
    return 0;
}
</pre>

<p>
Предположим, что нам нужно прочитать строки ввода, содержащие данные вида
</p>

<pre>
25 дек 1988
</pre>

<p>
Обращение к <i>scanf</i> выглядит следующим образом: </p>
<pre>
int day, year; /* день, год */
char monthname[20]; /* название месяца */

scanf ("%d %s %d", &day, monthname, &year);
</pre>

<p>
Знак <i>&</i> перед <i>monthname</i> не нужен, так как имя массива есть указатель.
</p>

<p>
В строке формата могут присутствовать символы, не участвующие ни в одной из 
спецификаций; это значит, что эти символы должны появиться на вводе. Так, мы 
могли бы читать даты вида <i>mm/dd/yy</i> с помощью следующего обращения к <i>scanf</i>:
</p>

<pre>
int day, month, year; /* день, месяц, год */ 
scanf("%d/%d/%d", &day, &month, &year);
</pre>

<p>
В своем формате функция <i>scanf</i> игнорирует пробелы и табуляции. Кроме того, при 
поиске следующей порции ввода она пропускает во входном потоке все символы-
разделители (пробелы, табуляции, новые строки и т.д.). Воспринимать входной 
поток, не имеющий фиксированного формата, часто оказывается удобнее, если 
вводить всю строку целиком и для каждого отдельного случая подбирать 
подходящий вариант <i>sscanf</i>. Предположим, например, что нам нужно читать строки 
с датами, записанными в любой из приведенных выше форм. Тогда мы могли бы 
написать:
</p>

<pre>
while (getline(line, sizeof(line)) > 0) {
    if (sscanf(line, "%d %s %d", &day, monthname, &year) == 3)
        printf("вepно: %s\r", line); /* в виде 25 дек 1968 */ 
    else if (sscanf(line, "%d/%d/%d", &month, &day, &year) == 3)
        printf("вepно: %s\n", line); /* в виде mm/dd/yy */
    else
        printf("неверно: %s\n", line); /* неверная форма даты */
}
</pre>

<p>
Обращения к <i>scanf</i> могут перемежаться с вызовами других функций ввода. Любая 
функция ввода, вызванная после <i>scanf</i>, продолжит чтение с первого еще 
непрочитанного символа.
</p>

<p>
В завершение еще раз напомним, что аргументы функций <i>scanf</i> и <i>sscanf</i> должны 
быть указателями.
</p>

<p>Одна из самых распространенных ошибок состоит в том, что вместо того, 
чтобы написать</p>

<pre>
scanf ("%d", &n);
</pre>

<p>пишут</p>

<pre>
scanf("%d", n);
</pre>

<p>Компилятор о подобной ошибке ничего не сообщает. </p>

<p><b>Упражнение 7.4</b>. Напишите свою версию <i>scanf</i> по аналогии с <i>minprintf</i> из 
предыдущего параграфа.
</p>

<p>
<b>Упражнение 7.5</b>. Перепишите основанную на постфиксной записи программу 
калькулятора из <a href="ch4kr.html">главы 4</a> таким образом, чтобы для ввода и преобразования чисел 
она использовала <i>scanf</i> и/или <i>sscanf</i>.
</p>

<hr>
<a name="p75"></a>
<h3><a href="#cnt">7.5 Доступ к файлам</a></h3>

<p>
Во всех предыдущих примерах мы имели дело со стандартным вводом и стандартным 
выводом, которые для программы автоматически предопределены операционной 
системой конкретной машины.
</p>

<p>
Следующий шаг - научиться писать программы, которые имели бы доступ к файлам, 
заранее не подсоединенным к программам. Одна из программ, в которой возникает 
такая необходимость, - это программа <i>cat</i>, объединяющая несколько именованных 
файлов и направляющая результат в стандартный вывод. Функция <i>cat</i> часто 
применяется для выдачи файлов на экран, а также как универсальный "коллектор" 
файловой информации для тех программ, которые не имеют возможности обратиться 
к файлу по имени. Например, команда
</p>

<pre>
cat x.c y.c
</pre>

<p>направит в стандартный вывод содержимое файлов <i>x.c</i> и <i>y.c</i> (и ничего более).
</p>

<p>
Возникает вопрос: что надо сделать, чтобы именованные файлы можно было 
читать; иначе говоря, как связать внешние имена, придуманные пользователем, с 
инструкциями чтения данных?
</p>

<p>
На этот счет имеются простые правила. Для того чтобы можно было читать из 
файла или писать в файл, он должен быть предварительно открыт с помощью 
библиотечной функции <b>fopen</b>. Функция <i>fopen</i> получает внешнее имя типа <i>x.c</i> или 
<i>y.c</i>, после чего осуществляет некоторые организационные действия и 
"переговоры" с операционной системой (технические детали которых здесь не 
рассматриваются) и возвращает указатель, используемый в дальнейшем для 
доступа к файлу.
</p>

<p>Этот указатель, называемый <i>указателем файла</i>, ссылается на структуру, 
содержащую информацию о файле (адрес буфера, положение текущего символа в 
буфере, открыт файл на чтение или на запись, были ли ошибки при работе с 
файлом и не встретился ли конец файла). Пользователю не нужно знать 
подробности, поскольку определения, полученные из &lt;stdio.h&gt;, включают 
описание такой структуры, называемой <b>FILE</b>.
</p>

<p>
Единственное, что требуется для определения указателя файла, - это задать 
описания такого, например, вида:
</p>

<pre>
FILE *fp;
FILE *fopen(char *name, char *mode);
</pre>

<p>
Это говорит, что <i>fp</i> есть указатель на <i>FILE</i>, a <i>fopen</i> возвращает указатель на 
<i>FILE</i>. Заметим, что <i>FILE</i> — это имя типа) наподобие <i>int</i>, а не тег структуры. Оно 
определено с помощью <b>typedef</b>. (Детали того, как можно реализовать <i>fopen</i> в 
системе UNIX, приводятся в <a href="ch8kr.html#p85">параграфе 8.5</a>.)
</p>

<p>
Обращение к <i>fopen</i> в программе может выглядеть следующим образом: </p>
<pre>
fp = fopen(name, mode);
</pre>

<p>Первый аргумент - строка, содержащая имя файла. Второй аргумент несет 
информацию о режиме. Это тоже строка: в ней указывается, каким образом 
пользователь намерен применять файл. Возможны следующие режимы: чтение (<i>read</i> 
- "r"), запись (<i>write</i> - "w") и добавление (<i>append</i> - "a"), т. е. запись 
информации в конец уже существующего файла. В некоторых системах различаются 
текстовые и бинарные файлы; в случае последних в строку режима необходимо 
добавить букву "b" (<i>binary</i> - бинарный).
</p>

<p>
Тот факт, что некий файл, которого раньше не было, открывается на запись или 
добавление, означает, что он создается (если такая процедура физически 
возможна). Открытие уже существующего файла на запись приводит к выбрасыванию 
его старого содержимого, в то время как при открытии файла на добавление его 
старое содержимое сохраняется. Попытка читать несуществующий файл является 
ошибкой. Могут иметь место и другие ошибки; например, ошибкой считается 
попытка чтения файла, который по статусу запрещено читать. При наличии любой 
ошибки <i>fopen</i> возвращает NULL. (Возможна более точная идентификация ошибки; 
детальная информация по этому поводу приводится в конце <a href="b.html#b1">параграфа 1</a> 
приложения B.)
</p>
<p>
Следующее, что нам необходимо знать, - это как читать из файла или писать в 
файл, коль скоро он открыт. Существует несколько способов сделать это, из 
которых самый простой состоит в том, чтобы воспользоваться функциями <b>getc</b> и 
<b>putc</b>. Функция <i>getc</i> возвращает следующий символ из файла; ей необходимо 
сообщить указатель файла, чтобы она знала откуда брать символ.
</p>

<pre>
int getc(FILE *fp);
</pre>

<p>
Функция <i>getc</i> возвращает следующий символ из потока, на который указывает <i>*fp</i>; 
в случае исчерпания файла или ошибки она возвращает EOF.
</p>

<p>
Функция <i>putc</i> пишет символ <i>c</i> в файл <i>fp</i>
</p>
<pre>
int putc(int с, FILE *fp);
</pre>

<p>
и возвращает записанный символ или EOF в случае ошибки. Аналогично <i>getchar</i> и 
<i>putchar</i>, реализация <i>getc</i> и <i>putc</i> может быть выполнена в виде макросов, а не 
функций.
</p>

<p>
При запуске Си-программы операционная система всегда открывает три файла и 
обеспечивает три файловые ссылки на них. Этими файлами являются: стандартный 
ввод, стандартный вывод и стандартный файл ошибок; соответствующие им 
указатели называются <b>stdin</b>, <b>stdout</b> и <b>stderr</b>; они описаны в &lt;stdio.h&gt;. Обычно 
<i>stdin</i> соотнесен с клавиатурой, а <i>stdout</i> и <i>stderr</i> - с экраном. Однако <i>stdin</i> и 
<i>stdout</i> можно связать с файлами или, используя конвейерный механизм, соединить 
напрямую с другими программами, как это описывалось в <a href="ch7kr.html#p71">параграфе 7.1</a>.
</p>
<p>
С помощью <i>getc</i>, <i>putc</i>, <i>stdin</i> и <i>stdout</i> функции <i>getchar</i> и <i>putchar</i> теперь можно 
определить следующим образом: </p>

<pre>
#define getchar() getc(stdin)
#define putchar(c) putc((c), stdout)
</pre>

<p>
Форматный ввод-вывод файлов можно построить на функциях <b>fscanf</b> и <b>fprintf</b>. 
Они идентичны <i>scanf</i> и <i>printf</i> с той лишь разницей, что первым их аргументом 
является указатель на файл, для которого осуществляется ввод-вывод, формат же 
указывается вторым аргументом.
</p>

<pre>
int fscanf(FILE *fp, char *format, ...)
int fprintf(FILE *fp, char *format, ...)
</pre>

<p>
Вот теперь мы располагаем теми сведениями, которые достаточны для 
написания программы <i>cat</i>, предназначенной для конкатенации (последовательного 
соединения) файлов. Предлагаемая версия функции <i>cat</i>, как оказалось, удобна 
для многих программ. Если в командной строке присутствуют аргументы, они 
рассматриваются как имена последовательно обрабатываемых файлов. Если 
аргументов нет, то обработке подвергается стандартный ввод.
</p>

<pre>
#include &lt;stdio.h&gt;
/* cat: конкатенация файлов, версия 1 */
main(int argc, char *argv[])
{
    FILE *fp;
    void filecopy(FILE *, FILE *);

    if (argc == 1) /* нет аргументов; копируется стандартный ввод */
        filecopy(stdin, stdout);
    else
    while (--argc > 0)
        if ((fp = fopen(*++argv, "r")) == NULL) {
            printf("cat: не могу открыть файл %s\n", *argv);
            return 1;
        } else {
            filecopy(fp, stdout);
            fclose(fp);
        }
    return 0;
}

/* filecopy: копирует файл ifp в файл ofp */
void filecopy(FILE *ifp, FILE *ofp)
{
    int c;
    while ((c = getc(ifp)) != EOF)
        putc(c, ofp);
}
</pre>

<p>
Файловые указатели <i>stdin</i> и <i>stdout</i> представляют собой объекты типа <i>FILE*</i>. 
Это константы, а не переменные, следовательно, им нельзя ничего присваивать. 
</p>
<p>
Функция
</p>

<pre>
int fclose(FILE *fp)
</pre>

<p>- обратная по отношению к <i>fopen</i>; она разрывает связь между файловым 
указателем и внешним именем (которая раньше была установлена с помощью 
<i>fopen</i>), освобождая тем самым этот указатель для других файлов. Так как в 
большинстве операционных систем количество одновременно открытых одной 
программой файлов ограничено, то файловые указатели, если они больше не 
нужны, лучше освобождать, как это и делается в программе <i>cat</i>. Есть еще одна 
причина применить <i>fclose</i> к файлу вывода, - это необходимость "опорожнить" 
буфер, в котором <i>putc</i> накопила предназначенные для вывода данные. При 
нормальном завершении работы программы для каждого открытого файла <i>fclose</i> 
вызывается автоматически. (Вы можете закрыть <i>stdin</i> и <i>stdout</i>, если они вам не 
нужны. Воспользовавшись библиотечной функцией <b>freopen</b>, их можно 
восстановить.)
</p>

<hr>
<a name="p76"></a>
<h3><a href="#cnt">7.6 Управление ошибками (<b>stderr</b> и <b>exit</b>)</a></h3>

<p>
Обработку ошибок в <i>cat</i> нельзя признать идеальной. Беда в том, что если файл 
по какой-либо причине недоступен, сообщение об этом мы получим по окончании 
конкатенируемого вывода. Это нас устроило бы, если бы вывод отправлялся 
только на экран, a не в файл или по конвейеру другой программе.
Чтобы лучше справиться с этой проблемой, программе помимо стандартного вывода 
<i>stdout</i> придается еще один выходной поток, называемый <i>stderr</i>. Вывод в <i>stderr</i> 
обычно отправляется на экран, даже если вывод <i>stdout</i> перенаправлен в другое 
место. Перепишем <i>cat</i> так, чтобы сообщения об ошибках отправлялись в <i>stderr</i>.
</p>

<pre>
#include &lt;stdio.h&gt;
/* cat: конкатенация файлов, версия 2 */
main(int argc, char *argv[])
{
    FILE *fp;
    void filecopy(FILE *, FILE *);
    char *prog = argv[0]; /* имя программы */
    if (argc == 1)        /* нет аргументов, копируется станд. ввод */
        filecopy(stdin, stdout);
    else
        while (--argc > 0)
            if ((fp = fopen(*++argv, "r")) == NULL) {
                fprintf(stderr, "%s: не могу открыть файл %s\n", prog, *argv);
                exit(1);
            } else {
                filecopy(fp, stdout);
                fclose(fp);
            }
    if (ferror(stdout)) {
        fprintf(stderr, "%s: ошибка записи в stdout\n", prog);
        exit(2);
    }
    exit(0);
}
</pre>

<p>
Программа сигнализирует об ошибках двумя способами. Первый - сообщение об 
ошибке с помощью <i>fprintf</i> посылается в <i>stderr</i> с тем, чтобы оно попало на 
экран, а не оказалось на конвейере или в другом файле вывода. Имя программы, 
хранящееся в <i>argv[0]</i>, мы включили в сообщение, чтобы в случаях, когда данная 
программа работает совместно с другими, был ясен источник ошибки.
</p>
<p>
Второй способ указать на ошибку - обратиться к библиотечной функции <b>exit</b>, 
завершающей работу программы. Аргумент функции <i>exit</i> доступен некоторому 
процессу, вызвавшему данный процесс. А следовательно, успешное или ошибочное 
завершение программы можно проконтролировать с помощью некоей программы, 
которая рассматривает эту программу в качестве подчиненного процесса. По 
общей договоренности возврат нуля сигнализирует о том, что работа прошла 
нормально, в то время как ненулевые значения обычно говорят об ошибках. Чтобы 
опорожнить буфера, накопившие информацию для всех открытых файлов вывода, 
функция <i>exit</i> вызывает <i>fclose</i>.
</p>

<p>
Инструкция <b>return</b> <i>exp</i> главной программы <i>main</i> эквивалентна обращению к функции 
<i>exit(exp)</i>. Последний вариант (с помощью <i>exit</i>) имеет то преимущество, что он 
пригоден для выхода и из других функций, и, кроме того, слово <i>exit</i> легко 
обнаружить с помощью программы контекстного поиска, похожей на ту, которую мы 
рассматривали в <a href="ch5kr.html">главе 5</a>. Функция <b>ferror</b> выдает ненулевое значение, если в 
файле <i>fp</i> была обнаружена ошибка.
</p>

<pre>
int ferror(FILE *fp)
</pre>

<p>
Хотя при выводе редко возникают ошибки, все же они встречаются (например, 
оказался переполненным диск); поэтому в программах широкого пользования они 
должны тщательно контролироваться.
</p>

<p>
Функция <b>feof</b>(<i>FILE *fp</i>) aнaлoгичнa функции <i>ferror</i>; oнa вoзвpaщaeт нeнулевое 
значение, если встретился конец указанного в аргументе файла.
</p>

<pre>
int feof(FILE *fp);
</pre>

<p>
В наших небольших иллюстративных программах мы не заботились о выдаче статуса 
выхода, т. е. выдаче некоторого числа, характеризующего состояние программы в 
момент завершения: работа закончилась нормально или прервана из-за ошибки? 
Если работа прервана в результате ошибки, то какой? Любая серьезная программа 
должна выдавать статус выхода.
</p>

<hr>
<a name="p77"></a>
<h3><a href="#cnt">7.7 Ввод-вывод строк</a></h3>

<p>
В стандартной библиотеке имеется программа ввода <b>fgets</b>, аналогичная программе 
<i>getline</i>, которой мы пользовались в предыдущих главах.
</p>

<pre>
char *fgets(char *line, int maxline, FILE *fp)
</pre>

<p>
Функция <i>fgets</i> читает следующую строку ввода (включая и символ новой строки) 
из файла <i>fp</i> в массив символов <i>line</i>, причем она может прочитать не более 
<i>MAXLINE-1</i> символов. Переписанная строка дополняется символом '\0'. Обычно 
<i>fgets</i> возвращает <i>line</i>, а по исчерпании файла или в случае ошибки - NULL. 
(Наша <i>getline</i> возвращала длину строки, которой мы потом пользовались, и нуль 
в случае конца файла.)
</p>

<p>
Функция вывода <b>fputs</b> пишет строку (которая может и не заканчиваться символом 
новой строки) в файл.
</p>

<pre>
int fputs(char *line, FILE *fp)
</pre>

<p>Эта функция возвращает EOF, если возникла ошибка, и неотрицательное 
значение в противном случае.
</p>

<p>
Библиотечные функции <b>gets</b> и <b>puts</b> подобны функциям <i>fgets</i> и <i>fputs</i>. Отличаются 
они тем, что оперируют только стандартными файлами <i>stdin</i> и <i>stdout</i>, и кроме 
того, <i>gets</i> выбрасывает последний символ '\n', a <i>puts</i> его добавляет.
</p>
<p>
Чтобы показать, что ничего особенного в функциях вроде <i>fgets</i> и <i>fputs</i> нет, мы 
приводим их здесь в том виде, в каком они существуют в стандартной библиотеке 
на нашей системе.
</p>

<pre>
/* fgets: получает не более n символов из iop */ 
char *fgets(char *s, int n, FILE *iop) 
{
    register int c;
    register char *cs;

    cs = s;
    while (--n > 0 && (с = getc(iop)) != EOF)
        if ((*cs++ = c) == '\n')
            break;
    *cs= '\0';
    return (c == EOF && cs == s) ? NULL : s;
}

/* fputs: посылает строку s в файл iop */
int fputs(char *s, FILE *iop)
{
    int c;

    while (c = *s++)
        putc(c, iop);
    return ferror(iop) ? EOF : 0;
}
</pre>

<p>
Стандарт определяет, что функция <i>ferror</i> возвращает в случае ошибки ненулевое 
значение; <i>fputs</i> в случае ошибки возвращает EOF, в противном случае - 
неотрицательное значение.
</p>

<p>
С помощью <i>fgets</i> легко реализовать нашу функцию <i>getline</i>:
</p>

<pre>
/* getline: читает строку, возвращает ее длину */
int getline(char *line, int max)
{
    if (fgets(line, max, stdin) == NULL)
        return 0; 
    else
        return strlen(line);
}
</pre>

<p>
<b>Упражнение 7.6</b>. Напишите программу, сравнивающую два файла и печатающую 
первую строку, в которой они различаются.
</p>

<p>
<b>Упражнение 7.7</b>. Модифицируйте программу поиска по образцу из <a href="ch5kr.html">главы 5</a> таким 
образом, чтобы она брала текст из множества именованных файлов, а если имен 
файлов в аргументах нет, то из стандартного ввода. Будет ли печататься имя 
файла, в котором найдена подходящая строка? </p>
<p>
<b>Упражнение 7.8</b>. Напишите программу, печатающую несколько файлов. Каждый файл 
должен начинаться с новой страницы, предваряться заголовком и иметь свою 
нумерацию страниц.
</p>

<hr>
<a name="p78"></a>
<h3><a href="#cnt">7.8 Другие библиотечные функции</a></h3>

<p>
В стандартной библиотеке представлен широкий спектр различных функций. 
Настоящий параграф содержит краткий обзор наиболее полезных из них. Более 
подробно эти и другие функции описаны в <a href="b.html">приложении B</a>.
</p>


<a name="p781"></a>
<h4><a href="#cnt">7.8.1 Операции со строками</a></h4>

<p>
Мы уже упоминали функции <i>strlen</i>, <i>strcpy</i>, <i>strcat</i> и <i>strcmp</i>, описание которых 
даны в &lt;string.h&gt;. Далее, до конца пункта, предполагается, что <i>s</i> и <i>t</i> имеют 
тип <i>char *</i>, <i>c</i> и <i>n</i> - тип <i>int</i>.
</p>

<table>
<tr>
<td nowrap><b>strcat(s,t)</b></td> <td>- приписывает <i>t</i> в конец <i>s</i>.</td>
</tr>
<tr>
<td nowrap><b>strncat(s,t,n)</b></td> <td>- приписывает <i>n</i> символов из <i>t</i> в конец <i>s</i>.</td>
</tr>
<tr>
<td nowrap><b>strcmp(s,t)</b></td> <td>- возвращает отрицательное число, нуль или положительное число 
для <i>s</i> &lt; <i>t</i>, <i>s == t</i> или <i>s</i> &gt; <i>t</i>, соответственно.</td>
</tr>
<tr>
<td nowrap><b>strncmp(s,t,n)</b></td> <td>- делает то же, что и <i>strcmp</i>, но количество сравниваемых 
символов не может превышать <i>n</i></td>
</tr>
<tr>
<td nowrap><b>strcpy(s,t)</b></td> <td>- копирует <i>t</i> в <i>s</i>.</td>
</tr>
<tr>
<td nowrap><b>strncpy(s,t,n)</b></td> <td>- копирует не более <i>n</i> символов из <i>t</i> в <i>s</i>.</td>
</tr>
<tr>
<td nowrap><b>strlen(s)</b></td> <td>- возвращает длину <i>s</i>.</td>
</tr>
<tr>
<td nowrap><b>strchr(s,c)</b></td> <td>- возвращает указатель на первое появление символа <i>c</i> в <i>s</i> или, 
если <i>c</i> нет в <i>s</i>, NULL.</td>
</tr>
<tr>
<td nowrap><b>strrchr(s,c)</b></td> <td>- возвращает указатель на последнее появление символа <i>c</i> в <i>s</i> или, 
если <i>c</i> нет в <i>s</i>, NULL.</td>
</tr>
</table>

<a name="p782"></a>
<h4><a href="#cnt">7.8.2 Анализ класса символов и преобразование символов</a></h4>

<p>
Несколько функций из библиотеки &lt;ctype.h&gt; выполняют проверки и преобразование 
символов. Далее, до конца пункта, переменная <i>c</i> - это переменная типа <i>int</i>, 
которая может быть представлена значением <i>unsigned</i>, <i>char</i> или <i>EOF</i>. Все эти 
функции возвращают значения типа <i>int</i>.
</p>

<table>
<tr>
<td nowrap><b>isalpha(c)</b></td>  <td>- не нуль, если <i>c</i> - буква; 0 в противном случае.</td> 
</tr>
<tr>
<td nowrap><b>isupper(c)</b></td> <td>- не нуль, если <i>c</i> - буква верхнего регистра; 0 в противном случае.</td>
</tr>
<tr>
<td nowrap><b>islower(c)</b></td>  <td>- не нуль, если <i>c</i> - буква нижнего регистра; 0 в противном случае.</td>
</tr>
<tr>
<td nowrap><b>isdigit(c)</b></td>  <td>- не нуль, если <i>c</i> - цифра; 0 в противном случае.</td> 
</tr>
<tr>
<td nowrap><b>isalnum(c)</b></td>  <td>- не нуль, если или <i>isalpha(c)</i>, или <i>isdigit(c)</i> истинны; 0 в противном случае.</td>
</tr>
<tr>
<td nowrap><b>isspace(c)</b></td>  <td>- не нуль, если <i>c</i> - символ пробела, табуляции, новой строки, возврата каретки, перевода страницы, вертикальной табуляции.</td>
</tr>
<tr>
<td nowrap><b>toupper(c)</b></td>  <td>- возвращает <i>c</i>, приведенную к верхнему регистру.</td>
</tr>
<tr>
<td nowrap><b>tolower(c)</b></td>  <td>- возвращает <i>c</i>, приведенную к нижнему регистру.</td>
</tr>
</table>

<a name="p783"></a>
<h4><a href="#cnt">7.8.3 Функция ungetc</a></h4>

<p>
В стандартной библиотеке содержится более ограниченная версия функции <i>ungetch</i> 
по сравнению с той, которую мы написали в <a href="ch4kr.html">главе 4</a>. Называется она <i>ungetc</i>. Эта 
функция, имеющая прототип
</p>
<pre>
int ungetc(int с, FILE *fp)
</pre>
<p>
отправляет символ <i>c</i> назад в файл <i>fp</i> и возвращает <i>c</i>, а в случае ошибки EOF. 
Для каждого файла гарантирован возврат не более одного символа. Функцию 
<i>ungetc</i> можно использовать совместно с любой из функций ввода вроде <i>scanf</i>, 
<i>getc</i>, <i>getchar</i> и т. д.
</p>

<a name="p784"></a>
<h4><a href="#cnt">7.8.4 Исполнение команд операционной системы</a></h4>

<p>
Функция <b>system</b>(char *s) выполняет команду системы, содержащуюся в строке <i>s</i>, и 
затем возвращается к выполнению текущей программы. </p>
<p>
Содержимое <i>s</i>, строго говоря, зависит от конкретной операционной системы. 
Рассмотрим простой пример: в системе UNIX инструкция
</p>
<pre>
system("date");
</pre>

<p>
вызовет программу <i>date</i>, которая направит дату и время в стандартный вывод. 
Функция возвращает зависящий от системы статус выполненной команды. В системе 
UNIX возвращаемый статус - это значение, переданное функцией <i>exit</i>.
</p>

<a name="p785"></a>
<h4><a href="#cnt">7.8.5 Управление памятью</a></h4>
<p>
Функции <b>malloc</b> и <b>calloc</b> динамически запрашивают блоки свободной памяти. 
Функция <i>malloc</i></p>
<pre>
void *malloc(size_t n)
</pre>
<p>
возвращает указатель на <i>n</i> байт неинициализированной памяти или NULL, если 
запрос удовлетворить нельзя. Функция <i>calloc</i></p>
<pre>
void *calloc(size_t n, size_t size)
</pre>
<p>
возвращает указатель на область, достаточную для хранения массива из <i>n</i> 
объектов указанного размера (<i>size</i>), или NULL, если запрос не удается 
удовлетворить. Выделенная память обнуляется.</p>
<p>
Указатель, возвращаемый функциями <i>malloc</i> и <i>calloc</i>, будет выдан с учетом 
выравнивания, выполненного согласно указанному типу объекта. Тем не менее к 
нему должна быть применена операция приведения к соответствующему типу (Как уже отмечалось (см. примеч. в <a href="ch6kr.html#p65">параграфе 6.5</a>), замечания о приведении типов 
значений, возвращаемых функциями <i>malloc</i> или <i>calloc</i>, — неверно. — <i>Примеч. авт.</i>), как 
это сделано в следующем фрагменте программы: </p>

<pre>
int *ip;
ip = (int *) calloc(n, sizeof(int));
</pre>

<p>
Функция <b>free(p)</b> освобождает область памяти, на которую указывает <i>p</i>, -
указатель, первоначально полученный с помощью <i>malloc</i> или <i>calloc</i>. Никаких 
ограничений на порядок, в котором будет освобождаться память, нет, но 
считается ужасной ошибкой освобождение тех областей, которые не были получены 
с помощью <i>calloc</i> или <i>malloc</i>.
</p>
<p>
Нельзя также использовать те области памяти, которые уже освобождены. 
Следующий пример демонстрирует типичную ошибку в цикле, освобождающем 
элементы списка.
</p>

<pre>
for (p = head; p != NULL; p = p->next) /* НЕВЕРНО */
    free(p);
</pre>

<p>
Правильным будет, если вы до освобождения сохраните то, что вам 
потребуется, как в следующем цикле: </p>

<pre>
for (p = head; p != NULL; p = q) {
    q = p->next;
    free(p);
}
</pre>

<p>
В <a href="ch8kr.html#p87">параграфе 8.7</a> мы рассмотрим реализацию программы управления памятью вроде 
<i>malloc</i>, позволяющую освобождать выделенные блоки памяти в любой 
последовательности. </p>

<a name="p786"></a>
<h4><a href="#cnt">7.8.6 Математические функции</a></h4>

<p>
В <b>&lt;math.h&gt;</b> описано более двадцати математических функций. Здесь же 
приведены наиболее употребительные. Каждая из них имеет один или два 
аргумента типа <i>double</i> и возвращает результат также типа <i>double</i>.
</p>

<table>
<tr>
<td nowrap><b>sin(x)</b></td> <td>- синус x, x в радианах</td>
</tr>
<tr>
<td nowrap><b>cos(x)</b></td> <td>- косинус x, x в радианах</td>
</tr>
<tr>
<td nowrap><b>atan2(y,x)</b></td> <td>- арктангенс y/x, y и x в радианах</td>
</tr>
<tr>
<td nowrap><b>exp(x)</b></td> <td>- экспоненциальная функция e в степени x</td>
</tr>
<tr>
<td nowrap><b>log(x)</b></td> <td>- натуральный (по основанию e) логарифм x (x>0)</td>
</tr>
<tr>
<td nowrap><b>log10(x)</b></td> <td>- обычный (по основанию 10) логарифм x (x>0)</td>
</tr>
<tr>
<td nowrap><b>pow(x,y)</b></td> <td>- x в степени y</td>
</tr>
<tr>
<td nowrap><b>sqrt(x)</b></td> <td>- корень квадратный x (x > 0)</td>
</tr>
<tr>
<td nowrap><b>fabs(x)</b></td> <td>- абсолютное значение x</td>
</tr>
</table>


<a name="p787"></a>
<h4><a href="#cnt">7.8.7 Генератор случайных чисел</a></h4>

<p>
Функция <b>rand()</b> вычисляет последовательность псевдослучайных целых в диапазоне 
от нуля до значения, заданного именованной константой RAND_MAX, которая 
определена в &lt;stdlib.h&gt;. Привести случайные числа к значениям с плавающей 
точкой, большим или равным 0 и меньшим 1, можно по формуле
</p>
<pre>
#define frand() ((double) rand() / (RAND_MAX+1.0))
</pre>
<p>
(Если в вашей библиотеке уже есть функция для получения случайных чисел с 
плавающей точкой, вполне возможно, что ее статистические характеристики лучше 
указанной.)
</p>
<p>Функция <b>srand</b>(<i>unsigned</i>) устанавливает семя для <i>rand</i>. Реализации <i>rand</i> и 
<i>srand</i>, предлагаемые стандартом и, следовательно, переносимые на различные 
машины, рассмотрены в <a href="ch2kr.html#p27">параграфе 2.7</a>. </p>
<p>
<b>Упражнение 7.9</b>. Реализуя функции вроде <i>isupper</i>, можно экономить либо память, 
либо время. Напишите оба варианта функции. </p>
</body>
</html>
