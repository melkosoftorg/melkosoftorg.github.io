<html>
<head>
<title>ОП | Для конспекта | Лекция № 44
</title>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<meta http-equiv="Content-Language" content="ru">
<LINK REL=STYLESHEET TYPE="text/css" HREF="../css/style.css" title="style">
</head>
<body bgcolor="#ffffff" text="000066">
<p><center><table width="100%">
<tr bgcolor="#f3f3f3" class="author"><td align=center valign=top>Для конспекта
</td></tr>
<tr><td>
<p>&nbsp;</p>
<h2>Друзья классов </h2>
<ol>
<p><li>Функции, которые, не являясь компонентом класса, имеют доступ к его защищенным и собственным компонентам называются дружественные
<p><li>Для получения прав друга функция должна быть описана в теле класса со спецификатором friend.
<p><li>Права доступа дружественной функции не изменяются и не зависят от спецификаторов доступа.
<p><li>Дружественная функция 
<ul type="disc">
<li>не может быть компонентной функцией того класса, по отношению к которому определяется как дружественная; 
<li>может быть глобальной функцией:
<pre>
	class CL { friend int f1(...); ... };
	int f1(...) { тело_функции }
</pre>
<li>может быть компонентной функцией другого ранее определенного класса:
<pre>
	class CLASS { ... char f2(...); ... };
	class CL { ... friend char CLASS::f2(...); ... };
</pre>
<p>Класс CLASS с помощью своей компонентной функции f2() получает доступ к компонентам класса CL. Компонентная функция некоторого класса (CLASS) может быть объявлена дружественной функцией другому классу (CL), если только определение этого первого класса размещено раньше, чем определение второго (CL). 
<li>может быть дружественной по отношению к нескольким классам: 
<pre>
	// Предварительное неполное определение класса
	class CL2;
	class CL1 { friend void ff(CL1,CL2); ... };
	class CL2 { friend void ff(CL1,CL2); ... };
	void ff(...) { тело функции }
</pre>
</ul>
<p><li>Класс может быть дружественным другому классу. Это означает, что все компонентные функции класса являются дружественными для другого класса. Дружественный класс должен быть определен вне тела класса, "предоставляющего дружбу". 
<p>Например, так: 
<pre>
	class X2 { friend class X1; ... } ;
	class X1 
	{
		... // Определение дружественного класса
		void f1(...); void f2(...);
		...
	};
</pre>
<p><li>Для распространения действия операции на новые пользовательские типы данных программисту необходимо определить специальную функцию, называемую "операция-функция" (operator function).
<p><li>Определение операции-функции имеет вид:
<pre>
	тип_возвращаемого_значения operator знак_операции (спецификация_параметров_операции-функции)
	{
		операторы_тела_операции-функции
	}
</pre>
<p><li>Прототип операции-функции:
<pre>
	тип_возвращаемого_значения operator знак_операции (список аргументов);
</pre>
<p><li>Перегрузка оператора индекса массива [ ]:
<pre>
	тип имя_класса :: operator [ ] (int индекс)
	{
		операторы_тела_операции-функции
	}
</pre>
</ol>
<p>&nbsp;</p>
</td></tr>
<tr bgcolor="#f3f3f3"><td align=center valign=top class="author">&copy;&nbsp;Ставропольский колледж связи, 2012
</td></tr><tr><td>
</table></center></p>
</body>
</html> 