<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | Лекция № 12</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_1.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=a>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=p>&nbsp 6 &nbsp</a></td>
<td><a href="07.htm" class=p>&nbsp 7 &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr>
<td class=usual>
<p align=center class=dbi><br>Рекурсивная функция</p>
<b><center>функция, которая вызывает саму себя или непосредственно, <br>или косвенно через другую 
функцию</center></b>
<p><b>Прямой</b> (непосредственной)
рекурсией является вызов функции
внутри тела этой функции. </p>

<pre>
     int a()
     {.....a().....}
</pre>

<p><b>Косвенной</b> рекурсией является
рекурсия, осуществляющая
рекурсивный вызов функции
посредством цепочки вызова других
функций. Все функции, входящие в
цепочку, тоже считаются
рекурсивными. </p>

<p>Например: </p>

<pre>
                    a(){.....b().....}
                    b(){.....c().....}
                    c(){.....a().....} .
</pre>

<p>Все функции a, b, c являются
рекурсивными, так как при вызове
одной из них, осуществляется вызов
других и самой себя. </p>

<p><b><i>Вычислим факториал числа n! = 1 &#8729; 2 &#8729; 3 &#8729; ... &#8729; n</i></b>, используя рекурсивную функцию.
<br>Надо учесть, что 0! = 1 и 1! = 1.
<p>Можно записать в общем виде: n! = n &#8729; (n - 1) &#8729; (n - 2) &#8729; ... &#8729; 1
<p>Например, 5! = 5 &#8729; 4 &#8729; 3 &#8729; 2 &#8729; 1 = 120

<p>В данной программе вычисляется 10! и используется потоковый вывод результата.
<pre>
	#include&lt;conio.h>
	#include&lt;iostream.h>
	#include&lt;iomanip.h>
	unsigned long faktorial(unsigned long number)
	{
		if(number <= 1)
			return 1;
		else
			return number * faktorial(number - 1);
	}
	void main()
	{	clrscr();
		for (int i = 0; i <= 10; i++)
			cout << setw(2) << i << "! = " << faktorial(i) << endl;
		getch();
	}
</pre>
<p>Еще одним классическим примером использования рекурсии является <b><i>вычисление 
последовательности чисел Фибоначчи: 0, 1, 1, 2, 3, 5, 8, ...</i></b>
<br>Последовательность начинается с 0 и 1, затем каждый следующий член 
последовательности представляет собой сумму двух предыдущих.
<pre>
	#include&lt;conio.h&gt;
	#include&lt;iostream.h&gt;
	unsigned long fibonacci(unsigned long n)
	{
		if(n == 0 || n == 1) 
			return n;
		else 
			return fibonacci(n - 1) + fibonacci(n - 2);
	}
	void main()
	{	clrscr();
		unsigned long res, num;
		for(num = 0; num < 24; num++)
		{
			res = fibonacci(num);
			cout << "Число Фибоначчи(" << num << ") = " 
				<< res << endl;
		}	getch();
	}
</pre>
<p> Найти максимальную цифру в записи данного натурального числа.
<br>При создании функции Maximum было использовано следующее соображение:
<ul type="disc">
<li>если число состоит из одной цифры, то она является максимальной,
<li>иначе если последняя цифра не является максимальной, то ее следует искать среди других цифр числа.
</ul>



<p>Рассмотрим <b>задачу о
Ханойских башнях</b>. Имеются три
стержня с номерами 1, 2, 3. На стержень 1
надето n дисков различного диаметра
так, что они образуют пирамиду
(см. рис. 1). Написать программу для
печати последовательности
перемещений дисков со стержня на
стержень, необходимых для переноса
пирамиды со стержня 1 на стержень 3
при использовании стержня 2 в
качестве вспомогательного. При
этом за одно перемещение должен
переноситься только один диск, и
диск большего диаметра не должен
помещаться на диск меньшего
диаметра. Доказано, что для n дисков
минимальное число необходимых
перемещений равно 2^n-1. </p>
<p align="center"><img src="31.gif" width="309"
height="84">
<br> Рис. 1. Задача о Ханойских
башнях.</p>
<p>Для решения простейшего случая
задачи, когда пирамида состоит
только из одного диска, необходимо
выполнить одно действие - перенести
диск со стержня i на стержень j, что
очевидно (этот перенос
обозначается i -&gt; j). Общий случай
задачи, когда
требуется перенести n дисков со
стержня i на стержень j, считая
стержень w вспомогательным. Сначала
следует перенести n-1 диск со
стержня i на стержень w при
вспомогательном стержне j, затем
перенести один диск со стержня i на
стержень j и, наконец, перенести n-1
диск из w на стержень j, используя
вспомогательный стержень i. Итак,
задача о переносе n дисков сводится
к двум задачам о переносе n-1 диска и
одной простейшей задаче.
<p>Схематически это можно записать
так: 
<pre>
	T(n, i, j, w) = T(n-1, i, w, j), T(1, i, j, w), T(n-1, w, j, i).
 </pre>
<p>Ниже приведена программа, которая
вводит число n и печатает список
перемещений, решающая задачу о
Ханойских башнях при количестве
дисков n. Используется внутренняя
рекурсивная <b>процедура tn(n, i, j, w)</b>,
печатающая перемещения,
необходимые для переноса n дисков
со стержня i на стержень j с
использованием вспомогательного
стержня w при {i, j, w} = {1, 3, 2}. </p>

<pre>
   /*                    ханойские башни                    */
#include &lt;stdio.h>
main()                                 //   вызывающая  функция  
{
	void tn(int, int, int, int);      
	int n;
	scanf(&quot; %d&quot;,&amp;n);
	tn(n, 1, 2, 3);
	return 0;
}

void tn(int n, int i, int j, int w)   //   рекурсивная  функция
{
	if (n&gt;1)                           
	{	
		tn (n-1, i, w, j);
		tn (1, i, j, w);
		tn (n-1, w, j, i);
	}
	else printf(&quot; \n %d -&gt; %d&quot;, i, j);
}
</pre>

<p>Последовательность
вызовов процедуры tn при m = 3
иллюстрируется древовидной
структурой на рис. 2. Каждый раз при
вызове процедуры tn под параметры n,
i, j, w выделяется память и
запоминается место возврата. При
возврате из процедуры tn память,
выделенная под параметры n, i, j, w,
освобождается и становится
доступной память, выделенная под
параметры n, i, j, w предыдущим
вызовом, а управление передается в
место возврата. </p>

<p align="center"><img src="33.gif" width="323"
height="157">
<br> Рис. 2. Последовательность
вызовов процедуры tn.</p>


<p>Использование рекурсии является красивым приёмом программирования. В то же время в большинстве практических задач этот приём неэффективен с точки зрения расходования таких ресурсов ЭВМ, как память и время исполнения программы. Использование рекурсии увеличивает время исполнения программы и зачастую требует значительного объёма памяти для хранения копий подпрограммы на рекурсивном спуске. Поэтому на практике разумно заменять рекурсивные алгоритмы на итеративные.
<p>&nbsp;</p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_1.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=a>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=p>&nbsp 6 &nbsp</a></td>
<td><a href="07.htm" class=p>&nbsp 7 &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>