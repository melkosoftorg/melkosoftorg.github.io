<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<HTML>
<HEAD>
<LINK REL="STYLESHEET" HREF="style.css">
<TITLE>Функции с переменным количеством параметров</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1251">
</HEAD>
<BODY>
<p><strong><center>Функции с переменным количеством параметров </center></strong></p>
<P>В языках C и C++ допустимы функции, количество параметров у которых при компиляции определения функции не определено. Кроме того, могут быть неизвестными и типы параметров. Количество и типы параметров становятся известными только в момент вызова функции, когда явно задан список фактических параметров. При определении и описании таких функций, имеющих списки параметров неопределенной длины, спецификация формальных параметров заканчивается многоточием. Формат прототипа функции с переменным списком параметров: </P>
<PRE>  <STRONG>тип имя (спецификация_явных_параметров, ...); </STRONG></PRE>
<p>где:
<PRE>  <STRONG>тип</STRONG> - тип возвращаемого функцией значения;
  <STRONG>имя</STRONG> - имя функции;
  <STRONG>спецификация_явных_параметров</STRONG> - список спецификаций отдельных параметров, 
  количество и типы которых фиксированы и известны в момент компиляции. 
  Эти параметры можно назвать обязательными.</pRE>
<p>После списка явных (обязательных) параметров ставится необязательная запятая, а затем многоточие, извещающее компилятор, что дальнейший контроль соответствия количества и типов параметров при обработке вызова функции проводить не нужно. Сложность в том, что у переменного списка параметров нет даже имени, поэтому непонятно, как найти его начало и где этот список заканчивается. </p>
<p> К сожалению, в программировании волшебство мало распространено, и поэтому каждая функция с переменным списком параметров должна иметь механизм определения их количества и их типов. Принципиально различных подходов к созданию этого механизма всего два:</p>
<OL>
  <LI> Первый подход предполагает добавление в конец списка реально использованных необязательных фактических параметров специального параметра-индикатора с уникальным значением, которое будет сигнализировать об окончании списка. В теле функции параметры последовательно перебираются, и их значения сравниваются с заранее известным концевым признаком. </LI>
  <LI> Второй подход предусматривает передачу в функцию значения реального количества фактических параметров. Значение реального количества используемых фактических параметров можно передавать в функцию с помощью одного из явно задаваемых (обязательных) параметров. </LI>
</OL>
<P>В обоих подходах - и при задании концевого признака, и при указании числа реально используемых фактических параметров - переход от одного фактического параметра к другому выполняется с помощью указателей, то есть с использованием адресной арифметики. Проиллюстрируем сказанное примерами. </P>
<P>Следующая программа включает функцию с изменяемым списком параметров, первый из которых (единственный обязательный) определяет число действительно используемых при вызове необязательных фактических параметров. </P>
<pre>
	//L1.СРР - заданное количество необязательных параметров
	<b>#include</b> &lt;iostream.h&gt;

	//Функция суммирует значения своих параметров типа <b>int</b>
	<b>long</b> summa(<b>int</b> k, ...)		// k - число суммируемых параметров
	{
		<b>int</b> *pik = &amp;k;
		<b>long</b> total = 0;

		<b>for</b>( ; k; k--)
			total += *(++pik) ;
		<b>return</b> total;
	}

	<b>void</b> main()
	{
		cout &lt;&lt;"\n summa(2, 6, 4) = " &lt;&lt; summa (2, 6, 4);
		cout &lt;&lt;"\n summa(6, 1, 2, 3, 4, 5, 6) = " &lt;&lt; summa(6, 1, 2, 3, 4, 5, 6);
	}</pre>
<Pre>
	<strong>Результат выполнения программы:</strong>
		summa(2, 6, 4) = 10
		summa(6, 1, 2, Э, 4, 5, 6) = 21
</Pre>
<P>Для доступа к списку параметров используется указатель pik типа int *. Вначале ему присваивается адрес явно заданного параметра k , то есть он устанавливается на начало списка параметров в памяти (в стеке). Затем в цикле указатель pik перемещается по адресам следующих фактических параметров, соответствующих неявным формальным параметрам. С помощью разыменования * pik выполняется выборка их значений. Параметром цикла суммирования служит аргумент k , значение которого уменьшается на 1 после каждой итерации и, наконец, становится нулевым. Особенность функции - возможность работы только с целочисленными фактическими параметрами, так как указатель pik после обработки значения очередного параметра &quot;перемещается вперед&quot; на величину sizeof ( int ) и должен быть всегда установлен на начало следующего параметра. </P>
<P>Следующий пример содержит функцию для вычисления произведения переменного количества параметров. Признаком окончания списка фактических параметров служит параметр с нулевым значением. </P>
<pre>
	//L2.СРР - индексация конца переменного списка параметров
	<b>#include</b> &lt;iostream.h&gt;
	// Функция вычисляет произведение параметров:
	<b>double</b> prod (<b>double</b> arg, ...)
	{
		<b>double</b> aa = 1.0;	// Формируемое произведение
		<b>double</b> *prt = &amp;arg;	// Настроили указатель на первый параметр
		<b>if</b> (*prt  == 0.0)
			<b>return</b> 0.0;

		<b>for</b> ( ; *prt; prt++)
			aa *= *prt;
		<b>return</b> aa;
	}

	<b>void</b> main()
	{
		cout &lt;&lt; "\n prod(2e0, 4e0, 3e0, 0e0) = " &lt;&lt; prod(2e0,4e0,3e0,0e0);
		cout &lt;&lt; "\n prod(1.5, 2.0, 3.0, 0.0) = " &lt;&lt; prod(1.5,2.0,3.0,0.0);
		cout &lt;&lt; "\n prod(1.4, 3.0, 0.0, 16.0, 84.3, 0.0) = ";
		cout &lt;&lt; prod(1.4, 3.0, 0.0, 16.0, 84.3, 0.0); 
		cout &lt;&lt; "\n prod(0e0) = " &lt;&lt; prod(0e0);
	}</pre>              
<pre>	<strong>Результат выполнения программы:</strong>
		prod(2e0, 4e0, Зe0, 0e0) = 24
		prod(1.5, 2.0, 3.0, 0.0) = 9
		prod (1.4, 3.0, 0.0, 16.0, 84.3, 0.0) =4. 2
		prod(0e0) = 0
</pre>
<P>В функции prod перемещение указателя prt по списку фактических параметров выполняется всегда за счет изменения prt на величину sizeof ( double ). Поэтому все фактические параметры при обращении к функции prod() должны иметь тип double . В вызовах функции проиллюстрированы некоторые варианты задания параметров. Обратите внимание на вариант с нулевым значением параметра в середине списка. Параметры вслед за этим значением игнорируются. </P>
<P> Чтобы функция с переменным количеством параметров могла воспринимать параметры различных типов, необходимо в качестве исходных данных каким-то образом передавать ей информацию о типах параметров. Для однотипных параметров возможно, например, такое решение - передавать с помощью дополнительного обязательного параметра признак типа параметров. Запишем функцию, выбирающую минимальное из значений параметров, которые могут быть двух типов: или только long , или только int . </P>
<P>Признак типа параметра будем передавать как значение первого обязательного параметра. Второй обязательный параметр определяет количество параметров, из значений которых выбирается минимальное. В следующей программе предложен один из вариантов решения сформулированной задачи: </P>
<pre>
	//L3.CPP - меняются тип и количество параметров функции
	<b>#include</b> &lt;iostream.h&gt;

	<b>void</b> main ()
	{
		<b>long</b> minimum (<b>char</b> z, <b>int</b> k, ...);	// Прототип функции

		cout &lt;&lt; "\n\tminimum('1', 3, 10L, 20L, 30L) = " &lt;&lt; minimum ('1', 3, 10L, 20L, 30L);
		cout &lt;&lt; "\n\tminimum('i', 4, 11, 2, 3, 4) = " &lt;&lt; minimum ('i', 4, 11, 2, 3, 4);
		cout &lt;&lt; "\n\tminimum('k', 2, 0, 64) = " &lt;&lt; minimum ('k', 2, 0, 64);
	}

	// Функция с переменным списком параметров
	<b>long</b> minimum (<b>char</b> z, <b>int</b> k, ...)
	{
		<b>if</b> (z == 'i')
		{
			<b>int</b> *p1 = &amp;k + 1;		// Настроились на первый необязательный параметр
			<b>int</b> min = *p1;			// Значение первого необязательного параметра
			<b>for</b>( ; k; k--, p1++)
				min = (min &gt; *p1) ? *p1 : min;

			<b>return</b> (<b>long</b>) min;
		}

		<b>if</b> (z == '1')
		{
			<b>long</b> *p1 = (<b>long</b>*) (&amp;k + 1);
			<b>long</b> min = *p1;		// Значение первого параметре

			<b>for</b>( ; k; k--, p1++)
				min = (min &gt; *p1) ? *p1 : min;

			<b>return</b> (<b>long</b>) min;
		}

		cout &lt;&lt; "\nОшибка! Неверно задан 1-й параметр:";
		<b>return</b> 2222L;
	}</pre> 
<pre>
	<strong>Результат выполнения программы:</strong>
		minimum('l', 3, 10L, 20L, 30L) = 10 
		minimum ('i', 4, 11, 2, 3, 4) = 2
		Ошибка! Неверно задан 1-й параметр:
		minimum ('k', 2, 0, 64) = 2222
</pre>         
<P> В приведенных примерах функций с изменяемыми списками параметров перебор параметров выполнялся с использованием адресной арифметики и явным применением указателей нужных типов. К проиллюстрированному способу перехода от одного параметра к другому нужно относиться с осторожностью. Дело в том, что при обращении к функции ее параметры помещаются в стек, причем порядок их размещения в стеке зависит от реализации компилятора. Более того, в компиляторах имеются опции, позволяющие изменять последовательность помещения значений параметров в стек. </P>
<P> Стандартная для языка C++ последовательность размещения параметров в стеке предполагает, что первым обрабатывается и помещается в стек последний из параметров функции. При этом у него оказывается максимальный адрес (так стек устроен в реализациях на IBM PC). Именно поэтому для перехода от одного параметра к другому указатель заданного типа увеличивается на 1.
<p>Противоположный порядок обработки и помещения в стек будет у функций, определенных и описанных с модификатором pascal . Этот модификатор и его антипод - модификатор cdecl являются дополнительными ключевыми словами, определенными для компиляторов ТС++ и ВС++. </P>
<ol><li>Во-первых, применение модификатора pascal необходимо в тех случаях, когда функция, написанная на языке C или C++, будет вызываться из программы, подготовленной на Паскале.</li>
<li>Во-вторых, функция с модификатором pascal не может иметь переменного списка параметров, то есть в ее определении и в ее прототипе нельзя использовать многоточие. </li>
<li>Третий факт имеет отношение к разработке программ в среде Windows . Дело в том, что большинство из функций библиотеки API (Application Programming Interface - интерфейс прикладного программирования) для разработки приложений для Windows являются функциями, разработанными с использованием модификатора pascal . </li>
</ol>
<P>Предложенный выше способ передвижения по списку параметров имеет один существенный недостаток - он ориентирован на конкретный тип машин и привязан к реализации компилятора. Поэтому функции могут оказаться непереносимыми. </P>
<P>Для обеспечения мобильности программ с функциями, имеющими изменяемые списки параметров, в каждый компилятор языка C (и языка C++) стандарт предлагает включать специальный набор макроопределений, которые становятся доступными при включении в текст программы заголовочного файла stdarg<b>.</b>h.
Они используются внутри функции для получения аргументов из списка.</p>
<pre>
<p><table width="70%" align=left>
<tr><td><strong>va_list</strong>
</td><td>тип данных для указателя на аргументы
</td></tr>
<tr><td><strong>va_start()</strong>
</td><td>макрос для инициализации списка аргументов
</td></tr>
<tr><td><strong>va_arg()</strong>
</td><td>макрос для получения аргументов по очереди из списка
</td></tr>
<tr><td><strong>va_end()</strong>
</td><td>макрос для очистки лишних данных после получения всех аргументов
</td></tr>
</table></p>
</pre>
<p>Макрокоманды, обеспечивающие простой и стандартный (не зависящий от реализации) способ доступа к конкретным спискам фактических параметров переменной длины, имеют следующий формат: </P>
<pre>
  <strong>void va_start (va_list param, последний_явный_параметр);</strong>
  <strong>type va_arg (va_list param, type); </strong>
  <strong>void va_end (va_list param);</strong>
</pre>
<p> Кроме перечисленных макросов, в файле stdarg.h определен специальный тип данных va_list , соответствующий потребностям обработки переменных списков параметров. Именно такого типа должны быть первые фактические параметры, используемые при обращении к макрокомандам va_start (), va_arg (), va_end ().</p>
<p>Объясним порядок использования перечисленных макроопределений в теле функции с переменным списком параметров. Напомним, что каждая из функций с переменным списком параметров должна иметь хотя бы один явно специфицированный формальный параметр, за которым после запятой стоит многоточие. В теле функции обязательно определяется объект типа va_list. Например, так: </p>
<pre>  <strong>va_list</strong> factor;  </pre>
<p>Определенный таким образом объект factor обладает свойствами указателя. С помощью макроса va_start () объект factor связывается с первым необязательным параметром, то есть с началом списка неизвестной длины. Для этого в качестве второго аргумента при обращении к макросу va_start () используется последний из явно специфицированных параметров функции (предшествующий многоточию): </p>
<pre>  <strong>va_start</strong> (factor, последний_явный_параметр); </pre>
<p>Рассмотрев выше способы перемещения по списку параметров с помощью адресной арифметики, мы уже знаем, что указатель factor сначала &quot;нацеливается&quot; на адрес последнего явно специфицированного параметра, а затем перемещается на его длину и тем самым устанавливается на начало переменного списка параметров. Именно поэтому функция с переменным списком параметров должна иметь хотя бы один явно специфицированный параметр. </p>
<p>Теперь с помощью разыменования указателя factor мы можем получить значение первого фактического параметра из переменного списка. Однако нам неизвестен тип этого фактического параметра. Как и без использования макросов, тип параметра нужно каким-то образом передать в функцию. Если это сделано, то есть определен тип <strong>type</strong> очередного параметра, то обращение к макросу <strong>va_arg</strong> (factor, type) позволяет получить значение очередного (вначале первого) фактического параметра типа type.
</p>
<p>Вторая задача макрокоманды <strong>va_arg</strong> () - заменить значение указателя factor на адрес следующего фактического параметра в списке. Теперь, узнав каким-то образом тип, например type1, этого следующего параметра, можно вновь обратиться к макросу <strong>va_arg</strong> (factor, type1) </p>
<p>Это обращение позволяет получить значение следующего фактического параметра и переадресовать указатель factor на фактический параметр, стоящий за ним в списке, и так далее. </p>
<p><strong>Примечание</strong>. Реализация ТС++ и ВC++ запрещает использовать с макрокомандой <strong>va_arg</strong> () типы <strong>char</strong>, <strong>unsigned</strong> <strong>char</strong>, <strong>float</strong>. </p>
<p>Макрокоманда va_end () предназначена для организации корректного возврата из функции с переменным списком параметров. Ее единственным параметром должен быть указатель типа va_list , который использовался в функции для перебора параметров. Таким образом, для наших рассуждений вызов макрокоманды должен иметь вид:</p>
<pre>  <strong>va_end</strong> (factor); </pre>
<p>Макрокоманда <strong>va_end</strong> () должна быть вызвана после того, как функция обработает весь список фактических параметров. Макрокоманда <strong>va_end</strong> () обычно модифицирует свой аргумент (указатель типа <strong>va_list</strong>), и поэтому его нельзя будет повторно использовать без предварительного вызова макроса va_start (). </p>
<p>Для иллюстрации особенностей использования описанных макросов рассмотрим следующую программу, в которой определена и используется функция для конкатенации любого количества символьных строк. Строки, предназначенные для соединения в одну строку, передаются в функцию с помощью списка указателей-параметров. В конце списка неопределенной длины всегда помещается нулевой указатель NULL. </p>
<pre>
	//L4.СРР - макросредства для переменного списка параметров
	<b>#include</b> &lt;iostream.h&gt;
	<b>#include</b> &lt;string.h&gt;	// Для работы со строками
	<b>#include</b> &lt;stdarg.h&gt;	// Для макросредств
	<b>#include</b> &lt;stdlib.h&gt;	// Для функции mаllос()
	<b>char</b> *concat(<b>char</b> *s1, ...)
	{
		va_list par;			// Указатель на параметры списка
		<b>char</b> *cp = s1;
		<b>int</b> len = strlen(s1);		// Длина 1-го параметра

		va_start(par, s1);		// Начало переменного списка
		// Цикл для определения общей длины параметров-строк:
		<b>while</b> (cp = va_arg(par, <b>char</b> *))
			len += strlen(cp);	// Выделение памяти для результата:

		<b>char</b> *stroka = (<b>char</b> *) malloc (len + 1);
		strcpy (stroka, s1);
		va_start (par, s1);		// Начало переменного списка

		// Цикл конкатенации параметров строк:
		<b>while</b> (cp = va_arg(par, <b>char</b> *))
			strcat (stroka, cp);	// Конкатенация двух строк
		va_end(par);
		<b>return</b> stroka;
	}
	<b>void</b> main ()
	{
		<b>char</b>* concat(<b>char</b>* s1, ...);	// Прототип функции
		<b>char</b>* s;			// Указатель для результата

		s = concat("\nNulla ", "Dies ", "Sine ", "Linea!", NULL);
		s = concat(s, " - Ни одного дня бeз черточки!", "\n\t",
			" (Плиний Старший о художнике Апеллесе) " , NULL);
		cout &lt;&lt; s;
	}
</pre>              
<pre>
	<STRONG>Результат выполнения программы:</STRONG>
		Nulla Dies Sine Linea! - Ни одного дня без черточки! 
		(Плиний Старший о художнике Апеллесе)
</pre>
<p>В функции concat() тип параметров заранее мзвестен и фиксирован. В ряде случаев полезно иметь функцию, параметры которой изменяются как по числу, так и по типам. В этом случае нужно сообщать функции о типе очередного фактического параметра, как, например, в библиотечных функциях форматного ввода/вывода языка C:
<pre>
  printf(char* format, ...);
  scanf(char* format, ...);
</pre>
<p>В обоих функциях форматная строка, связанная с указателем format, содержит спецификации преобразования (%d - для десятичных чисел, %е - для вещественных данных в форме с плавающей точкой, %f - для вещественных значений в форме с фиксированной точкой и так далее). Кроме того, эта форматная строка в функции <strong>printf</strong>&nbsp;() может содержать произвольные символы, которые выводятся на дисплей без какого-либо преобразования. </p>
<p>Чтобы продемонстрировать особенности построения функций с переменным числом параметров, классики языка C (Керниган Б., Ритчи Д.) рекомендуют самостоятельно написать функцию, подобную функции <strong>printf</strong>().
<p>Последуем их совету, применяя простейшие средства вывода языка C++. Разрешим использовать только спецификации преобразования &nbsp;%d &nbsp; и &nbsp;%f . </p>
<pre>
	//L5.СРР - упрощенный аналог printf()
	<b>#include</b> &lt;iostream.h&gt;
	<b>#include</b> &lt;stdarg.h&gt;	// Для макросредств nepeмeнного списка параметров
	<b>void</b> miniprint (<b>char</b> *format, ...)
	{
		va_list ap;			// Указатель на необязательный параметр
		<b>char</b> *p;			// Для просмотра строки format
		<b>int</b> ii;				// Целые параметры
		<b>double</b> dd;			// Параметры типа double
		va_start(ap, format);		// Настроились на 1 параметр

		<b>for</b> (p = format; *p; p++)
		{
			<b>if</b> (*p != '%')
			{
				cout &lt;&lt; *p;
				<b>continue</b>;
			}

			<b>switch</b> (*++p)
			{
				<b>case</b> 'd': ii = va_arg(ap, <b>int</b>); cout &lt;&lt; ii; <b>break</b>;
				<b>case</b> 'f': dd = va_arg(ap, <b>double</b>); cout &lt;&lt; dd; <b>break</b>;
				<b>default</b>:  cout &lt;&lt; *p;
			}	// Конец переключателя
		}		// Конец цикла просмотра строки-формате
		va_end(ap);	// Подготовка к завершение функции
	}

	<b>void</b> main()
	{
		<b>void</b> miniprint(<b>char</b> *, ...);	// Прототип
		<b>int</b> k = 154;
		<b>double</b> e = 2.718282;
		miniprint("\nЦелое k = %d,\t число е = %f", k, e);
	}</pre>               
<pre>
	<strong>Результат выполнения программы:</strong> 
		Целое k = 154, число e = 2.718282
</pre>  
<p>Интересной особенностью предложенной функции miniprint () и ее серьезных, прародителей - библиотечных функций языка C printf () и scanf () - является использование одного явного параметра и для задания типов последующих параметров, и для определения их количества. Для этого в строке, определяющей формат вывода, записывается последовательность спецификаций, каждая из которых начинается символом '%'. Количество спецификаций должно быть в точности равно количеству параметров в следующем за форматом списке. Конец обмена и перебора параметров определяется по достижению конца строки формата. </p>
<p>Рассмотрим функцию average(), вычисляющую среднее арифметическое последовательности целых чисел. В функцию передается единственный фиксированный аргумент,
указывающий, сколько дополнительных аргументов содержит следующий за ним список.</p>
<pre>  
	#include&lt;stdio.h>
	#include&lt;conio.h>
	#include&lt;stdarg.h>
	float average(int num, ...)
	{	// Объявление переменной типа va_list
		va_list arg_ptr;
		// Инициализация указателя на аргументы
		va_start(arg_ptr, num);
		// Получение аргументов из списка
		int i, total = 0;
		for(i = 0; i < num; i++)
			total += va_arg(arg_ptr, int);
		// Очистка ненужных данных
		va_end(arg_ptr);
		// Вычисление среднего арифметического
		// и приведение суммы к типу float
		return ((float) total / num);
	}
	void print(int col, float zn)
	{
		printf("\nСреднее арифметическое %d чисел равно %.2f", col, zn);
	}
	void main(void)
	{	float x; int n; clrscr();
		n = 10; x = average(n, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
		print(n, x);
		n = 5; x = average(n, 121, 206, 76, 31, 5);
		print(n, x); getch();
	}
</pre>  

<pre>  
	<strong>Результат выполнения программы:</strong> 
		Среднее арифметическое 10 чисел равно 5.50
		Среднее арифметическое 5 чисел равно 87.80
</pre>  
<p>&nbsp;</p>
</BODY>
</HTML>