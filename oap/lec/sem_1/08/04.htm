<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | Лекция № 08</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_1.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=a>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=p>&nbsp 6 &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr><td class=usual>
<p align=center class=dbi><br>Форматированный ввод - вывод</p>
<p><table width="95%" align="center" border=1 cellpadding=15 cellspacing=0>
<tr valign="top"><td width="50%">
<p align=center class=dbi><br>Интерактивный ввод данных любого типа</p>
<p>Функции семейства <b><i>... scanf</i></b> позволяют вводить данные любых типов. 
<p><b>Синтаксис</b> int scanf(const char *format [, adress, ...]);
<p><b>Прототип</b> в stdio.h
<p>Функция сканирует (просматривает) клавиатуру, определяет, какие клавиши нажаты, затем интерпретирует 
ввод, основываясь на указателях формата (преобразователи символов).
<pre>           scanf(<строка формата>, <адрес>, <адрес>, ...)</pre>
<p>В scanf() используются те же  
<a href="05.htm"> спецификаторы формата,</a> что и у функции printf.  
<p><i>В строке формата функции scanf() допускаются следующие элементы:</i>
<ul>
<li type="disc">Пробелы и символы табуляции, которые просто игнорируются, но с их помощью можно сделать строку более удобочитаемой.
<li type="disc">Символы (кроме %), которые ставятся в соответствие непустым символам в потоке ввода. 
<li type="disc">Спецификации ввода, состоящие из символа % и следующего за ним специального символа.
Одна спецификация ввода соответствует одному вводимому значению определенного типа.
</ul>
<p><b><i>Функция scanf имеет одно очень важное отличие</i></b>: объекты, следующие за строкой формата, должны быть адресами, а не значениями.
<pre>	scanf("%d %d", &a, &b);</pre>
<p>Этот вызов сообщает программе, что она должна ожидать от вас ввода двух десятичных (целых) чисел, разделенных 
пробелом; первое будет присвоено <b>а</b>, а второе <b>b</b>. 
<br>Здесь используется операция адреса <b>&</b> для передачи адресов <b>а</b> и <b>b</b>
функции scanf. Как только число помещается в область памяти, оно автоматически становится значением 
переменной.
<p>Если необходимо ввести строку, то оператор получения адреса со строковой переменной использовать не надо:
<pre>
	char name[30];
	printf("Как Вас зовут: "); scanf("%s", name);
	printf ("Привет, %s\n", name);
</pre>
name - массив символов, значение name - адрес самого массива. Поэтому перед именем name не используется 
адресный оператор & Значением name является строка символов, не содержащая пробела.
<p><center><b>Обработка лишних символов</b></center>
<p>Функция scanf() выполняет буферизованный ввод: ни один символ не вводится из потока stdin до нажатия клавиши &lt;Enter&gt;.
После ее нажатия из потока поступает целая строка, которая затем обрабатывается функцией scanf() по порядку следования символов.
<br>Выполнение scanf() заканчивается только после того, как введены все данные, соответствующие спецификациям в строке формата.
<p>Пусть при выполнении команды
<pre>
	scanf("%d %d", &x, &y);
</pre>
<p>были введены значения: &nbsp;&nbsp;&nbsp;12&nbsp;&nbsp;&nbsp;21&nbsp;&nbsp;&nbsp;17.&nbsp;&nbsp;&nbsp;
Функция scanf() прочитает два числа 12 и 21, а лишние символы 1 и 7 останутся в потоке stdin в ожидании, что может привести к возникновению ошибок.
<p>Рассмотрим фрагмент программного кода, содержащий ввод вещественного числа и строки символов.
<pre>
	float x;
	char name[80];
	printf("float x = "); scanf("%f", &x);
	printf("x = %f\n", x);
	printf("string name = "); scanf("%s", name);
	printf("\nname - %s", name);
</pre>
<p>Предположим, были введены значения: &nbsp;&nbsp;float x = 345.23 &nbsp;&nbsp; 765.&nbsp;&nbsp;
Результаты работы программы окажутся следующими:
<pre>
	float x = 345.23 &nbsp;&nbsp; 765
	x = 345.230011
	string name =
	name - 765
</pre>
<p>От лишних символов в потоке ввода можно избавиться с помощью функции fflush().
<p><b><i>fflush</i></b> - сбрасывает поток, не оказывает влияния на небуфирезованные потоки.
<p><b>Синтаксис</b> int fflush(FILE * stream);
<br><b>Прототип</b> в stdio.h 
<p>Обычно эта функция используется для работы с дисковыми файлами и ее аргументом является имя потока который следует очистить.
<br>Нам необходимо очистить стандартный поток ввода stdin, поэтому имя именно этого потока используем в качестве аргумента функции.
В результате нам удалось избавиться от лишних символов.
<pre>
	float x;
	char name[80];
	printf("float x = "); scanf("%f", &x);
	printf("x = %f\n", x);
	fflush(stdin);		// очистить поток stdin
	printf("string name = "); scanf("%s", name);
	printf("\nname - %s", name);

<i>Результаты:</i>	float x = 675.98 &nbsp;&nbsp; 876
		x = 675.979980
		string name = Петр

		name - Петр
</pre>
<p>&nbsp;</p>
</td><td>
<p align=center class=dbi><br>Форматированный вывод данных любого типа</p>
Функции семейства ... printf позволяют выводить на дисплей данные всех типов 
и работать со списком из нескольких аргументов. Кроме того, 
можно определить способ форматирования данных. 
<br>Для просмотра результатов вывода на экране монитора 
используются функции printf и cprintf 
<pre>
<b>Синтаксис</b>	int printf(char *format [, argument, ...]);
		int cprintf(char *format[,argument,...]);
<b>Прототип</b> в stdio.h
</pre>
Все функции семейства ...printf генерируют форматный вывод, причем все из них:
<ul>
<li>принимают в качестве аргумента строку формата, определяющую, в каком виде
вывод должен быть отформатирован, это параметр format;
<li>обрабатывают соответственно заданному формату переменное число значений, эти значения задаются в 
списке "argument,...", либо в параметре va_list;
</ul>
<b><i>Cтрока формата</i></b> - символьная строка, состоящая из двух типов объектов:
<ul>
<li>просто символы (переносятся в вывод без изменений),
<li><a href="05.htm">спецификации преобразования</a> (применяются для форматирования).
</ul>
Строка формата, представленная в каждом вызове функций семейства ...printf, управляет тем, как каждая из функций 
будет конвертировать, форматировать и печатать свои аргументы. Для формата должно быть достаточно аргументов, 
иначе результаты могут быть непредвиденными, и, скорее всего, неверными. Лишние аргументы, если их количество 
больше, чем требуется в формате, будут игнорированы.
<p><b><i>Спецификации формата имеют форму:</i></b>
<pre>		% [флажки] [ширина] [. точность] [F|N|h|l] тип</pre>
Каждая спецификация начинается с символа процента %. После процента следуют
признаки в порядке:
<ul>
<li>необязательная последовательность [flags] символов-флажков
<li>необязательная спецификация [width] ширины
<li>необязательная спецификация [.prec] точности
<li>необязательный модификатор [F|N|h|l] входного размера
<li>символ типа преобразования [type]
</ul>
<b><center>Правила управления форматом</center></b>
<p><table border=1 align=center cellpadding=10>
<tr><td> <b><center>Символ или спецификация   </center></b>
</td><td><b><center>Как они управляют форматом</center></b>
</td></tr>          
<tr><td> <b>Flags (флажки)
</td><td>выравнивание вывода, знак числа, десятичная точка, хвостовые нули, восьмеричные и десятичные префиксы
</td></tr>          
<tr><td> <b>width (ширина)
</td><td>Максимальное число печатаемых символов, включая пробелы и нули
</td></tr>
<tr><td> <b>precision (точность)
</td><td>Максимальное число печатаемых символов; для целых чисел максимальное число цифр
</td></tr>
<tr><td> <b>size (размер)
</td><td>Отвергает размер аргумента по умолчанию (N - ближний указатель, F - дальний указатель, h - короткое целое, l - длинное целое)
</td></tr>
</table>
<p>Ниже приведен фрагмент программы, демонстрирующий, как по-разному может 
выглядеть вывод значений <b>x</b> и <b>y</b> с разными спецификаторами вывода.
<pre>
	#include &lt;stdio.h>
	#include &lt;conio.h>
	void main(void)
	{
       		clrscr();
		int x = -3456;  float y = 456.896;

		printf("x = %-10d   y = %+-10.2f\n", x, y);
		printf("x = %08d    y = %08.2f\n", x, y);
		printf("x = %10p    y = %10p\n", x, y);
		getch();
	}

	<i>Результаты:</i>
			x = -3456              y = +456.90
			x = -0003456        y = 00456.90
			x =  0000:F280     y =  8E56:0000
</pre>
<p>В следующем примере переменная <b>v</b> будет выведена на экран в поле шириной z = 10 с двумя десятичными знаками.
<pre>
	float v = 87.965; int z = 10;
	printf("float v = %*.2f", z, v);

	float v =      87.96
</pre>

<p>&nbsp;</p>
</td></tr>
</table>

<p>&nbsp;</p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_1.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=a>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=p>&nbsp 6 &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>