<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | Лекция № 03</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_1.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=p>&nbsp 6 &nbsp</a></td>
<td><a href="07.htm" class=p>&nbsp 7 &nbsp</a></td>
<td><a href="08.htm" class=a>&nbsp 8 &nbsp</a></td>
<td><a href="09.htm" class=p>&nbsp 9 &nbsp</a></td>
<td><a href="10.htm" class=p>&nbsp 10 &nbsp</a></td>
<td><a href="11.htm" class=p>&nbsp 11 &nbsp</a></td>
<td><a href="12.htm" class=p>&nbsp 12 &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr><td class=usual>
<p align=center class=dbi><br>Debug - меню отладки
<br>Вызов: Alt + D</p>
<p>Команды из меню Debug (Отладка) управляют всеми возможностями интегрированного отладчика.
<p><center><table  width="100%">
<tr><td width="40%" valign="top"><left><img src="deb_m.gif"></left>
</td><td width="60%">
Меню Debug (Отладка) позволяет
<ul>
<li><a href="#01">модифицировать значения</a> элемента данных,
<li><a href="#02">вычислять и модифицировать выражения</a>,
<li><a href="#03">отображать последовательность функций</a>,
<li><a href="#04">просматривать выражения</a>,
<li><a href="#05">устанавливать точки приостанова</a>,
<li><a href="#06">управлять использованием точек приостанова</a>.
</ul>
</td></tr>
</table></center>
<p>&nbsp;</p><a name="01"></a>
<p><b><center>Команда Inspect (Инспектировать)
<br>Вызов: Alt + F4</center></b></p>
<p>Команда Debug\Inspect (Отладка\Инспектировать) открывает окно Inspector (Инспекция), которое позволяет проанализировать и модифицировать значения элемента данных.
<br>Тип элемента, который проверяете, определяет тип информации, которая отображается в этом окне.
<br>В системе Borland C++ вы можете проверять значения простых (порядковых) типов 
данных, как то char (символьный) или unsigned long (беззнаковый длинный (двойной 
точности)), указателей, массивов, структур, классов, типов, объединений и функций.
<p>Существует два способа открытия окна Inspector (Инспекция):
<ol><li>Позиционировать курсор на элементе данных, который хотите проанализировать, а затем нажать комбинацию клавиш Alt + F4;
<br>выбрать команду Debug\Inspect (Отладка\Инспектировать), чтобы вызвать блок диалога Inspector (Инспекция), а затем ввести идентификатор переменной или выражение, которое хотите проанализировать.
<li>Другой путь заключается в том, чтобы установить курсор на какое-либо выражение, выбрать команду Debug\Inspect (Отладка\Инспектировать), а затем, находясь в блоке диалога, нажать клавишу "стрелка вправо", чтобы выбрать из текста окна дополнительные символы, составляющие выражение.
</ol>
<p>Для того, чтобы проверить (проинспектировать) данное выражение, необходимо нажать клавишу Enter.
<br>Для того, чтобы закрыть окно Inspector (Инспекция), убедитесь в том, что это окно 
является активным (то есть, находится на самом верху стека окон), а затем нажмите 
клавишу Esc или выберите команду Window\Close (Окно\Закрыть).
<p>Перечень дополнительных операций проверки (инспекции), которые могут быть выполнены:
<ul><li><b><i>субинспекция:</i></b> можете проверить (проинспектировать) определенные элементы, чтобы 
изолировать область просмотра. Когда элемент в окне проверки является 
инспектируемым, строка состояния отображает сообщение "+ Inspect". Для того, чтобы 
провести субинспекцию какого-либо элемента, необходимо переместить маркер 
инспекции на требуемый элемент и нажать клавишу Enter.
<li><b><i>модификация элементов окна инспекции:</i></b> Когда элемент окна инспекции может быть 
модифицирован, в строке состояния отображается строка "Alt + M Modify Field" (Alt + M 
Модификация поля). Переместите курсор к требуемому элементу и нажмите клавишу 
Alt + M; в блоке диалога у вас будет запрошено новое значение.
<li><b><i>инспекция по диапазону:</i></b> Когда инспектируете определенные элементы, можете 
модифицировать диапазон отображаемых значений. Например, можете осуществить 
диапазонную инспекцию переменных-указателей, чтобы указать системе Borland C++, 
на какое число элементов указывает данный указатель. Можете осуществлять 
инспекцию по диапазону в окне инспекции в том случае, когда в строке состояния 
отображается сообщение "Set index range" (Задайте диапазон индекса), командой Alt + I.
</ul>
<p><b><i><center>Восемь типов допустимых в системе окон Inspector (Инспекция)</center></i></b>
<ol><p><b><i><li>Окна Ordinal Inspector (Инспекция перечислимых типов данных)</i></b>
<br>Показывают значение элементов данных простых типов, например char x = 4; unsigned 
long y = 123456L;
<br>Эти окна Inspector (Инспекция) содержат только одну строку информации, которая 
следует за самой верхней строкой (которая обычно отображает адрес переменной, хотя 
она может отображать слово "constant" (константа) или содержать другую информацию по 
объекту - в зависимости от того, какой именно объект вы инспектируете).
<br>Слева располагается обозначение типа скалярной переменной (char, unsigned long и так далее), а 
справа отображается текущее значение переменной. Данное значение может отображаться 
в десятичном, шестнадцатеричном виде или в обоих видах. Обычно оно отображается в 
десятичном виде, за которым следует заключенное в скобки шестнадцатеричное 
представление (использующее стандартный для языка C префикс 0x).
<br>Если отображаемая переменная имеет тип char (символьный), то отображается также 
символьный эквивалент. Если у текущего значения нет эквивалентного печатаемого 
символа, то значение символа отображается с помощью обратной косой черты (обратного 
слэша), за которым следует шестнадцатеричное представление значения. Это символьное 
значение располагается перед десятичным или шестнадцатеричным значениями.
<p><b><i><li>Окна Pointer Inspector (Инспекция указателей)</i></b>
<br>Показывают значение элементов, которые указывают на другие элементы данных, 
например char *p = "abc"; int *ip = 0; int **ipp = &ip;
<br>Окна Pointer Inspector (Инспекция указателей) обычно обладают верхней строкой, которая 
содержит адрес переменной - указателя и адрес, который содержит этот указатель. За ней 
следует единственная строка информации.
<br>Слева располагается [0], обозначающее первый компонент массива. Справа располагается 
значение элемента, на который реализуется указание. Если это значение представляет 
собой составной элемент данных, такой как структуру или массив, то отображается 
максимально возможная часть его, причем значения заключаются в фигурные скобки { и }.
<br>Если указатель является указателем на тип char, и выясняется, что он указывает на строку, 
завершающуюся нулевым символом, появляется дополнительная информация, которая 
показывает значение каждого элемента в этом символьном массиве. Слева в каждой 
строке располагается индекс массива ([1], [2] и так далее), а само значение располагается 
справа, как если бы оно появлялось в окне Inspector (Инспекция) для скалярных типов. В 
этом случае вся строка отображается также в верхней строке в совокупности с адресом 
переменной - указателя и адресом той строки, на которую указывает данная переменная.
<p><b><i><li>Окна Array Inspector (Инспекция массивов)</i></b>
<br>Показывают значение массивов элементов данных.
<br>Например, long thread [3][4][5]; char message[] = "впитай эти слова";
<br>Для каждого компонента массива отводится своя строка. Слева на каждой строке 
располагается индекс данного компонента в массиве. Справа располагается значение 
индексируемого элемента.
<br>Если значение принадлежит составному элементу данных, 
такому как структура или массив, то отображается максимально возможная часть его, 
причем значения заключаются в фигурные скобки { и }.
<p><b><i><li>Окна Structure & Union Inspector (Инспекция структуры и объединения)</i></b>
<br>Показывают значение компонентов в структуре и объединении, например:
<pre>
	struct date			union
	{	int year;			{
		char month;			int small;
		char day;				long large;
	} today;				} holder;
</pre>
<p>Структуры и объединения появляются в одном и том же типе окна Inspector (Инспекция). 
Эти окна Inspector (Инспекция) содержат столько элементов после значения адреса, 
сколько в структуре или объединении содержится компонентов. Каждый элемент 
отображает имя компонента слева и его значение справа. Отображение производится в 
формате, который принят для соответствующих типов данных в языке C.
<p><b><i><li>Окна Function Inspector (Инспекция функции)</i></b>
<br>Показывают тип возвращаемого функцией значения у нижнего края окна инспекции. 
Каждый параметр, с которым вызывается данная функция, появляется вслед за адресом 
памяти у верхнего края списка. Предоставляют информацию относительно параметров 
вызова, типа возвращаемого функцией значения, а также методики вызова данной 
функции (calling conventions).
<p><b><i><li>Окна Class Inspector (Инспекция классов или инспекция объектов)</i></b>
<br>Позволяют инспектировать специфику переменной класса. Это окно отображает имена и 
значения компонентов и методов, определенных в классе.
<p>Окно может быть разделено по горизонтали на две панели. Верхняя панель содержит 
перечень полей данных или компонентов класса, а нижняя панель содержит перечень 
имен компонентных функций и адресов функций.
<br>Для перехода от одной панели окна 
Class Inspector (Инспекция классов) к другой и обратно необходимо воспользоваться 
клавишей Tab.
<p>Если выделенное цветовым или световым маркером поле данных представляет собой 
класс или указатель на класс, то нажатие клавиши Enter приводит к открытию другого 
окна Class Inspector (Инспекция классов) для выделенного маркером типа. Таким образом, 
можно оперативно инспектировать сложные вложенные структуры классов, используя для 
этого минимальное число нажатий клавиш.
<p><b><i><li>Окно Constant Inspector (Инспекция констант)</i></b>
<br>Во многом аналогичны окнам Ordinal Inspector (Инспекция перечислимых типов данных), 
но не содержат адресов и никогда не могут быть модифицированы.
<p><b><i><li>Окно Type Inspector (Инспекция типа)</i></b>
<br>Позволяет проанализировать какой-либо тип. Свое окно Type Inspector (Инспекция типа) 
имеется для каждого вида описанных здесь окон инспекции экземпляров данных. 
Различие между ними заключается в том, что окна инспекции экземпляров отображают 
значение поля, а окна инспекции типа отображают тип поля.
</ol>
<p>&nbsp;</p><a name="02"></a>
<p><b><center>Команда Evaluate/modify... (Вычислить/Модифицировать...)
<br>Вызов: Ctrl + F4</center></b></p>
<p>Вычисляет значение переменной или выражения, отображает их значение и, если это 
возможно, позволяет модифицировать это значение.
<br>Команда отображает значение каждого типа в соответствующем формате. Например, она 
отображает значение типа int как целое по основанию 10 (десятичное целое), а массив как 
указатель по основанию 16 (шестнадцатеричное целое).
<br>Для получения другого формата 
отображения после выражения следует расположить запятую, за которой следует один из 
спецификаторов формата <a href="#07">(Таблица 1)</a>.
<p>Данная команда открывает блок диалога, в котором содержатся три поля:
<ol><li>Поле Expression (Выражение).
<li>Поле Result (Результат).
<li>Поле New Value (Новое значение).
</ol>
<p>Поле Expression (Выражение) показывает используемое по умолчанию выражение, 
которое состоит из слова на позиции курсора в окне редактирования. Можете вычислить 
это используемое по умолчанию выражение нажатием клавиши Enter, либо сначала 
отредактировать или заменить его. Можно также нажать клавишу "стрелка вправо", чтобы 
выбрать из текста окна редактирования дополнительные символы для того, чтобы 
"расширить" используемое по умолчанию выражение.
<br>Можете вычислить любое допустимое в языке C выражение, которое не содержит:
<ul><li>вызовов функций;
<li>идентификаторов или макросов, заданных посредством директивы #define;
<li>локальных или статических переменных, которые находятся вне пределов видимости выполняемой функции.</ul>
<p>Если отладчик может вычислить заданное выражение, он отображает значение выражения в поле Result (Результат).
<br>Если введенное выражение представляет переменную или простой элемент данных, то можете перевести курсор в поле New Value (Новое значение) и ввести в качестве нового значения какое-либо выражение.
<br>Если содержимое поля New Value (Новое значение) было модифицировано, но не выбрана 
кнопка Modify (Модифицировать), то отладчик при закрытии блока диалога 
проигнорирует значение, введенное в поле New Value (Новое значение).
<p>Для отображения последовательно расположенных в памяти элементов данных следует 
воспользоваться суффиксом повтора. Например, для массива целых чисел с именем 
xarray:
<ul><p><li>xarray [0], 5 отображает пять последовательно расположенных целых чисел в десятичном формате;
<li>xarray [0], 5x отображает пять последовательно расположенных целых чисел в шестнадцатеричном формате.</ul>
<p>Выражение, использованное с применением суффикса повтора, должно представлять 
единственный элемент данных. Отладчик рассматривает элемент данных как первый 
элемент массива, если он не является указателем, или как указатель на массив, если он 
является указателем.
<p>&nbsp;</p><a name="03"></a>
<p><b><center>Команда Call Stack (Стек вызовов)
<br>Вызов: Ctrl + F3</center></b></p>
<p>Открывает блок диалога, в котором содержится стек вызовов. Окно отображает 
последовательность функций, которые вызывались программой для достижения той 
функции, которая выполняется в настоящий момент. У основания стека располагается 
функция main (основная); у вершины стека находится та функция, которая выполняется в 
настоящий момент.
<br>Каждый элемент стека отображает имя вызванной функции, а также значения параметров, 
которые были ей переданы.

<p><table align=center width=90% border=1 cellpadding=5 cellspacing=10>
<tr><td class=rule>
<b>Важное замечание:</b> 
Компиляция с немаркированной триггерной кнопкой Standard 
Stack Frame (Стандартный параграф стека) (O\C\Code Generation) приводит к тому, 
что в стеке вызовов некоторые функции будут пропущены. К тому же самому 
эффекту может приводить использование оверлейных модулей.
</td></tr>
</table>
<p>При первом обращении к этому окну расположенный у верхнего края окна элемент будет 
выделен с помощью цветового или светового маркера. Для того, чтобы отобразить 
текущую строку любой другой функции в стеке вызовов следует выбрать имя этой 
функции и нажать клавишу Enter. Курсор перемещается к строке, содержащей вызов той 
функции, которая расположена непосредственно над исследуемой в стеке вызовов.
<p>Например, стек вызовов выглядит следующим образом: func2() func1() main().
<br>Данная последовательность указывает, что функция main осуществила вызов функции 
func1, а функция func1 вызвала функцию func2. Если нужно увидеть выполняющуюся в 
настоящий момент строку функции func1, можете выбрать идентификатор функции func1 
в стеке вызовов и нажать клавишу Enter. В окне редактирования появится код функции 
func1, а курсор окажется установленным на вызов функции func2.
<br>Для того, чтобы возвратиться к текущей строке той функции, которая выполняется в 
настоящий момент (то есть, к позиции выполнения), следует выбрать самую верхнюю 
функцию в стеке вызовов и нажать клавишу Enter.
<a name="07">
<p><b><i>Таблица 1.</b> Спецификаторы формата, распознаваемые в выражениях, анализируемых отладчиком</i>
<p><center><table width=95% border=0 cellpadding=2 cellspacing=3>
<tr><td width=15% valign="top"><b>C</b>
</td><td><b>Символ.</b> Отображает специальные дисплейные символы для управляющих 
символов (коды ASCII с 0 по 31); по умолчанию, такие символы 
отображаются с помощью соответствующих эскейп-последовательностей 
языка C (\n, \t и так далее). Оказывает влияние на символы и строки.
</td></tr>
<tr><td valign="top"><b>S</b>
</td><td><b>Строка.</b> Отображает управляющие символы (коды ASCII с 0 по 31) в виде значений кодов ASCII, используя соответствующие эскейп - последовательности языка C. Поскольку этот формат является стандартным форматом представления символов и строк, спецификатор S оказывается полезным лишь в совокупности со спецификатором M.
</td></tr>
<tr><td valign="top"><b>D</b>
</td><td><b>Десятичный.</b> Отображает все целые значения в десятичном формате. Влияет на простые целые выражения, а также на массивы и структуры, содержащие целые.
</td></tr>
<tr><td valign="top"><b>H или X</b>
</td><td><b>Шестнадцатеричный.</b> Отображает все целые значения в шестнадцатеричном формате с префиксом 0x. Влияет на простые целые выражения, а также на массивы и структуры, содержащие целые.
</td></tr>
<tr><td valign="top"><b>F&lt;n></b>
</td><td><b>Действительное с плавающей точкой.</b> Отображает <n> значащих цифр (<n> является целым в диапазоне от 2 до 18). По умолчанию используется значение 7. Влияет только на действительные числа с плавающей точкой.
</td></tr>
<tr><td valign="top"><b>M</b>
</td><td><b>Дамп памяти.</b> Отображает дамп памяти, начинающийся с адреса указанного выражения. Это выражение должно представлять собой конструкцию, которая допустима в левой части оператора присваивания, то есть конструкцию, которая задает адрес памяти; в ином случае спецификатор M игнорируется.
<br>По умолчанию каждый байт переменной отображается в виде двух шестнадцатеричных цифр. Добавление спецификатора D к спецификатору M приводит к отображению этих байтов в десятичном формате. Добавление спецификаторов H или X приводит к отображению этих байтов в шестнадцатеричном формате. Спецификатор S или C приводит к отображению переменной в виде строки (со специальными символами или без таковых). Отображаемое по умолчанию число байтов соответствует размеру переменной, однако, для задания точного числа отображаемых байтов может быть использован суффикс повтора.
</td></tr>
<tr><td valign="top"><b>P</b>
</td><td><b>Указатель.</b> Отображает указатели в формате <сегмент> : <смещение> с дополнительной информацией о том, куда указывает данный адрес вместо того, чтобы отображать указатели в стандартном аппаратно - ориентированном формате <сегмент> : <смещение>. А именно, данный спецификатор сообщает об области памяти, в которой расположен данный сегмент, а также (если это возможно) об имени переменной, которая расположена по этому смещению.
<p>Имеются следующие области памяти:
<p><center><table width=100% border=0 cellpadding=2 cellspacing=3>
<tr><td width=35% valign="top"><b><i><center>Область памяти</i></b></center>
</td><td><b><i><center>Сообщение по результатам вычисления</i></b></center>
</td></tr>
<tr><td>0000:0000-0000:03FF
</td><td>Interrupt vector table (Таблица векторов прерывания)
</td></tr>
<tr><td>0000:0400-0000:04FF
</td><td>BIOS dataarea (Область данных BIOS)
</td></tr>
<tr><td>0000:0500-Borland C++
</td><td>MS-DOS/TSRs (MS-DOS/ резидентные программы)
</td></tr>
<tr><td>Borland C++ PSP - программа пользователя
</td><td>Система Borland C++ программа пользователя
</td></tr>
<tr><td>PSP программы пользователя 
</td><td>User Process PSP - процесса пользователя
</td></tr>
<tr><td>Программа пользователя - вершина оперативной памяти
</td><td>Имя статической переменной пользователя, если адрес попадает вовнутрь выделенной памяти переменной; в ином случае - ничего.
</td></tr>
<tr><td>A000:0000-AFFF:FFFF
</td><td>EGA/VGA Video RAM (Видеопамять платы EGA/VGA)
</td></tr>
<tr><td>B000:0000-B7FF:FFFF
</td><td>Monochrome Display RAM (Оперативная память монохромного дисплея)
</td></tr>
<tr><td>B800:0000-BFFF:FFFF
</td><td>Color Display RAM (Оперативная память цветного дисплея)
</td></tr>
<tr><td>C000:0000-EFFF:FFFF
</td><td>EMS Pages/AdaptorBIOS ROM's (Страницы отображаемой памяти/ПЗУ BIOS адаптера)
</td></tr>
<tr><td>F000:0000-FFFF:FFFF
</td><td>BIOS ROM's (ПЗУ BIOS (базовой системы ввода/вывода)
</td></tr>
</table></center>
</td></tr>
<tr><td valign="top"><b>R</b>
</td><td><b>Структура / Объединение.</b> Отображает имена полей, а также их значения, например: X : 1, Y : 10, Z : 5. Влияет только на структуры и объединения.
</td></tr>
</table></center>
<p>&nbsp;</p><a name="04"></a>
<p><b><center>Команда Watches (Просмотр выражений)</center></i></b></p>
<p>Открывает всплывающее меню, содержащее команды, которые управляют использованием точек просмотра.
<p><b><i><center>Команда Add watch... (Добавить выражение просмотра)
<br>Вызов: Ctrl + F7</center></i></b></p>
<p>Вставляет в окно Watch (Выражения просмотра) еще одно выражение просмотра.
<br>При выборе данной команды отладчик открывает блок диалога и просит ввести выражение просмотра. В качестве стандартного выражения используется слово, на котором в настоящий момент позиционирован курсор в текущем окне редактирования. Если хотите оперативно ввести то выражение, которое уже использовалось ранее, можете воспользоваться списком "предыстории".
<br>Когда вводите допустимое выражение и нажимаете клавишу Enter или выбираете кнопку OK (Выполнить), отладчик добавляет указанное выражение и его текущее значение в окно Watch (Выражения просмотра).
<br>Если окно Watch (Выражения просмотра) является в настоящий момент текущим окном, то можете вставить новое выражение просмотра нажатием клавиши Ins.
<p><b><i><center>Команда Delete watch (Удалить выражение просмотра)</center></i></b></p>
<p>Удаляет из окна Watch (Выражения просмотра) текущее выражение просмотра. Перед использованием данной команды окно Watch (Выражения просмотра) должно быть активным окном.
<br>Если окно Watch (Выражения просмотра) является активным, то текущее выражение просмотра оказывается выделенным.
<br>Если окно Watch (Выражения просмотра) в настоящий момент не является активным, а активным является другое окно, меню или блок диалога, то это выражение будет помечено точкой в левом поле.
<br>Для того, чтобы удалить выражение просмотра, помеченное с помощью точки, следует выбрать команду Delete watch (Удалить выражение просмотра).
<br>Для того, чтобы удалить выражение просмотра, которое не является текущим (то есть, не выделено и не помечено с помощью точки), необходимо сделать активным окно Watch (Выражения просмотра), выбрать нужное выражение просмотра и нажать либо клавишу Del, либо комбинацию клавиш Ctrl + Y.
<p><b><i><center>Команда Edit watch... (Редактировать выражение просмотра)</center></i></b></p>
<p>Позволяет редактировать текущее выражение просмотра в окне Watch (Выражения просмотра). Для того, чтобы сохранить время, затрачиваемое на повторный ввод, можно воспользоваться списком "предыстории".
<br>Когда выбираете эту команду, отладчик открывает блок диалога, содержащий копию текущего выражения просмотра. Отредактируйте это выражение и нажмите клавишу Enter. Отладчик заменит оригинальную версию выражения на отредактированную.
<br>Можно также отредактировать выражение просмотра изнутри отладчика, если выбрать нужное выражение и нажать Enter.
<p><b><i><center>Команда Remove All watches (Удалить все выражения просмотра)</center></i></b></p>
<p>Удаляет все выражения просмотра из окна Watch (Выражения просмотра).
<p>&nbsp;</p><a name="05"></a>
<p><b><center>Команда Toggle Breakpoint (Триггерная установка точки приостанова)
<br>Вызов: Ctrl + F8</center></b></p>
<p>Позволяет установить или отменить безусловную точку приостанова на той строке, где позиционирован курсор. Когда точка приостанова установлена, она отмечается с помощью маркера точки приостанова.
<p>&nbsp;</p><a name="06"></a>
<p><b><center>Команда Breakpoints... (Точки приостанова)</center></b></p>
<p>Открывает блок диалога, который позволяет управлять использованием точек 
приостанова - как условных (вызывающих приостанов выполнения программы в 
зависимости от выполнения определенного условия), так и безусловных (которые 
вызывают приостанов выполнения программы вне зависимости от каких - либо условий).
<br>Блок диалога показывает все точки приостанова, которые были заданы, соответствующие 
им номера строк, а также условия, при которых будет совершаться приостанов 
выполнения программы. Условию может соответствовать список "предыстории", поэтому 
можно выбрать вызывающее приостанов программы условие, которое было использовано ранее.
<p>Можно удалить точки приостанова из программы, выбрав кнопку Delete (Удалить). 
<p>Можно просмотреть тот исходный код, где установлены существующие точки 
приостанова, выбрав кнопку View (Просмотреть). Выбор кнопки View (Просмотреть) 
перемещает курсор к выбранной точке приостанова. Данная команда не приводит к 
выполнению кода; она лишь осуществляет позиционирование курсора на активных точках приостанова в окне редактирования.
<p>Кнопка At (У объекта) позволяет установить 
точку приостанова у конкретной функции (для обращения к данному средству 
необходимо находиться в режиме отладки).
<p>Для добавления новой точки приостанова к списку необходимо выбрать кнопку Edit 
(Редактировать). Когда осуществляется редактирование точки приостанова, поверх 
первого блока диалога появляется другой блок диалога Breakpoint Modify/New 
(Модифицировать точку приостанова/Новая)
<br>В данном случае номер строки и условия соответствуют той точке приостанова, которая 
была задана. Поле Pass Count (Число проходов) используется для задания числа раз, 
которое данная точка приостанова будет "проследована безостановочно" перед тем, как на ней произойдет приостанов выполнения.
<br>Данный блок диалога содержит также кнопку New (Новая), которая позволяет вводить 
информацию по новой точке приостанова, а также кнопку Modify (Модифицировать), 
которая позволяет зафиксировать установочные значения, введенные в данный блок диалога.
<p>Если в ходе выполнения программе встречается точка приостанова, выполнение 
программы приостанавливается. Когда выполнение программы приостанавливается, 
маркер выполнения позиционируется на строке, содержащей точку приостанова. (При 
этом цветовой маркер точки приостанова будет "заслонен" маркером выполнения; он 
вновь станет виден, как только маркер выполнения сдвинется с текущей строки.)
Когда осуществляется редактирование исходного файла, каждая точка приостанова "привязывается" к той строке, где она установлена. 
<p>Потеря точек приостанова происходит лишь в случаях, когда:
<ul><li>покидаете интегрированную среду;
<li>удаляете строку исходного кода, на которой установлена точка приостанова;
<li>удаляете точку приостанова с помощью команды Toggle Breakpoint (Триггерная установка точки приостанова).
</ul>
<p>Система Borland C++ будет пытаться сохранить информацию о точках приостанова в двух случаях:
<ul><li>если редактируете файл, в котором имеются точки приостанова, но не сохраняете в последствие отредактированную версию этого файла;
<li>если редактируете файл, в котором имеются точки приостанова, а затем продолжаете текущий сеанс отладки, не прибегая к избирательной рекомпиляции программы. (Система Borland C++ отображает запрос-предупреждение "Source modified, rebuild?" ("Исходный файл был модифицирован, осуществить рекомпиляцию?"))
</ul>
<p>Перед тем, как скомпилируете исходный файл, можете установить точку приостанова на любой строке, даже на пустой строке или на строке комментария.
<br>Когда компилируете и выполняете этот файл, система Borland C++ производит проверку допустимости любых установленных точек приостанова, и предоставляет возможность удалить, игнорировать или заменить недопустимые точки приостанова.
<br>Когда осуществляете отладку файла, система Borland C++ обладает информацией, какие именно строки содержат выполняемые операторы, и выдаст предостережение, если пытаетесь установить недопустимые точки приостанова.
<p>Можно установить безусловные точки приостанова, не обращаясь к блоку диалога. Для этого необходимо выбрать команду Debug\Toggle Breakpoint (Отладка\Триггерная установка точки приостанова).
<p>&nbsp;</p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_1.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=p>&nbsp 6 &nbsp</a></td>
<td><a href="07.htm" class=p>&nbsp 7 &nbsp</a></td>
<td><a href="08.htm" class=a>&nbsp 8 &nbsp</a></td>
<td><a href="09.htm" class=p>&nbsp 9 &nbsp</a></td>
<td><a href="10.htm" class=p>&nbsp 10 &nbsp</a></td>
<td><a href="11.htm" class=p>&nbsp 11 &nbsp</a></td>
<td><a href="12.htm" class=p>&nbsp 12 &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>