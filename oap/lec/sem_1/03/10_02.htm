<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | Лекция № 03</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp;</td></tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr><td class=usual>
<p align=center class=dbi><br>Options - меню параметров
<br>Вызов: Alt + O</p><p>&nbsp;</p>
<p><b><center>Команда Compiler (Компилятор)</center></b></p>
<p>Команда Options\Compiler (Параметры\Компилятор) отображает всплывающее меню, 
которое предоставляет возможность задания нескольких параметров, оказывающих 
влияние на процесс компиляции кода.
<p><b><i><center>Команда Code Generation (Генерация кода)</center></i></b></p>
<p>Команда Options\Compiler\Code Generation (Генерация кода) отображает блок диалога, 
содержащий параметры, которые указывают компилятору, как осуществлять генерацию 
объектного кода.
<p><b><i>Model (Модель)</i></b>
<blockquote>
( ) Tiny (Минимальная)
<br>(<b>&#8729;</b>) Small (Малая)
<br>( ) Medium (Средняя)
<br>( ) Compact (Компактная)
<br>( ) Large (Большая)
<br>( ) Huge (Максимальная)
</blockquote>
<p>Кнопка Model (Модель) определяет, какая будет использоваться модель памяти. 
Выбранная модель памяти определяет стандартный метод адресации памяти. Стандартно 
используется малая модель памяти.
<p><b><i>Options (Параметры)</i></b>
<blockquote>
[X] Treat enums as ints (Интерпретировать перечисления как целые)
<br>[&nbsp;&nbsp;&nbsp;] Word alignment (Выравнивание по словам)
<br>[&nbsp;&nbsp;&nbsp;] Duplicate strings merged (Слияние дубликатных строк)
<br>[X] Unsigned characters (Символьные переменные в беззнаковом формате)
<br>[&nbsp;&nbsp;&nbsp;] Pre-compiled headers ()
<br>[&nbsp;&nbsp;&nbsp;] Generate assembler source ()
<br>[&nbsp;&nbsp;&nbsp;] Compile via assembler ()
</blockquote>
<ul>
<li>Маркирование <b><i>Treat enums as ints</i></b> (Интерпретировать перечисления как целые) 
указывает компилятору всегда отводить целое слово. По умолчанию данная кнопка 
маркирована. В качестве эквивалентного параметра командной строки используется 
параметр -b.
<li>Маркирование <b><i>Word alignment</i></b> (Выравнивание по словам) указывает системе 
выравнивать не символьные данные (только структуры и объединения) по четным 
адресам в памяти. Когда данный параметр находится немаркированном состоянии, 
система использует выравнивание по байтам, причем данные (только структуры и 
объединения) могут начинаться как с четных, так и с нечетных адресов, в зависимости 
от очередного свободного адреса. Выравнивание по границам слов увеличивает 
скорость, с которой процессоры 8086 и 80286 осуществляют извлечение и занесение в 
память данных.
<li>Маркирование <b><i>Duplicate strings merged</i></b> (Слияние дубликатных строк) указывает 
системе сливать две строки в одну при их полном совпадении. В результате 
получаются более компактные программы, но это может привести к логическим 
ошибкам, если происходит модификация строк.
<li>Маркирование <b><i>Unsigned characters</i></b> (Символьные переменные в беззнаковом формате) 
указывает системе интерпретировать все объявления объектов типа char, как если бы 
они были объявлены unsigned char. Эта кнопка по умолчанию маркирована.
<li>Маркирование <b><i>Pre-compiled headers</i></b> ()
<li>Маркирование <b><i>Generate assembler source</i></b> ()
<li>Маркирование <b><i>Compile via assembler</i></b> ()
</ul>
<p><b><i>Assume SS Equals DS (Сегмент стека SS и сегмент данных DS)</i></b>
<blockquote>
(<b>&#8729;</b>) Default for memory model (Для модели памяти по умолчанию)
<br>( ) Never (Не использовать)
<br>( ) Always (Постоянно)
</blockquote>
<p>Предполагается, что значение SS не равно DS, то есть, сегмент стека (регистр SS)
не эквивалентен сегменту данных (регистр DS).
<br>В качестве эквивалентного параметра командной строки используется параметр -mml.
<p><b><i>Defines (Макроопределения)</i></b>
<p>Блок ввода Defines (Макроопределения) используется для ввода макроопределений препроцессора.
<br>Если вводится несколько макроопределений, то их следует разделять символом "точка с 
запятой".
<br>Возможно также присвоение значений с помощью знака равенства (=). Начальные и 
конечные символы пробелов отсекаются, но пробелы, которые находятся внутри строки, 
остаются нетронутыми.
<br>Например, приведенный ниже пример означает следующее: определяется имя TESTCODE
переменной PROGCONST присваивается значение 5.
<p><center>TESTCODE; PROGCONST=5</center></p>
<p>Если хотите включить в макрос символ "точка с запятой", перед 
ним необходимо поместить символ обратной косой черты.
<p><b><i><center>Команда Advanced code generation...<br>(Дополнительные параметры генерации кода)</center></i></b></p>
<p><b><i>Floating Point (Плавающая точка)</i></b>
<blockquote>
( ) None (Отсутствует)
<br>(<b>&#8729;</b>) Emulation (Эмуляция)
<br>( ) 8087
<br>( ) 80287/387
</blockquote>
<p>Кнопка Floating Point (Математика плавающей точки) позволяет решить, как должна 
система обрабатывать числа в формате с плавающей точкой.
<br><b><i>None</i></b> (Отсутствует), если не используете числа с плавающей точкой. Но, если используете 
в программе вычисления над числами в формате с плавающей точкой, получите 
сообщение об ошибке на этапе компоновки.
<br><b><i>Emulation</i></b> (Эмуляция), если хотите, чтобы система определяла наличие в компьютере 
сопроцессора 8087 и использовала его при его наличии. Если он отсутствует, система 
будет эмулировать его присутствие.
<br><b><i>8087</i></b> и <b><i>80287/387</i></b>, чтобы генерировать встроенный код указанных сопроцессоров.
<p><b><i>Instruction Set (Набор команд)</i></b>
<blockquote>
(<b>&#8729;</b>) 8088/8086
<br>( ) 80186
<br>( ) 80286
<br>( ) 80386
</blockquote>
<p>Селективная кнопка Instruction Set (Набор команд) позволяет выбрать, для какого набора 
команд процессора будет генерироваться код. Стандартной является селективная кнопка 
8088/8086, которая указывает создавать код, выполняющийся на всем семействе 
персональных компьютеров.
<p><b><i>Options (Параметры)</i></b>
<blockquote>
[X] Generate underbars (Генерация символов подчеркивания)
<br>[&nbsp;&nbsp;&nbsp;] Line numbers debug info (Отладочная информация по номерам строк)
<br>[X] Debug info in OBJs (Внесение отладочной информации в объектный)
<br>[&nbsp;&nbsp;&nbsp;] Browser info in OBJs ()
<br>[X] Fast floating point (Быстрая математика плавающей точки)
<br>[&nbsp;&nbsp;&nbsp;] Fast huge pointers ()
<br>[&nbsp;&nbsp;&nbsp;] Generate COMDEFs ()   
<br>[&nbsp;&nbsp;&nbsp;] Automatic far data ()
</blockquote>
<ul><li>Маркирование <b><i>Generate underbars</i></b> (Генерация символов подчеркивания) указывает 
системе автоматически добавлять символ подчеркивания (_) перед каждым 
глобальным идентификатором (то есть, идентификаторами функций и глобальных 
переменных). Если производите компоновку со стандартными библиотеками, данная 
триггерная кнопка должна быть промаркирована.
<li>Маркирование <b><i>Line numbers debug info</i></b> (Отладочная информация по номерам строк) 
приводит к включению номеров строк в файл таблицы объектного кода (object map file, 
который используется символьным отладчиком). В результате увеличивается размер 
объектного файла и файла таблицы объектного кода, но скорость работы выполняемой 
программы не меняется. По умолчанию данная кнопка не маркирована. Поскольку 
компилятор во время оптимизации операторов переходов может группировать код, 
создавая единый код на основании нескольких строк исходного текста, или может 
переупорядочивать строки, что затрудняет процесс отслеживания номеров строк, надо 
убедиться, что триггерная кнопка Jump Optimization (Оптимизация переходов) была не 
маркирована, когда задается данный параметр.
<li>Триггерная кнопка <b><i>Debug info in OBJs</i></b> (Внесение отладочной информации в объектный 
код) определяет, будет ли включаться в объектные файлы (расширение имени OBJ) 
отладочная информация. По умолчанию данная кнопка маркирована (Используется). 
Это необходимо для того, чтобы проводить как отладку в интегрированном отладчике, 
так и отладку в самостоятельном отладчике Borland Debugger.
<li>Триггерная кнопка <b><i>Debug Browser info in OBJs</i></b> ()
<li>Маркирование <b><i>Fast floating point</i></b> (Быстрая математика плавающей точки) позволяет 
оптимизировать выполнение операций над числами с плавающей точкой 
безотносительно к явным или неявным преобразованиям типов. По умолчанию данная 
кнопка маркирована. В качестве эквивалентного параметра командной строки 
используется параметр -ff.
<li>Триггерная кнопка <b><i>Fast huge pointers</i></b> ()
<li>Триггерная кнопка <b><i>Generate COMDEFs</i></b> ()   
<li>Триггерная кнопка <b><i>Automatic far data</i></b> ()
</ul>
<p><b><i>Far Data Threshold</i></b>   32767
<p>
<p><b><i><center>Команда Entry/Exit Code... ()</center></i></b></p>
<p>
<p><b><i>Prolog/Epilog Code Generation ()</i></b>
<blockquote>
(<b>&#8729;</b>) DOS standard
<br>( ) DOS overlay
<br>( ) Windows all functions exportable
<br>( ) Windows explicit functions exported
<br>( ) Windows smart callbacks
<br>( ) Windows DLL all functions exportable
<br>( ) Windows DLL explicit functions exported
</blockquote>
<p>
<p><b><i>Calling Convention ()</i></b>
<blockquote>
(<b>&#8729;</b>) C
<br>( ) Pascal
<br>( ) Register
</blockquote>
<p>  
<p><b><i>Stack Options ()</i></b>             
<blockquote>
[X] Standard stack frame (Стандартный параграф стека)
<br>[&nbsp;&nbsp;&nbsp;] Test stack overflow (Проверка переполнения стека)
</blockquote>
<ul><li>Маркирование <b><i>Standard stack frame</i></b> (Стандартный параграф стека) указывает системе 
генерировать стандартный параграф стека (стандартный код входа в функцию и 
выхода из него). Этот параметр оказывается полезным при отладке - он упрощает 
процесс обратной трассировки через стек вызванных подпрограмм. По умолчанию 
используется значение параметра Off (Не используется). Если при компиляции 
исходного кода кнопка не маркирована, то любая функция, которая не использует 
локальные переменные и не имеет никаких параметров, компилируется с 
сокращенным кодом входа в функцию и выхода из нее. Это делает код более 
компактным и приводит к повышению скорости его выполнения, но приводит к тому, 
что команда Debug\Call Stack (Отладка\Стек вызовов) "не видит" данную функцию. 
Данная кнопка всегда должна быть маркирована, если исходный код компилируется 
для последующей отладки.
<li>Маркирование <b><i>Test stack overflow</i></b> (Проверка переполнения стека) указывает 
компилятору генерировать код, в котором в период выполнения проводятся проверки 
на переполнение стека. Несмотря на то, что за это приходится платить увеличением 
объема программы и скоростью ее выполнения, это средство может оказать реальную 
помощь, поскольку ошибка переполнения стека относится к числу трудноопределимых 
ошибок. По умолчанию кнопка не маркирована.
</ul>
<p><b><i><center>Команда C++ options... (Параметры C++)</center></i></b></p>
<p>Команда C++ options... (Параметры C++) отображает блок диалога, который 
содержит параметры, указывающие компилятору при использовании языка C++ 
обрабатывать объектный код определенным образом.
<p><b><i>C++ Virtual Tables (Виртуальные таблицы языка C++)</i></b>
<blockquote>
(<b>&#8729;</b>) Smart (Интеллектуальный)
<br>( ) Local (Локальный)
<br>( ) External (Внешний)
<br>( ) Public (Общий, Глобальный)
</blockquote>
<p>Селективные кнопки C++ Virtual Tables (Виртуальные таблицы языка C++) позволяют 
управлять виртуальными таблицами языка C++, а также "раскрытием" встроенных 
функций при отладке.
<ul><li><b><i>Smart</i></b> (Интеллектуальный) приводит к генерации виртуальных таблиц C++ (и встроенных 
функций без раскрытия встроенного кода) таким образом, что в программу будет 
включаться только один экземпляр данной виртуальной таблицы (или встроенной 
функции). Это приводит к генерации минимального по объему и наиболее эффективного 
выполняемого кода, но связано с использованием расширенных конструкций в объектных 
(OBJ) файлах (и ASM файлах), которые доступны только при наличии компоновщика 
TLINK версии 3.0 и ассемблера TASM версии 2.0 (или более поздней).
<br>В качестве эквивалентного параметра командной строки используется параметр -V.
<li><b><i>Local</i></b> (Локальный) приводит к генерации локальных виртуальных таблиц (и встроенных 
функций без раскрытия встроенного кода) таким образом, что каждый модуль получает 
свою собственную индивидуальную копию каждой виртуальной таблицы (или встроенной 
функции), которую он использует. Данный параметр приводит к использованию только 
стандартных конструкций объектных (OBJ) файлов (и ASM файлов), но связано с 
большим размером выполняемых файлов.
<br>В качестве эквивалентного параметра командной строки используется параметр -Vs.
<li><b><i>External</i></b> (Внешний) приводит к генерации внешних ссылок на виртуальные таблицы; один 
или несколько модулей, составляющих программу, должны компилироваться с заданием 
параметра Public (Общий, Глобальный), чтобы задать описания для виртуальных таблиц. 
<br>В качестве эквивалентного параметра командной строки используется параметр -V0.
<li><b><i>Public</i></b> (Общий, Глобальный) приводит к генерации общедоступных описаний 
виртуальных таблиц, поэтому к ним можно обращаться извне из других модулей, которые 
были скомпилированы с заданием параметра External (Внешний).
<br>В качестве эквивалентного параметра командной строки используется параметр -V1.
</ul>
<p><b><i>Use C++ Compiler (Использовать компилятор C++)</i></b>
<blockquote>
(<b>&#8729;</b>) CPP extension (Только расширение CPP)
<br>( ) C++ always (Всегда C++)
</blockquote>
<p>Селективные кнопки Use C++ Compiler (Использовать компилятор C++) указывают 
системе Borland C++, всегда ли нужно компилировать программы как код языка C++, или 
всегда нужно компилировать исходный код как код языка C за исключением тех случаев, 
когда файл имеет расширение CPP.
<p><b><i>Template Generation ()</i></b>
<blockquote>
(<b>&#8729;</b>) Smart ()
<br>( ) Global ()
<br>( ) External ()
</blockquote>
<p>
<p><b><i>Options (Параметры)</i></b>
<blockquote>
[X] Out-of-line inline functions ()
<br>[&nbsp;&nbsp;&nbsp;] Far virtual tables ()
</blockquote>
<p><b><i>Out-of-line inline functions</i></b> следует использовать в тех случаях, когда
необходимо провести пошаговую трассировку встроенных функций (inline functions)
или установить в них точки приостанова программы.
<br><b><i>Far virtual tables</i></b>
<p><b><i><center>Команда Advanced C++ options... ()</center></i></b></p>
<p>
<p><b><i>C++ Member Pointers ()</i></b>
<blockquote>
(<b>&#8729;</b>) Support all cases ()
<br>( ) Support multiple inheritance ()
<br>( ) Support single inheritance ()
<br>( ) Smallest for class ()
</blockquote>
<p>
<p><b><i>Virtual Base Pointers ()</i></b>
<blockquote>
(<b>&#8729;</b>) Always near ()
<br>( ) Same size as 'this' pointer ()
</blockquote>
<p>
<p><b><i>Options (Параметры)</i></b>
<blockquote>
[&nbsp;&nbsp;&nbsp;] 'deep' virtual bases ()
<br>[&nbsp;&nbsp;&nbsp;] True 'pascal' member functions ()
<br>[&nbsp;&nbsp;&nbsp;] Honor precision of member pointers ()
<br>[&nbsp;&nbsp;&nbsp;] Disable constructor displacements ()
<br>[&nbsp;&nbsp;&nbsp;] Pass class values via reference ()
<br>[&nbsp;&nbsp;&nbsp;] Vtable pointer follows data members ()
</blockquote>
<p>
<p><b><i><center>Команда Optimizations (Виды оптимизации)</center></i></b></p>
<p>Команда Optimizations (Виды оптимизации) отображает блок диалога, параметры 
которого указывают компилятору определенным образом осуществлять обработку 
объектного кода в целях оптимизации по скорости или по размеру.
<p><b><i>Optimizations ()</i></b>
<blockquote>
[&nbsp;&nbsp;&nbsp;] Global register allocation ()
<br>[&nbsp;&nbsp;&nbsp;] Invariant code motion ()     
<br>[&nbsp;&nbsp;&nbsp;] Induction variables ()       
<br>[&nbsp;&nbsp;&nbsp;] Loop optimization ()
<br>[&nbsp;&nbsp;&nbsp;] Suppress redundant loads ()
<br>[&nbsp;&nbsp;&nbsp;] Copy propagation ()
<br>[&nbsp;&nbsp;&nbsp;] Assume no pointer aliasing ()
<br>[&nbsp;&nbsp;&nbsp;] Dead code elimination ()
<br>[&nbsp;&nbsp;&nbsp;] Jump optimization (Оптимизация переходов)
<br>[&nbsp;&nbsp;&nbsp;] Inline intrinsic functions ()
<br>[X] Standard stack frame (Стандартная запись активации)
<br>[&nbsp;&nbsp;&nbsp;] Object data calling ()
</blockquote>
<p>Триггерные кнопки группы Optimizations (Оптимизация) влияют на 
оптимизацию генерируемого кода.
<ul>
<li>Параметр <b><i>Global register allocation</i></b> ()
<li>Параметр <b><i>Invariant code motion</i></b> ()     
<li>Параметр <b><i>Induction variables</i></b> ()       
<li>Параметр <b><i>Loop optimization</i></b> ()
<li>Параметр <b><i>Suppress redundant loads</i></b> ()
<li>Параметр <b><i>Copy propagation</i></b> ()
<li>Параметр <b><i>Assume no pointer aliasing</i></b> ()
<li>Параметр <b><i>Dead code elimination</i></b> ()
<li>Параметр <b><i>Jump optimization</i></b> (Оптимизация переходов) уменьшает размер кода, 
устраняя избыточные переходы и реорганизуя операторы циклов и оператор switch 
(переключение).
<p><table align=center width=95% border=1 cellpadding=5 cellspacing=10>
<tr><td class=rule>
<b>Важное замечание:</b> 
Маркирование данной кнопки приводит к тому, что 
последовательности команд трассировки (Trace) и пошагового обхода (Step) в 
интегрированной среде могут привести к противоречиям, поскольку с одной 
конкретной сгенерированной последовательностью кода может быть связано 
множественное число строк исходного кода. Для получения максимально 
качественных результатов при пошаговой отладке программы следует отменить 
использование этого параметра (убрать маркирование кнопки).
</td></tr></table>
<p><li>Параметр <b><i>Inline intrinsic functions</i></b> ()
<li>Параметр <b><i>Standard stack frame</i></b> (Стандартная запись активации)
Генерирует стандартные записи активации (стандартные коды 
вызова и выхода из функции). Целесообразно использовать при отладке с помощью 
символного отладчика для упрощения процесса просмотра хранящихся в стеке
вызванных подпрограмм. По умолчанию включена. 
<br>Если исходный файл компилируется при выключенной опции 
Standart Stack Frame, все функции, не использующие локальные переменные и не 
имеющие параметры, компилируются с сокращенным входом и кодом возврата. 
Это делает код программы короче и быстрее, 
однако делает функции недоступными для Debug/Call Stack. Поэтому, 
если вы хотите использовать отладчик, компилируйте ваш исходный 
файл при включенной опции Standart Stack Frame. 
<li>Параметр <b><i>Object data calling</i></b> ()
</ul>
<p><b><i>Register Variables (Регистровые переменные)</i></b>
<blockquote>
( ) None (Отсутствуют)                
<br>( ) Register keyword (Ключевое слово Register)
<br>(<b>&#8729;</b>) Automatic (Автоматически)
</blockquote>
<p>Селективные кнопки Register Variables (Регистровые переменные) подавляют или 
разрешают использование регистровых переменных.
<br><b><i>Automatic</i></b> (Автоматически), регистровые переменные назначаются автоматически.
<br><b><i>None</i></b> (Отсутствуют), компилятор не использует регистровых переменных даже в том 
случае, когда использовали ключевое слово Register (Регистровый).
<br><b><i>Register keyword</i></b> (Ключевое слово Register), компилятор использует регистровые 
переменные только в том случае, если использовали ключевое слово Register 
(Регистровый), и имеется доступный на данный момент регистр. Как правило, этот 
параметр можно установить в состояние Automatic (Автоматически), если нет 
необходимости в установлении интерфейса с ранее существовавшим ассемблерным 
кодом, который не поддерживает использование регистровых переменных.
<p><b><i>Common Subexpressions ()</i></b>
<blockquote>
(<b>&#8729;</b>) No optimization ()
<br>( ) Optimize locally ()
<br>( ) Optimize globally ()
</blockquote>
<p>    
<p><b><i>Optimize For (Оптимизация по)</i></b>
<blockquote>
(<b>&#8729;</b>) Size (Размеру)
<br>( ) Speed (Скорости)
</blockquote>
<p>Селективные кнопки Optimize For (Оптимизация по) позволяют изменить стратегию 
генерации кода системы Borland C++.
<br>Обычно компилятор осуществляет оптимизацию по размеру, выбирая минимально возможные кодовые последовательности.
<br>Можно указать компилятору осуществлять оптимизацию по скорости, чтобы он выбирал максимально 
быстрые для данной задачи последовательности кода.

<p>Default
<br>Fastest Code
<br>Smallest Code


<p><b><i><center>Команда Source (Исходный код)</center></i></b></p>
<p>Команда Source (Исходный код) отображает блок диалога, параметры которого указывают 
компилятору предполагать наличие определенных видов конструкций в исходном коде.
<p><b><i>Keywords (Ключевые слова)</i></b>
<blockquote>
(<b>&#8729;</b>) Borland C++ (Borland C++)
<br>( ) ANSI (Стандарт ANSI)
<br>( ) UNIX (UNIX)
<br>( ) K&R (По Кернигану и Риччи)
</blockquote>
<p>Селективные кнопки Keywords (Ключевые слова) указывает компилятору, как 
осуществлять распознавание ключевых слов программы.
<br><b><i>Borland C++</i></b> указывает компилятору распознавать ключевые слова расширения синтаксиса системы Borland C++, включая near, far, huge, asm, cdecl, pascal, interrupt, _es, _ds, _cs, _ss и регистровые псевдопеременные (_AX, _BX и так далее).
<br><b><i>ANSI</i></b> (Стандарт ANSI) указывает компилятору распознавать только ключевые слова, которые приняты в стандарте ANSI и интерпретировать любые ключевые слова расширения синтаксиса системы Borland C++ как обычные идентификаторы.
<br><b><i>UNIX V</i></b> указывает компилятору распознавать только ключевые слова, которые приняты в стандарте операционной системы UNIX V и интерпретировать любые ключевые слова расширения синтаксиса системы Borland C++ как обычные идентификаторы.
<br><b><i>K&R</i></b> (по Кернигану и Риччи) указывает компилятору распознавать только ключевые слова расширения синтаксиса, которые приняты в монографии K&R, и интерпретировать любые ключевые слова расширения синтаксиса системы Borland C++ как обычные идентификаторы.
<p><b><i>Source Options (Параметры исходного кода)</i></b>
<blockquote>
[&nbsp;&nbsp;&nbsp;] Nested comments (Вложенные комментарии)
</blockquote>
<p>Nested comments (Вложенные комментарии) позволяет осуществлять вложение 
комментариев в исходных файлах системы Borland C++. Вложенные комментарии не 
допускаются в стандартных реализациях языка C, поскольку они препятствуют 
переносимости кода.
<p><b><i>Identifier Length 32 (Длина идентификатора 32)</i></b>
<p>Блок ввода Identifier Length (Длина идентификатора) следует использовать для задания 
числа <b>n</b> значащих символов идентификатора. За исключением языка C++, который 
распознает идентификаторы неограниченной длины, все идентификаторы 
интерпретируются как различные только в том случае, если их первые <b>n</b> символов 
различны. Сюда входят переменные, имена макросов препроцессора и имена компонентов 
структур. Число может варьироваться в диапазоне от 1 до 32; по умолчанию используется 
значение 32.
<p><b><i><center>Команда Messages (Сообщения)</center></i></b></p>
<p>Команда Messages(Сообщения) отображает блок диалога, который позволяет задать различные 
параметры, влияющие на выдачу компилятором сообщений об ошибках в интегрированной среде. 
<br>Каждый из вложенных блоков диалога позволяет задать или отменить выдачу отдельных категорий 
сообщений об ошибках.
<p><b>Display... - Compiler Messages (Предупреждения компиляции)</b>

<p><b><i>Display warnings (Отображать предупреждающие сообщения)</i></b>
<blockquote>
( ) All
<br>(<b>&#8729;</b>) Selected
<br>( ) None
</blockquote>

<p>Маркирование Display warnings (Отображать предупреждающие сообщения) означает, что могут 
отображаться любые из следующих типов предупреждающих сообщений, если выбрано:
<ul><li>Предупреждения, связанные с мобильностью кода;
<li>Нарушения стандарта ANSI;
<li>Предупреждающие сообщения C++;
<li>Часто встречающиеся ошибки.
</ul>
Когда данная кнопка находится в немаркированном состоянии), предупреждающие сообщения ни 
одной из этих категорий отображаться не будут.


<p><b><i>Errors: Stop After 25 (Ошибки: остановить после 25)</i></b>
<p>Errors: Stop After (Ошибки: остановить после) указывает компилятору остановить выполнение после 
возникновения определенного числа обнаруженных ошибок. По умолчанию используется значение 
25, однако, можно ввести произвольное число в диапазоне от 0 до 255. (Ввод значения 0 указывает 
компилятору продолжать выполнение до конца файла.)
<p><b><i>Warnings: Stop After 100 (Предупреждения: остановить после 100)</i></b>
<p>Warnings: Stop After (Предупреждения: остановить после) указывает компилятору остановить 
выполнение после выдачи определенного числа предупреждающих сообщений. По умолчанию 
используется значение 100, однако, можно ввести произвольное число в диапазоне от 0 до 255. 
(Ввод значения 0 указывает компилятору продолжать выполнение до конца файла или до того 
момента, когда будет достигнуто предельное значение числа ошибок, в зависимости от того, какое 
событие произойдет первым.)


<p><b><i>Portability... Portability Warnings (Предупреждения о переносимости)</i></b>
<blockquote>
[X] Non-portable pointer conversion
<br>[X] Non-portable pointer comparison
<br>[X] Constant out of range in comparison
<br>[&nbsp;&nbsp;&nbsp;] Constant is long
<br>[&nbsp;&nbsp;&nbsp;] Conversion may lose significant digits
<br>[&nbsp;&nbsp;&nbsp;] Mixing pointers to signed and unsigned char
</blockquote>
<p>Portability... (Мобильность) позволяет задать значения параметров, относящихся именно к этой 
категории.

<p><b><i>Ansi violations... (Нарушения стандарта ANSI)</i></b>
<blockquote>
[X] Void functions may not return a value
<br>[X] Both return and return of a value used
<br>[X] Suspicious pointer conversion
<br>[X] Undefined structure 'ident'
<br>[X] Redefinition of 'ident' is not identical
<br>[X] Hexadecimal value more than three digits
<br>[&nbsp;&nbsp;&nbsp;] Bit fields must be signed or unsigned int
<br>[X] 'ident' declared as both external and static
<br>[X] Declare 'ident' prior to use in prototype
<br>[X] Division by zero
<br>[X] Initializing 'ident' with 'ident'
<br>[&nbsp;&nbsp;&nbsp;] Initialization is only partially bracketed
</blockquote>
<p>ANSI violations... (Нарушения стандарта ANSI) позволяет задать значения параметров, относящихся 
именно к этой категории.

<p><b><i>C++ warnings... (C++ предупреждения)</i></b>
<blockquote>
[X] Base initialization without a class name is obsolete
<br>[X] Functions containing 'ident' are not expanded inline
<br>[X] Temporary used to initialize 'ident'
<br>[X] Temporary used for parameter 'ident'
<br>[X] Constant member 'ident' is not initialized
<br>[X] This style of function definition is now obsolete
<br>[X] Use of 'overload' is now unnecessary and obsolete
<br>[X] Assigning 'type' to 'enumeration'
<br>[X] 'function1' hides virtual function 'function2'
<br>[X] Non-const function 'ident' called for const object
<br>[X] Base class 'ident' is inaccessible because also in 'ident'
<br>[X] Overloaded prefix operator used as a postfix operator
<br>[X] Array size for 'delete' ignored
<br>[X] Use qualified name to access nested type 'ident'
</blockquote>
<p>C++ warnings... (Предупреждающие сообщения C++) позволяет задать значения параметров, 
относящихся именно к этой категории.

<p><b><i>Frequent errors... (Часто встречающиеся ошибки)</i></b>
<blockquote>
[X] Function should return a value
<br>[X] Unreachable code
<br>[X] Code has no effect
<br>[&nbsp;&nbsp;&nbsp;] Possible use of 'ident' before definition
<br>[X] 'ident' is assigned a value which is never used
<br>[X] Parameter 'ident' is never used
<br>[X] Possibly incorrect assignment
</blockquote>
<p>Frequent errors... (Часто встречающиеся ошибки) позволяет задать значения параметров, 
относящихся именно к этой категории.

<p><b><i>Less frequent errors... (Редко встречающиеся ошибки)</i></b>
<blockquote>
[&nbsp;&nbsp;&nbsp;] Superfluous & with function
<br>[&nbsp;&nbsp;&nbsp;] Ambiguous operators need parentheses
<br>[&nbsp;&nbsp;&nbsp;] Structure passed by value
<br>[&nbsp;&nbsp;&nbsp;] No declaration for function 'ident'
<br>[X] Call to function with no prototype
<br>[&nbsp;&nbsp;&nbsp;] Unknown assembler instruction
<br>[X] Ill-formed pragma
<br>[X] Condition is always (true/false)
<br>[X] Array variable 'ident' is near
<br>[&nbsp;&nbsp;&nbsp;] 'ident' declared but never used
</blockquote>
<p>

More ANSI violations (Дополнительные сообщения по нарушениям стандарта ANSI) позволяет 
задать значения еще одной группы параметров, относящихся именно к этой категории.
<br>More (Дополнительные сообщения) осуществляет переход к блоку диалога More Frequent errors 
(Другие часто встречающиеся ошибки).

<p><b><i><center>Команда Names (Имена)</center></i></b></p>
<p>Команда Names (Имена) приводит к отображению на экране блока диалога, который позволяет 
изменить стандартные имена сегментов, групп и классов для секций кода Code, данных Data и BSS секций.
<br>Если вы выбираете один из этих пунктов, звездочка <b>*</b> в меню указывает компилятору использовать имена по умолчанию. 

<p><table align=center width=95% border=1 cellpadding=5 cellspacing=10>
<tr><td class=rule>
<b>Важное замечание:</b> 
Не меняйте значения параметров в этой команде, если вы не являетесь 
опытным программистом.
</td></tr></table>
<p>&nbsp;</p>
</td></tr></table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp;</td></tr>
</table>
<a name=#end></a>
</body>
</html>
