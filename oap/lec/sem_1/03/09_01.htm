<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | Лекция № 03</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp;</td></tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr><td class=usual>
<p align=center class=dbi><br>Управление мультифайловыми проектами</p>
<p><center><table width="80%"><tr><td>
<ol>
<li><a href="#01">Возможности менеджера проектов</a>
<li><a href="#02">Использование менеджера проектов</a>
<li><a href="#03">Отслеживание ошибок</a>
<li><a href="#04">Прекращение процесса избирательной рекомпиляции</a>
<li><a href="#05">Синтаксические ошибки в нескольких исходных файлах</a>
<li><a href="#06">Сохранение или удаление сообщений</a>
<li><a href="#07">Проверка автоматически отслеживаемых зависимостей</a>
<li><a href="#08">Использование других трансляторов файлов</a>
<li><a href="#09">Переопределение библиотек</a>
<li><a href="#10">Добавление файлов в проект</a>
<li><a href="#11">Просмотр файлов, включенных в проект</a>
<li><a href="#12">Пометки, относящиеся к проекту</a>
</ol></td></tr>
</table></center>
<p>&nbsp;</p><a name="01"></a>
<p><b><i><center>Возможности менеджера проектов</center></i></b>
<p>Поскольку большая часть программ состоит из нескольких файлов, желательно иметь возможность 
автоматической идентификации тех файлов, которые должны быть рекомпилированы и 
рекомпонованы.
<br>Менеджер проектов позволяет задавать те файлы, которые относятся к описываемому проекту. 
Когда осуществляете рекомпиляцию проекта, менеджер проектов автоматически обновляет 
информацию, которая хранится в файле проекта.
<p><b>В файл проекта входит следующая информация:</b>
<ul><li>имена всех файлов, входящих в проект;
<li>где их следует искать на диске;
<li>какие файлы зависят от других файлов, которые должны быть скомпилированы в первую очередь (автоматически отслеживаемые зависимости);
<li>какие компиляторы и параметры командной строки должны использоваться при создании каждой из частей программы;
<li>куда следует поместить результирующую программу;
<li>размер кода, размер данных и число строк, полученных в результате последней компиляции.
</ul>
<p><b>Для построения проекта следует:</b>
<ul><li>выбрать имя из файла проекта с помощью команды
<pre>
		Project\Open Project (Проект\Открыть проект);
</pre>
<li>добавить к проекту имена исходных файлов с помощью команды
<pre>
		Project\Add Item (Проект\Добавить элемент);
</pre>
<li>задать системе Borland C++ скомпилировать файл с помощью команды
<pre>
		Compile\Make EXE (Компилировать\Создать выполняемый файл).
</pre>
</ul>
<p><b>Когда в меню Project (Проект) станут доступны команды организации проекта, можно:</b>
<ul><li>добавить имена файлов в проект или удалить их из него;
<li>задать параметры для обработки файла, внесенного в проект;
<li>просмотреть содержимое включаемых файлов для конкретного файла в проекте.
<li>просмотреть содержимое включаемых файлов для конкретного файла в проекте.
</ul>
<p>&nbsp;</p><a name="02"></a>
<p><b><i><center>Использование менеджера проектов</center></i></b>
<p>Предположим, имеется программа, которая состоит из основного исходного файла с 
именем MYMAIN.CPP, дополнительного файла MYFUNCS.CPP, содержащего функции и 
данные, обращения к которым имеются в основном файле, и файла MYFUNCS.H.
<p>Файл MYMAIN.CPP:
<pre>
		#include&lt;stdio.h>
		#include "myfuncs.h"
		main (int argc, char *argv[])
		{	char *s;
			if (argc > 1)	s = argv[1];
			else		s = " вселенной";
			printf("%s %s.\n",GetString(),s);
		}
</pre>
<p>Файл MYFUNCS.CPP:
<pre>
		char ss[] ="Ресторан в конце";
		char *GetString(void)
		{
			return ss;
		}
</pre>
<p>Файл MYFUNCS.H:
<pre>
		extern char *GetString(void);
</pre>
<p>Эти файлы составляют программу, которая теперь будет описана для менеджера проектов.
<br>Первый этап заключается в том, чтобы указать системе Borland C++ имя файла проекта, 
который собираетесь использовать. В данном случае назовем его MYPROG.PRJ и оно не 
совпадает с именем основного файла (MYMAIN.CPP). Кроме того, именем выполняемого 
файла будет MYPROG.EXE.
<p>Для того, чтобы перейти к меню Project (Проект), необходимо нажать комбинацию 
клавиш Alt&nbsp;+&nbsp;P.
<br>Затем следует выбрать команду Open Project (Открыть проект).
<br>В результате на экран будет выдан блок диалога Load Project File (Загрузить файл проекта), который 
содержит перечень всех файлов с расширением имени .PRJ в текущей директории, а также 
информацию о дате и времени создания первого файла в этом списке и его размере. 
<p>Поскольку хотим создать новый файл, введем в блок ввода Load Project File (Загрузить 
файл проекта) имя MYPROG.
<br>После открытия проекта в меню Project (Проект) становятся доступными команды:
<blockquote>
Add Item (Добавить элемент),
<br>Delete Item (Удалить элемент),
<br>Local (Локальный)
<br>Include Files (Включаемые файлы).
</blockquote>
<p><table align=center width=90% border=1 cellpadding=5 cellspacing=10>
<tr><td class=rule>
<b>Важное замечание:</b> Если файл проекта, который загружаете в память, находится в другой директории, то текущей директорией станет та, из которой был загружен файл проекта.
</td></tr>
</table>
<p>Можно держать файл проекта в любой директории; для чего необходимо лишь указать в 
качестве составной части имени файла маршрутное имя. (Если исходные файлы находятся 
в других директориях, надо также задать их маршрутные имена).
<br>Все имена файлов и соответствующие маршрутные имена задаются относительно той директории, из которой был загружен файл проекта.
<p>После того, как ввели имя файла проекта, увидите окно Project (Проект).
<br>Окно Project (Проект) содержит имя текущего файла проекта (MYPROG) 
и информацию относительно тех файлов, которые были выбраны в качестве составных 
частей проекта. Для каждого файла будут отображаться имя файла и маршрут файла (его местоположение).
<br>После компиляции этого файла будет также отображено число строк в файле и объем кода и данных (в байтах), сгенерированных компилятором.
<p>Строка состояния, отображаемая у нижнего края экрана, показывает, какое действие может быть выполнено в настоящий момент:
<ul><li>по нажатию клавиши F1 перейдете к системе подсказки,
<li>нажатие клавиши Ins приведет к добавлению файлов к проекту,
<li>клавиша Del удалит файлы из проекта,
<li>нажатие комбинации Ctrl+O позволит задать параметры обработки файла,
<li>нажатие клавиши пробела позволит просмотреть информацию о включаемых файлах, относящихся к какому - либо файлу проекта,
<li>нажатие клавиши F10 переводит к основному меню.
</ul>
<p>Следует нажать клавишу Ins, чтобы добавить файл к списку файлов проекта. Появляется 
блок диалога Add Item to Project List (Добавить элемент к списку файлов проекта), 
который позволяет выбрать исходные файлы и добавить их к проекту.
<br>Блок списка Files (Файлы) отображает все имена файлов в текущей директории, имеющие расширение имени CPP. (В этом списке появляются файлы MYMAIN.CPP и MYFUNCS.CPP). 
<p>Доступны будут три кнопки действия: Add (Добавить), Cancel (Отменить) и Help (Подсказка).
<br>Поскольку стандартной кнопкой является кнопка Add (Добавить), можно занести файл в 
окно Project (Проект), введя его имя в блок ввода Name (Имя) и нажав клавишу Enter или 
выбрав его имя в блоке списка Files (Файлы).
<br>Можно осуществить поиск имени файла в 
блоке списка Files (Файлы), если ввести несколько первых литер имени необходимого 
файла. В данном случае ввод символов my должен привести к желаемому результату: 
маркер установится на имени MYFUNCS.CPP; нажмите клавишу Enter, увидите, что имя 
MYFUNCS добавилось к окну Project (Проект), а вы вернулись к блоку диалога Add Item 
(Добавить элемент), где можете добавить другое имя файла. Сделайте то же самое с 
файлом MYMAIN.CPP.
<br>Система Borland C++ будет осуществлять компиляцию файлов 
именно в том порядке, в котором они появляются в проекте.
<p>Нажмите клавишу Esc, чтобы закрыть этот блок диалога и возвратиться к окну Project (Проект).
<br>Заметьте, что поля Lines (Число строк кода), Code (Объем кода) и Data (Объем 
данных) содержат аббревиатуру n/a (сведения недоступны). Это означает, что данная 
информация будет недоступна до тех пор, пока вы не осуществите компиляцию этих 
модулей.
<p>После того, как были заданы все параметры работы компилятора и имена директорий, 
система Borland C++ будет обладать всей информацией, которая ей необходима для 
построения программы MYPROG.EXE на основе кода, входящего в модули 
MYMAIN.CPP, MYFUNCS.CPP и MYFUNCS.H.
<p>Теперь перейдем к фактическому построению проекта.
<p>Нажмите клавишу F10, чтобы перейти к основному меню.
<br>Создайте программу MYPROG.EXE путем нажатия клавиши F9 (или выбора команды Compile\Make EXE (Компилировать\Создать выполняемый файл)).
<br>Затем выполните программу нажатием комбинации клавиш Ctrl+F9 (или выбором команды Run\Run (Выполнить\Выполнить)).
<p>Чтобы при выходе из интегрированной среды Borland C++ проект, над которым вы 
работали, автоматически был сохранен на диске, необходимо маркировать триггерную 
кнопку Project (Проект) в блоке диалога Preferences (Выбранные параметры) (команда 
Options\Environment (Параметры\Среда работы)).
<p>Сохраненный на диске проект будет состоять из двух файлов:
<ul><li>файла проекта (с расширением имени *.PRJ),
<li>файла макета экрана (с расширением имени *.DSK).</ul>
<p>Файл проекта содержит информацию, которая необходима для построения 
ориентированного на проект выполняемого файла (с расширением имени *.EXE). 
<p>Необходимая для построения выполняемого файла информация состоит из параметров 
работы компилятора, маршрутных имен включаемых файлов, файлов библиотек и 
результирующих файлов, параметров работы компоновщика, параметров выполнения 
избирательной компиляции и программ переноса.
<br>Файл макета экрана состоит из статусной информации по всем окнам на момент последнего использования данного проекта.
<p>&nbsp;</p><a name="03"></a>
<p><b><i><center>Отслеживание ошибок</center></i></b>
<p>Как и в случае состоящей из одного файла программы, при работе с мультифайловой 
программой из окна Message (Сообщение) можно выбирать и просматривать строки с 
синтаксическими ошибками, которые вызвали генерацию компилятором 
предупреждающих сообщений и сообщений об ошибках.
<br>Для того, чтобы убедиться в этом, введем в файлы MYMAIN.CPP MYFUNCS.CPP синтаксические ошибки.
<br>Например, удалим из файла MYMAIN.CPP первую угловую 
скобку из первой строки и литеру "c" из ключевого слова char. Эти модификации 
приведут к генерации пяти сообщений об ошибках и двух предупреждающих сообщений 
по файлу MYMAIN.
<br>Удалим в файле MYFUNCS.CPP первую литеру "r" в ключевом слове return. Эти 
изменения приведут к появлению двух сообщений об ошибках и одного 
предупреждающего сообщения.
<p><table align=center width=90% border=1 cellpadding=5 cellspacing=10>
<tr><td class=rule>
<b>Важное замечание:</b> Внесение модификаций в эти файлы приведет к тому, что они 
окажутся старше соответствующих им объектных файлов, поэтому выполнение команды избирательной рекомпиляции (Make) приведет к их рекомпиляции.
</td></tr>
</table>
<p>Поскольку вы хотите видеть эффект отслеживания ошибок в мультифайловой программе, 
необходимо модифицировать критерии, используемые системой Borland C++ для 
прекращения создания программы, путем маркирования селективной кнопки в блоке 
диалога Make (Избирательная рекомпиляция) (команда Options\Make 
(Параметры\Избирательная рекомпиляция)).
<p>&nbsp;</p><a name="04"></a>
<p><b><i><center>Прекращение процесса избирательной рекомпиляции</center></i></b>
<p>Можно задать тип сообщений об ошибках, при появлении которых будет прекращаться 
процесс избирательной рекомпиляции. Это делается путем задания одного из параметров 
группы Break Make On (Прекратить избирательную рекомпиляцию на) в блоке диалога 
Make (Избирательная рекомпиляция) (команда Options\Make (Параметры\Избирательная рекомпиляция)).
<br>По умолчанию используется параметр Errors (Ошибки), которым пользуются в обычной ситуации.
<br>Можно остановить процесс избирательной 
рекомпиляции после компиляции файла, по которому появились предупреждающие 
сообщения, сообщения об ошибках или сообщения о неисправимых ошибках, а также 
остановить процесс перед тем, как будет произведена попытка компоновки программы.
<p>Полезность каждого из этих режимов в действительности определяется тем способом, при 
помощи которого вы предпочитаете исправлять ошибки и нейтрализовывать предупреждающие сообщения.
<br>Если вы предпочитаете исправлять ошибки сразу после их 
обнаружения, следует выбрать в группе селективных кнопок Break Make On (Прекратить 
избирательную рекомпиляцию на) значение Warnings (Предупреждающие сообщения) или Errors (Ошибки).
<br>Если перед исправлением ошибок вы предпочитаете получить перечень 
всех ошибок во всех исходных файлах, следует выбрать селективную кнопку Fatal Errors 
(Неисправимые ошибки) или Link (компоновка).
<br>В данном случае для демонстрации ошибок в мультифайловой программе выберите в блоке диалога Make (Избирательная 
рекомпиляция) параметр Fatal Errors (Неисправимые ошибки).
<p>&nbsp;</p><a name="05"></a>
<p><b><i><center>Синтаксические ошибки в нескольких исходных файлах</center></i></b>
<p>Поскольку уже введены синтаксические ошибки в файлы MYMAIN.CPP и 
MYFUNCS.CPP, можно осуществить создание проекта путем нажатия клавиши F9 (Make 
(Избирательная рекомпиляция)). В окне компиляции будут отображаться имена 
компилируемых файлов, а также число сообщений об ошибках и предупреждающих 
сообщений в каждом из файлов и суммарная информация по всему процессу рекомпиляции.
<br>Когда в этом окне будет мигать сообщение Errors: Press any key (Ошибки: 
Нажмите какую-либо клавишу), следует нажать произвольную клавишу.
<br>Теперь курсор будет позиционирован на первом сообщении об ошибке или 
предупреждающем сообщении в окне Message (Сообщения).
<br>Если файл, на который ссылается сообщение, находится в редакторе, то световой маркер в окне редактирования 
показывает, где именно компилятор обнаружил ошибку.
<br>Можно осуществлять прокрутку вверх и вниз в окне Message (Сообщение), чтобы просматривать другие сообщения об ошибках.
<p>Для каждого исходного файла, который был скомпилирован, имеется сообщение 
Compiling (Идет компиляция). Эти сообщения служат в качестве границ файлов, разделяя 
различные сообщения, генерируемые по каждому модулю и его включаемым файлам. 
<p>Когда осуществляется прокрутка к сообщению, которое было сгенерировано в другом 
исходном файле, окно редактирования будет отслеживать места генерации ошибок только 
по отношению к тем файлам, которые загружены в настоящий момент в редактор.
<p>Перемещение к какому - либо сообщению, относящемуся к файлу, который не загружен в 
настоящий момент в редактор, приводит к погашению светового маркера в окне 
редактирования.
<br>Чтобы загрузить этот файл в редактор и продолжить трассирование, нажмите клавишу пробела.
<br>Чтобы выбрать одно из этих сообщений, нажмите клавишу 
Enter, когда маркер позиционирован на конкретном сообщении, система Borland C++ 
загрузит этот файл в окно редактирования и позиционирует курсор на месте возникновения ошибки.
<br>Если возвращаетесь к окну Message (Сообщение) (клавиши Alt+W&nbsp;M), то в этом файле возобновится трассировка.
<p>Параметры SourceTracking (Трассировка на уровне исходного кода) в блоке диалога 
Preferences (Приоритеты) (команда Options\Environment (Параметры\Среда работы)) 
помогают определить, в какое окно будет загружаться файл. Эти установочные параметры 
могут использоваться при трассировке сообщений и пошаговой отладке.
<p>На команды Previous message (Предыдущее сообщение) и Next message (Следующее 
сообщение) (комбинации клавиш Alt+F7 Alt+F8) оказывает влияние значение параметра 
Source Tracking (Трассировка на уровне исходного кода). Эти команды всегда будут 
осуществлять поиск предыдущего или последующего сообщений об ошибках и будут 
осуществлять загрузку файла при помощи метода, который был задан параметром Source 
Tracking (Трассировка на уровне исходного кода).
<p>&nbsp;</p><a name="06"></a>
<p><b><i><center>Сохранение или удаление сообщений</center></i></b>
<p>Обычно когда приступаете к рекомпиляции проекта, содержимое окна Message 
(Сообщение) стирается, чтобы освободить место под новые сообщения. Однако, иногда 
желательно сохранять сообщения между двумя рекомпиляциями.
<p>Рассмотрим пример: имеется проект, в который входит значительное число исходных 
файлов и параметры задают прекращение создания программы при обнаружении ошибок. 
<br>После компиляции значительного числа файлов, в которых происходила генерация 
предупреждающих сообщений, появление одной ошибки в одном из файлов приводит к 
прекращению процесса создания программы.
<br>Вы исправляете эту ошибку и хотите определить, воспримет ли компилятор это 
исправление. Но если повторно произведете компиляцию или избирательную рекомпиляцию, 
потеряете возникавшие ранее предупреждающие сообщения. Чтобы избежать этого, необходимо 
маркировать кнопку Save Old Messages (Сохранять старые сообщения) в блоке диалога Preferences 
(Приоритеты) (команда Options\Environment (Параметры\Среда работы)). Благодаря этому 
единственным видом удаляемых сообщений являются генерируемые теми файлами, которые вы 
рекомпилируете.
<br>Таким образом, старые сообщения для данного файла заменяются новыми 
сообщениями, которые может сгенерировать компилятор.
<p>Вы можете избавиться от всех сообщений путем выбора команды Compile\Remove Messages 
(Компилировать\Удалить сообщения), которая стирает все имеющиеся в настоящий момент сообщения.
<br>Демаркирование кнопки Save Old Messages (Сохранять старые сообщения) и 
выполнение очередной избирательной рекомпиляции (Make) также приводит к удалению всех старых сообщений.
<p>&nbsp;</p><a name="07"></a>
<p><b><i><center>Проверка автоматически отслеживаемых зависимостей</center></i></b>
<p>В период компиляции менеджер проектов собирает информацию по последовательностям 
зависимостей и кэширует эту информацию таким образом, что необходимо обрабатывать только те 
файлы, которые компилировались вне интегрированной среды.
<br>Менеджер проектов может автоматически проверять зависимости между исходными файлами в списке проекта (в том числе по 
файлам, которые включаются в эти файлы проекта) и соответствующими им объектными файлами. 
Это оказывается полезным в том случае, когда конкретный исходный файл на языке C++ зависит от других файлов.
<br>Для исходного файла на языке C++ типично включение нескольких файлов 
заголовков (с расширением имени *.H), в которых описывается интерфейс с внешними программами. 
<br>Если интерфейс с этими программами меняется, то вы захотите, чтобы был рекомпилирован тот файл, в котором используются эти подпрограммы.
<p>Если маркируете триггерную кнопку Auto-Dependencies (Автоматически отслеживаемые 
зависимости) (команда Options\Make (Параметры\Избирательная рекомпиляция)), то при 
выполнении рекомпиляции извлекаются значения даты и времени для всех файлов с расширением 
имени *.CPP, и всех файлов, которые в них включены. Затем происходит сравнение информации о 
дате/времени всех этих файлов с датой/временем последней компиляции. Если во времени/дате 
обнаруживаются различия, то исходный файл рекомпилируется.
<p>Если параметр Auto-Dependencies (Автоматически отслеживаемые зависимости) демаркирован, то 
сравниваются показания даты и времени для файлов с расширениями *.C и файлов с расширениями 
*.OBJ. Если существует более поздний файл с расширением *.C, то происходит рекомпиляция.
<p>Когда происходит компиляция файла, компилятор интегрированной среды системы Borland C++ 
(BC.EXE) и компилятор командной строки системы Borland C++ (BCC.EXE) заносят информацию 
по последовательностям зависимостей в объектные файлы. Менеджер проектов использует эту 
информацию, чтобы удостовериться, что каждый файл, который был использован для построения 
объектного файла, проверяется по дате и времени на соответствие объектному файлу. Если даты 
различаются, то происходит рекомпиляция исходного файла с расширением *.C.
<p>&nbsp;</p><a name="08"></a>
<p><b><i><center>Использование других трансляторов файлов</center></i></b>
<p>До сих пор вы создавали проекты, которые используют систему Borland C++ только как языковый 
транслятор. Многие проекты состоят как из кода, написанного на языке C, так и из ассемблерного 
кода, а также, возможно, из кода, написанного на других языках программирования. Было бы 
удобно обладать каким-либо способом, указать системе BorlandC++, как создавать такие модули, используя только что описанные методы проверки зависимостей.
<br>При работе с менеджером проектов не нужно беспокоиться о том, что забыли рекомпилировать эти файлы при внесении 
изменений в какие - либо части их исходного кода, или беспокоиться о занесении их в нужную поддиректорию.
<p>Для каждого исходного файла, включенного в список в окне Project (Проект), можно задать:
<ul><li>какая программа (Borland C++, TASM и так далее) должна использоваться для генерации результирующего файла;
<li>какие параметры командной строки должны задаваться этой программе;
<li>должен ли данный модуль иметь оверлейную структуру;
<li>как будет называться результирующий модуль и куда он будет заноситься (эта информация используется менеджером проектов для определения местоположения файлов, которые требуются для компоновки);
<li>должен ли данный модуль содержать отладочную информацию;
<li>должен ли данный модуль участвовать в процессе компоновки.</ul>
<p>По умолчанию в качестве транслятора для каждого модуля выбирается компилятор 
интегрированной среды системы Borland C++ (BC.EXE). При этом по умолчанию не используются 
никакие параметры переопределения командной строки, для вывода файлов используется 
директория Output (Результирующие файлы) и подразумевается, что обрабатываемый модуль не 
является оверлейным и что отладочная информация не должна исключаться из объектного файла.
<p>Проанализируем простой пример. Перейдите к окну Project (Проект), и переместите маркер к имени 
файла MYFUNCS.CPP, нажмите комбинацию клавиш Ctrl+O, чтобы вызвать относящийся к данному 
файлу блок диалога Override Options (Параметры переопределения).
<p>За исключением Borland C++, каждое из имен в блоке списка Project File Translators (Трансляторы 
файлов проекта) представляет собой ссылку на какую-либо программу, которая описана в блоке 
диалога Transfer (Переход) (команда Options\Transfer (Параметры\Переход)).
<p>Нажмите Esc, затем F10, чтобы возвратиться в основное меню, выберите команду 
Options\Transfer (Параметры\Переход). Появляется блок диалога Transfer (Переход), в 
котором содержится перечень всех программ перехода, описанных в настоящее время. 
<br>Выберите Турбо Ассемблер и нажмите Enter. (Поскольку стандартной кнопкой является 
кнопка Edit (Редактировать), нажатие Enter приводит к появлению на экране блока 
диалога Modify/New Transfer Item (Элемент списка переходов: Модифицировать/Новый)). 
<br>Вы видите, что Турбо Ассемблер описан как программа TASM, расположенная в 
доступной по маршрутному поиску директории. Триггерная кнопка Translator 
(Транслятор) маркирована литерой [X], вследствие этого данный элемент списка 
трансляторов отображается в блоке диалога Override Options (Параметры 
переопределения).
<br>Чтобы возвратиться к блоку диалога Transfer (Переход), нажмите Esc.
Предположим, вы хотите скомпилировать модуль MYFUNCS при помощи компилятора 
командной строки системы Borland C++ (с именем BCC.EXE), а не компилятора 
интегрированной среды BC.EXE.
<br>Чтобы сделать это, необходимо выполнить следующие действия:
<ol><li>Необходимо описать программу BCC как один из трансляторов файлов проекта в блоке диалога Transfer (Переход).
<br>Переведите курсор на первую свободную строку за 
последним элементом спискаProgram Titles (Заголовки программ) и нажмите Enter, 
чтобы отобразить на экране блоки диалога Modify/New Transfer Item (Элемент списка переходов: Модифицировать/Новый).
<br>В блоке ввода Program Title (Заголовок программы) введите Borland C++ Command-Line Compiler (Компилятор командной 
строки системы Borland C++); в блоке ввода Program Path (Маршрутное имя 
программы) введите BCC; в командной строке введите $EDNAME.
<p><li>Маркируйте кнопку Translator (Транслятор) нажатием пробела и Enter (стандартной кнопкой действия является кнопка New (Новый)).
<br>Вернувшись в блок диалога Transfer 
(Переход), увидите, что строка Borland C++ Command-Line (слово Compiler не 
отображается) присутствует теперь в блоке списка Program Titles (Заголовки программ).
<br>С помощью клавиши табуляции переместитесь к кнопке OK (Выполнить) и нажмите Enter.
<p><li>Вернувшись в окно Project (Проект), нажмите комбинацию клавиш Ctrl+O, чтобы 
перейти к блоку диалога Override Options (Параметры переопределения).
<br>Строка Borland C++ Command-Line Compiler (Компилятор командной строки системы Borland 
C++) теперь является одним из вариантов выбора в списке Project File Translators 
(Трансляторы файлов проекта) для файла MYFUNCS.CPP (равно как и для всех других файлов).
<p><li>С помощью клавиши табуляции переместитесь к блоку списка Project File Translators 
(Трансляторы файлов проекта) и выделите световым маркером строку Borland C++ 
Command-Line Compiler (Компилятор командной строки системы Borland C++) (нажатие 
Enter или табуляционное перемещение к другой группе клавиш приводит в этот момент к выбору данного элемента).
<br>Воспользуйтесь блоком ввода Command-Line Options 
(Параметры командной строки), чтобы добавить необходимые параметры командной 
строки, которые должны передаваться программе BCC при компиляции файла MYFUNCS.CPP.</ol>
<p>Теперь компиляция файла MYFUNCS.CPP происходит при помощи программы BCC.EXE 
в то время, как все прочие исходные модули компилируются посредством программы BC.EXE.
<br>При принятии решения о необходимости рекомпиляции данного модуля во 
время выполнения процесса избирательной рекомпиляции менеджер проектов будет 
применять к программе MYFUNCS.CPP те же самые критерии, что и ко всем модулям, которые компилируются с помощью программы BC.EXE.
<p>&nbsp;</p><a name="09"></a>
<p><b><i><center>Переопределение библиотек</center></i></b>
<p>В некоторых случаях бывает необходимо переопределить стандартные файлы запуска или 
стандартные библиотеки.
<br>Можно переопределить файл запуска (startup file), если 
поместите файл с именем C0&lt;x>.OBJ в качестве ПЕРВОГО имени в файле проекта; литера 
&lt;x> означает любое допустимое в DOS имя (например, C0MINE.OBJ). Существенно, 
чтобы имя начиналось с символов C0, чтобы данное имя файла было первым именем в 
используемом проекте, и чтобы для этого файла было явно задано расширение имени 
файла *.OBJ.
<p>Для переопределения стандартной библиотеки необходимо занести имя специальной 
библиотеки в какое-либо место списка имен в окне Project (Проект). Имя этой библиотеки 
должно начинаться с литеры C, за которой следует литера, представляющая модель 
памяти (например, S для малой модели памяти); оставшиеся символы (их общее число не 
должно превышать шести) могут быть произвольными. Должно использоваться явно 
задаваемое расширение имени *.LIB (например, CSMYFILE.LIB или CSNEW.LIB).
<p>Когда осуществляется переопределение стандартной библиотеки, утилита MAKE не будет 
предпринимать попытки прикомпоновать математические библиотеки (базирующиеся на 
значении параметра Floating Point (Математика плавающей точки) в блоке диалога 
Advanced CodeGeneration (Генерация специализированного кода) из меню 
Options\Compiler (Параметры\Компилятор)). Если необходимо, чтобы при 
переопределении стандартной библиотеки осуществлялось прикомпоновывание этих 
библиотек, надо включить их в проект явным образом.
<p>&nbsp;</p><a name="10"></a>
<p><b><i><center>Добавление файлов в проект</center></i></b>
<p>Для примера расширим программу MYMAIN.CPP, чтобы включить в нее вызов функции с именем GetMyTime:
<pre>
	#include&lt;stdio.h>
	#include "myfuncs.h"
	#include "mytime.h"
	main (int argc, char *argv[])
	{	char *s;
		if (argc > 1)	s = argv[1];
		else		s = " вселенной";
		printf("%s %s открыт в %d.\n", GetString(), s, GetMyTime(HOUR));
	}
</pre>
<p>К файлу MYMAIN добавляются два включаемых файла: myfuncs.h и mytime.h. Эти файлы 
содержат прототипы, которые описывают функции GetString и GetMyTime, вызываемые 
из программы MYMAIN.
<p>Файл myfuncs.h содержит:
<pre>
		extern char *GetString(void);
</pre>
<p>Файл mytime.h содержит:
<pre>
		#define HOUR	1
		#define MINUTE	2
		#define SECOND	3
		extern int GetMyTime(int);
</pre>
<p>Запишем фактический код для функции GetMyTime в новый исходный файл с именем MYTIME.CPP:
<pre>
	#include&lt;time.h>
	#include "mytime.h"
	int GetMyTime(int which)
	{	struct tm *timeptr;
		time_t secsnow;
		time(&secsnow);
		timeptr = localtime(&secsnow);
		switch (which)
		{	case HOUR:	return (timeptr -> tm_hour);
			case MINUTE:	return (timeptr -> tm_min);
			case SECOND:	return (timeptr -> tm_sec);
		}
	}
</pre>
<p>Файл MYTIME включает в себя стандартный файл заголовка time.h, который содержит 
прототип функций time и localtime, а также описание идентификаторов tm и time_t. Он 
также включает в себя файл mytime.h в целях описания идентификаторов HOUR, MINUTE 
и SECOND.
<p>Откроем файл проекта MYPROG.PRJ (Project\OpenProject (Проект\Открыть проект)). 
<br>Файлы с именами MYMAIN.CPP и MYFUNCS.CPP уже находятся в окне Project (Проект). 
<br>Теперь в окно Project (Проект) необходимо добавить имя файла MYTIME.CPP вместе с 
его маршрутным именем (команда Project\Add Item (Проект\Добавить элемент)).
<p>Нажмите F9, чтобы осуществить избирательную компиляцию проекта.
<br>Файл  MYMAIN.CPP будет рекомпилирован, поскольку в него внесли с момента последней компиляции изменения.
<br>Файл MYFUNCS.CPP рекомпилироваться не будет, поскольку с момента проведения избирательной рекомпиляции в предыдущем примере в него не вносились никакие изменения.
<br>Файл MYTIME.CPP будет компилироваться впервые.
<p>&nbsp;</p><a name="11"></a>
<p><b><i><center>Просмотр файлов, включенных в проект</center></i></b>
<p>Чтобы отобразить блок диалога Include Files (Включаемые файлы), необходимо в окне 
проекта MYPROG переместить маркер к файлу MYMAIN.CPP и нажать пробел (или 
выбрать команду Project\Include Files (Проект\Включаемые файлы)).
<br>Этот блок диалога содержит имя выбранного файла, несколько кнопок и перечень включаемых файлов и мест их расположения (маршрутных имен).
<br>Первый файл в блоке списка Include Files (Включаемые файлы) будет выделен световым маркером; блок списка содержит перечень 
всех файлов, которые были включены в файл MYMAIN.CPP.
<br>Если какой-либо из включаемых файлов расположен вне текущей директории, то маршрутное имя данного 
файла будет отображено в поле Location (Местоположение) этого блока списка.
<p>По мере компиляции каждого из исходных файлов информация о том, какие включаемые 
файлы включены в конкретные исходные файлы, будет заноситься в создаваемый из исходного файла объектный файл.
<br>Если обращаетесь к блоку диалога Include Files (Включаемые файлы) до того, как проводите избирательную компиляцию, он может не 
содержать ни одного файла или может содержать имена файлов, которые остались от предыдущей компиляции.
<p>Чтобы загрузить один из включаемых в проект файлов в окно редактирования, 
необходимо выделить маркером имя требуемого файла и нажать клавишу Enter (или 
подвести указатель мыши к кнопке View (Просмотреть) и нажать кнопку мыши).
<br>Давайте взглянем на файл MYMAIN.CPP, один из файлов, которые входят в проект. Теперь можно 
вносить в этот файл изменения, осуществлять в нем прокрутку, производить поиск текста и выполнять другие необходимые действия.
<br>После реализации всех необходимых действий сохраните внесенные изменения F2, а затем нажмите комбинацию клавиш Alt+F3, чтобы закрыть окно редактирования.
<p>Предположим, что после просмотра файла MYMAIN.CPP вы поняли, что в 
действительности хотели просмотреть файл mytime.h, один из тех файлов, которые включены в файл MYMAIN.CPP.
<br>Установите на файле MYMAIN.CPP в окне Project 
(Проект) световой маркер, нажмите клавишу пробела, чтобы отобразить на экране блок 
диалога Include Files (Включаемые файлы) для файла MYMAIN. (Если файл 
MYMAIN.CPP находится в активном окне редактирования, то в качестве альтернативы 
можно выбрать команду Project\Include Items (Проект\Включаемые элементы) или нажать комбинацию клавиш Alt+P I).
<br>Теперь выберите в блоке Include Files (Включаемые файлы) 
имя файла mytime.h и кнопку действия View (Просмотреть). В результате на экране 
появится окно редактирования, в котором будет загружен файл MYTIME.H.
<p>&nbsp;</p><a name="12"></a>
<p><b><i><center>Пометки, относящиеся к проекту</center></i></b>
<p>Выберите команду Window\Project Notes (Окно\Пометки к проекту). В результате выбора 
этой команды на экран будет выдано новое окно редактирования, информация в котором 
хранится как часть вашего файла проекта. Введите в него, например, следующую 
информацию:
<blockquote>
Изменить историю:
<blockquote>
Чак Дж. Добавленный чек для сообщения Out of Memory (нехватка памяти) в DBADDFIELD.
<p>Гарри Б. Исправленная ошибка 0183.
</blockquote>
</blockquote>
<p>Каждый проект поддерживается своим собственным файлом примечаний, поэтому можно 
хранить примечания, относящиеся к проекту, над которым в настоящий момент работаете. 
Как только вы выбираете какой-либо файл проекта, можете обратиться к этим примечаниям.
<p>&nbsp;</p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp;</td></tr>
</table>
<a name=#end></a>
</body>
</html>