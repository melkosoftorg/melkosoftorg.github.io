<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | Лекция № 03</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp;</td></tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr><td class=usual>
<p align=center class=dbi><br>Options - меню параметров
<br>Вызов: Alt + O</p><p>&nbsp;</p>
<p><b><center>Команда Debugger (Отладчик)</center></b></p>
<p>Команда Options\Debugger (Параметры\Отладчик) позволяет задать значения нескольких 
параметров, которые определяют работу отладчика интегрированной среды. Данная команда 
открывает блок диалога.
<p><b><i>Source Debugging (Отладка на уровне исходного кода)</i></b>
<blockquote>
(.) On (Задана)
<br>( ) Standalone (Для самостоятельного отладчика)
<br>( ) None (Не задана)
</blockquote>
<p>Селективные кнопки Source Debugging (Отладка на уровне исходного кода) определяют, будет ли в 
выполняемый файл вноситься отладочная информация, и как EXE-файл будет выполняться под 
управлением системы Borland C++.
<br>Те программы, при компоновке которых данный параметр 
устанавливался в состояние <b><i>On</i></b> (Используется - установлено по умолчанию), могут отлаживаться 
как с помощью отладчика интегрированной среды, так и с помощью самостоятельного отладчика 
Borland Debugger. Если собираетесь производить отладку с помощью интегрированной среды, 
установите данный параметр в состояние On.
<br>Если данный параметр устанавливается в состояние <b><i>Standalone</i></b> (Для самостоятельного отладчика), 
то программы могут отлаживаться только с помощью отладчика Borland Debugger, хотя по-
прежнему можно выполнять эту программу в среде Borland C++.
<br>Если данный параметр устанавливается в состояние <b><i>None</i></b> (Не задана), то ни один из отладчиков не 
может использоваться для отладки программы, поскольку в EXE файл не будет занесена отладочная 
информация.
<p><b><i>Display Swapping (Своппинг дисплейного кадра)</i></b>
<blockquote>
( ) None (Отсутствует)
<br>(.) Smart (Интеллектуальный)
<br>( ) Always (Всегда)
</blockquote>
<p>Селективные кнопки Display Swapping (Своппинг дисплейного кадра) позволяют определять, когда 
отладчик интегрированной среды будет при выполнении программы осуществлять обновление 
дисплейных окон.
<br><b><i>None</i></b> (Отсутствует) - отладчик никогда не будет выполнять своппинг экранных кадров. Это 
значение параметра следует использовать для отладки только тех частей кода, которые 
гарантированно не выводят на экран никаких данных.
<br><b><i>Smart</i></b> (Интеллектуальный) - отладчик анализирует выполняемый код, чтобы выяснить, будет ли этот 
код отображать информацию на экране. Если этот код осуществляет выдачу на экран каких-либо 
данных (или производит вызов некоторой функции), то производится замена (своппинг) экранного 
кадра интегрированной среды на экранный кадр пользовательской программы на время, 
достаточное для отображения выводимых программой данных, после чего осуществляется обратная 
смена кадров. В противном случае своппинг не выполняется.
<p><table align=center width=95% border=1 cellpadding=5 cellspacing=10>
<tr><td class=rule>
<b>Важное замечание:</b> 
При реализации своппинга в режиме Smart (Интеллектуальный) следует 
учитывать следующие обстоятельства:
<ul><li>своппинг выполняется при вызове любой функции, даже если эта функция ничего не выводит 
на экран;
<li>в некоторых ситуациях экранный кадр интегрированной среды может быть модифицирован 
без своппинга; например, если запись на экран производится подпрограммой обработки 
прерывания таймера.</ul>
</td></tr></table>
<br><b><i>Always</i></b> (Всегда) - отладчик осуществляет своппинг экранных кадров всякий раз, когда выполняется 
какой-либо оператор. Это значение параметра следует выбирать в тех случаях, когда имеется 
вероятность затирания экранного кадра интегрированной среды данными выполняющейся 
программы.
<p><table align=center width=95% border=1 cellpadding=5 cellspacing=10>
<tr><td class=rule>
<b>Важное замечание:</b> 
Если отладка ведется в режиме двух мониторов (то есть, если 
используется параметр /d командной строки системы Borland C++), то выводимые 
программой данные можно отображать на одном мониторе, а экранный кадр системы 
Borland C++ на другом). В этом случае система Borland C++ никогда не осуществляет 
своппинг экранных кадров и значение параметра Display Swapping (Своппинг дисплейного 
кадра) не имеет никакого значения.
</td></tr></table>
<p><b><i>Inspectors (Инспекция)</i></b>
<blockquote>
[X] Show inherited (Отображать наследуемые)
<br>[X] Show methods (Отображать методы) 
<br><br>( ) Show decimal (Отображать в десятичном формате)
<br>( ) Show hex (Отображать в шестнадцатеричном формате)
<br>(.) Show both (Отображать в обоих форматах)
</blockquote>
<p>Если в группе триггерных кнопок Inspectors (Инспекция) промаркирована кнопка <b><i>Show inherited</i></b> 
(Отображать наследуемые), то интегрированный отладчик получает указание отображать все 
функции компонентов и методы - вне зависимости от того, описаны они в инспектируемом классе 
или унаследованы из базового класса. Когда данная кнопка не маркирована, отображаются только те 
поля, которые описаны в типе инспектируемого объекта.
<br>Если промаркирована кнопка <b><i>Show methods</i></b> (Отображать методы), интегрированный отладчик 
получает указание при инспектировании класса отобразить функции компонентов.
<br>Если необходимо определить, в каком формате будут отображаться значения в окнах инспекции, 
необходимо промаркировать селективную кнопку <b><i>Show decimal</i></b> (Отображать в десятичном 
формате), <b><i>Show hex</i></b> (Отображать в шестнадцатеричном формате) или <b><i>Show both</i></b> (Отображать в 
обоих форматах).
<br>По умолчанию используется параметр <b><i>Show both</i></b> (Отображать в обоих форматах).
<p><b><i>Program Heap Size (Размер "кучи" (пула хип-памяти) программы)</i></b>
<blockquote>
64 K bytes (64 Кбайт)
</blockquote>
<p>Блок ввода Program Heap Size (Размер "кучи" (пула хип-памяти) программы) можно использовать 
для ввода значения объема памяти, которая будет отводиться программе системой Borland C++ при 
отладке.
<br>Фактический объем памяти, который система Borland C++ пытается предоставить 
программе, равен размеру выполняемой программы плюс объем, заданный в этой строке.
<p><table align=center width=95% border=1 cellpadding=5 cellspacing=10>
<tr><td class=rule>
<b>Важное замечание:</b> 
Увеличение размера пула хип-памяти имеет смысл только при работе с 
большими моделями памяти.
</td></tr></table>
<p>По умолчанию размер пула хип-памяти, выделяемой программе, равняется 64 Кбайтам. Если в 
программе память для объектов выделяется динамически, может потребоваться увеличение этого 
значения.
<p>&nbsp;</p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp;</td></tr>
</table>
<a name=#end></a>
</body>
</html>
