<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | Лекция № 43</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=a>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<!--tr><td class=rule>
Внимание!
<ol>В окнах такого цвета будут отображаться правила и примечания относительно 
лекционного материала
</ol></td></tr-->
<tr>
<td class=usual>
<p align=center class=dbi><br>Указатели на компоненты класса</p>
Две специфичные операции языка C++ <b>.*</b> и <b>-></b>* 
предназначены для работы с указателями на компоненты класса. <p>Указатель на компонент 
класса не является обычным указателем, унаследованным языком C++ от языка Си. 
<br>Обыкновенный указатель предназначен для адресации того или иного объекта (участка 
памяти) программы. <br>Указатель на компонент класса не может адресовать никакого 
участка памяти, так как память выделяется не классу, а объектам этого класса при их 
создании. <p>Таким образом, указатель на компонент класса при определении не адресует 
никакого конкретного объекта. <br>Компоненты класса делятся на две группы:<ul>
<li>компоненты - данные,
<li>компоненты - функции.</ul>
<p><b><i>Указатели на компоненты класса по-разному определяются для данных и функций 
(методов) класса.</i></b> <br>Рассмотрим определение класса "комплексное число".
<pre>
	#include&lt;iostream.h&gt;
	struct complex		// Класс с конструктором и инкапсуляцией данных:
	{	// Методы класса (все общедоступные - public):
		complex (double re = 1.0, double im = 0.0)	// Конструктор объектов класса
		{ real = re; imag = im; }
		void display(void)		// Вывести на дисплей значение комплексного числа:
		{	cout << "real = " << real;
			cout << ", imag = " << imag;
		}
		double &re(void) { return real; }	// Получить доступ к вещественной части
		double &im(void) { return imag; }	// Получить доступ к мнимой части числа
		// Данные класса (скрыты от прямых внешних обращений):
		private:				// Изменить статус доступа на "собственный"
			double real;		// Вещественная часть
			double imag;		// Мнимая часть
	};
</pre>
<p><b><center>Указатели на принадлежащие классу функции</center></b>
<p>Их определение имеет формат:
<p><center>тип_возвращаемого_функцией_значения (имя_класса <b>::</b> *имя_укаэателя_на_метод)
(спецификация_параметров_функции);</center>
<br>Например, в классе complex определены методы (компонентные функции) <br><center>double& re(), 
double& im().</center>
<br>Вне класса можно описать указатель 
<br><center>ptCom:double& (complex <b>::</b> *ptCom) ();</center>
<br>Описав указатель ptCom на компонентные функции класса complex, можно почти 
обычным образом задать его значение:<br><center>ptCom = &complex <b>::</b> re; &nbsp; &nbsp; // "Настройка" указателя</center>
<br>Теперь для любого объекта A класса complex
<br><center>complex A (10.0, 2.4); &nbsp; &nbsp; // Определение объекта A</center>
можно вызвать принадлежащую классу функцию re():
<br><center>(A.*ptCom)() = 11.1; &nbsp; &nbsp; // Изменится вещественная часть A</center>
<br><center>cout << (A.*ptCom)(); &nbsp; &nbsp; // Вывод на печать A.real</center>
<br>Изменив значение указателя<br><center>ptCom = &complex <b>::</b> im; &nbsp; &nbsp; // "Настройка" указателя</center>
<br>можно с его помощью вызывать другую функцию того же класса:
<br><center>cout << (A.*ptCom)(); &nbsp; &nbsp; // Вывод значения мнимой части A</center>
<br><center>complex B = A; &nbsp; &nbsp; // Определение нового объекта B</center>
<br><center>(B.*ptCom) += 3.0; &nbsp; &nbsp; // Изменение значения мнимой части B</center>
<p>В примерах определен и использован указатель на компонентную функцию без 
параметров, возвращающую значение типа double&. Его не удастся настроить на 
принадлежащие классу complex функции с другой сигнатурой и другим типом 
возвращаемого значения. Для обращения к компонентной функции display(), указатель 
ptDisp нужно ввести следующим образом:<br><center>void (complex <b>::</b> *ptDisp)(void);</center>
Настроив указатель ptDisp на вещественную функцию display() класса complex, можно 
вызвать эту функцию для любого объекта этого класса:
<pre>
	ptDisp = &complex <b>::</b> display;	// "Настройка" указателя
	B.*ptDisp();		// Вызов функции display() для объекта В
</pre>
<p><b><center>Указатели на компонентные данные класса</center></b>
<p>Их определение имеет формат:
<p><center>тип_данных (имя_класса <b>::</b> *имя_указателя);</center>
<br>В определение указателя можно включить его явную инициализацию, используя адрес 
компонента: <p><center>&имя_класса <b>::</b> имя_компонента</center>
<br>При этом компонент класса должен быть общедоступным (public). <br>Например, попытка 
определить и использовать указатель на длину строки (компонент int len) класса stroka:
int(stroka <b>::</b> *plen) = &stroka <b>::</b> len;
окажется неверной, так как компонент len класса stroka по умолчанию имеет атрибут 
private.
<p>Указатель на компонент класса можно использовать в качестве фактического параметра 
при вызове функции.
<br>В приведенных примерах мы использовали операцию <b>.*</b> разыменования указателей на 
компоненты класса:<br><center>имя_объекта<b>.*</b>указатель_на_компонент_данных</center>
<br><center>имя_объекта<b>.*</b>укаэатель_на_метод(параметры)</center>
<br>Слева от операции <b>.*</b> кроме имени конкретного объекта может помещаться ссылка на 
объект.
<p>Если определен указатель на объект класса и введены указатели на компоненты того же 
класса, то доступ к компонентам конкретных объектов можно получить с помощью 
бинарной операции <b>->*</b> на объект доступа к компонентам класса через указатель:
<br><center>указатель_на_объект_класса <b>-> *</b>указатель_на_компонент_данных</center>
<br><center>указатель_на_объект_класса <b>-> *</b>указатель_на_метод(параметры)</center>
<br>Первым (левым) операндом должен быть указатель на объект класса, значение которого - 
адрес объекта класса. <br>Второй (правый) операнд - указатель на компонент класса. 
<br>Результат выполнения операции <b>->*</b> - это либо компонент данных, либо компонентная 
функция класса. <p>Если второй операнд - это леводопустимый компонент данных, то и 
результат применения операции <b>->*</b> (а также операции <b>.*</b> ) есть l-значение. <br>Например, 
определим и инициализируем указатель рсml на компонент данных класса complex:
<p><center>double (complex <b>::</b> *pcml) = &complex <b>::</b> real;</center>
<br>Определим и инициализируем указатель pcomplex на объекты класса complex:
<p><center>complex CM(10.2, -6.4); complex *pcomplex = &CM;</center>
<br>Теперь, применяя операцию <b>->*</b> , получим l-значение: pcomplex <b>->*</b> pcml = 22.2;
<p>Приведенный оператор присваивания изменяет значение вещественной части 
комплексного числа, представленного объектом CM класса complex. Если справа от 
операции <b>->*</b> находится инициализированный указатель на компонентную функцию для 
того объекта, на который "настроен" левый операнд, то выполнится обращение к 
соответствующему методу:
<pre>
	complex A(22.2, 33.3);		// Объект класса 
	complex *pComplex = &A;		// Указатель класса
	void (complex <b>::</b> *pdisplay)();		// Указатель на компонентную функцию
	pdisplay = &complex <b>::</b> display;	// "Настройка" указателя
	// Вызов компонентной функции через указатель на объект класса
	// и указатель на компонентную функцию
	(pComplex <b>-></b> *pdisplay) ();
</pre>
<br>В данном примере на экран выводится сообщение: real = 22.2, imag = 33.3
<p> &nbsp; </p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=a>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>