<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | Лекция № 43</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=a>&nbsp 5 &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr>
<td class=usual>
<p align=center class=dbi><br>Указатель this</p>
Когда функция, принадлежащая классу, вызывается для обработки данных конкретного 
объекта, этой функции автоматически и неявно передается указатель на тот объект, для 
которого функция вызвана. Этот указатель имеет фиксированное имя this и незаметно для 
программиста определен в каждой функции класса следующим образом:
<p><center>имя_класса * const this = адрес_объекта;</center>
<br>Имя this является ключевым словом. Явно описать или определить указатель this нельзя. В 
соответствии с неявным определением this является константным указателем, то есть 
изменять его нельзя, однако в каждой принадлежащей классу функции он указывает 
именно на тот объект, для которого функция вызывается. <p>Указатель this является 
дополнительным (скрытым) параметром каждой нестатической компонентной функции. 
<p>При входе в тело принадлежащей классу функции указатель this инициализируется 
значением адреса того объекта, для которого вызвана функция. Объект, который 
адресуется указателем this, становится доступным внутри принадлежащей классу 
функции именно с помощью указателя this. При работе с компонентами класса внутри 
принадлежащей классу функции можно было бы везде использовать этот указатель.
<br>Например, совершенно правильным будет такое определение класса:
<pre>
	struct ss
	{	int si; char sc;
		ss(int in, char cn)	// Конструктор объектов класса
		{ this <b>-></b> si = in; this <b>-></b> sc = cn; }
		// Функция вывода сведений об объекте
		void print(void)
		{	cout << "\n si = " << this <b>-></b> si;
			cout << "\n sc = " << this <b>-></b> sc;
		}
	};
</pre>
<br>В таком использовании указателя this нет никаких преимуществ, так как данные конкретных объектов 
доступны в принадлежащих классу функциях и с помощью имен данных класса.
<p>В следующей программе демонстрируется явное использование указателя this, чтобы напечатеть 
закрытую переменную x объекта Test.
<br>В программе иллюстрируется, как можно напечатать значение x непосредственно, а также две различных записи для доступа к переменной посредством указателя this.
<pre>
	#include&lt;conio.h&gt;
	#include&lt;iostream.h&gt;
	class Test
	{	public:	Test (int = 0);		// Конструктор
			void print() const;
		private: int x;
	};
	Test <b>::</b> Test (int a) { x = a; }			// Конструктор
	void Test <b>::</b> print() const
	{	cout << "x = " << x << endl << "this <b>-></b> = " << this <b>-></b> x << endl
			<< "(*this)<b>.</b>x = " << (*this)<b>.</b>x << endl;
	}
	main()
	{
		Test a(12); clrscr();
		a<b>.</b>print(); getch(); return 0;
	}

	<b><i>Результаты выполнения программы:</i></b>	x = 12
						this <b>-></b> = 12
						(*this)<b>.</b>x = 12
</pre>
<br>Ниже в функции read.print(), которая является компонентом класса String, используется 
указатель this. В этом случае конструкции this <b>-></b> компонент и (* this)<b>.</b>компонент 
позволяют обращаться к компоненту класса String.
<pre>
	#include&lt;stdio.h&gt;
	#include&lt;conio.h&gt;
	#include&lt;string.h&gt;
	class String
	{	char str[100]; int k, *r;
		public:	String() { k = 123; r = &k; }
			void read() { gets(str); }
			void print() { puts(str); }
			void read_print();
	};
	void String <b>::</b> read_print()
	{	char c;
		printf("k = %d\n", this <b>-></b> k);
		printf("*r = %d\n", *(this <b>-></b> r));
		puts("Введите строку");
		// Ключевое слова this содержит скрытый указатель на класс String
		// Поэтому конструкция this <b>-></b> read выбирает
		// (через указатель) функции read класса
		this <b>-></b> read(); puts("Введенная строка");
		this <b>-></b> print();		// аналогичная конструкция для функции print
		// В цикле одинаково удаленные от середины строки символы
		// меняются местами
		for(int i = 0, j = strlen(str)-1; i < j; i++, j--)
		{
			c = str[i]; str[i] = str[j]; str[j] = c; 
		}
		puts("Измененная строка"); 
		(*this).print();		// можно использовать и такую конструкцию
	}
	void main()
	{	String s; clrscr();
		s.read_print();		// обращение к функции read_print
		getch();
	}

	<b><i>Результаты работы программы:</i></b>	k = 123
					*r= 123
					Введите строку 1234567890 <Enter>
					Введенная строка 1234567890
					Измененная строка 0987654321
</pre>
<br>Очень удобным указатель this становится в тех случаях, когда в теле принадлежащей 
классу функции нужно явно задать адрес того объекта, для которого она вызвана, 
например, если в классе нужна функция, помещающая адрес выбранного объекта класса в 
массив или включающая конкретный объект класса в список. При организации связных 
списков, звеньями которых должны быть объекты класса, необходимо включать в связи 
звеньев указатель именно на тот объект, который в данный момент обрабатывается. Это 
включение должна выполнить функция - компонент класса. Однако имя включаемого 
объекта в момент написания принадлежащей классу функции недоступно, поскольку его 
позже произвольно выбирает программист, используя класс как тип данных. Можно 
передавать такой функции ссылку или указатель на нужный объект, но гораздо проще 
использовать указатель this. Когда указатель this использован в функции, принадлежащей 
классу, например с именем ZOB, то он имеет по умолчанию тип ZOB * const и всегда 
равен адресу того объекта, для которого вызвана компонентная функция. Если в 
программе для некоторого класса х определить объект Х factor(5); то при вызове 
конструктора класса х, создающего объект factor, значением указателя this будет &factor.
<p>Рассмотрим в качестве примера класс, объекты которого формируют двухсвязный список. 
Определим состав класса и опишем свойства его компонентов:
<pre>
	// MEMBER.Н - "элементы двухсвязного списка"
	class member
	{	static member *last_memb;	// Адрес последнего элемента списка:
		member *prev;		// На предыдущий элемент списка
		member *next;		// На следующий элемент списка
		char bukva;		// Содержимое (значение) элемента списка
		public:			// Функции для работы со списком:
			member (char cc) { bukva = cc; } // Конструктор
			void add(void);		// Добавление элемента в конец списка
			static void reprint(void);	// Вывод на дисплей содержимого списка:
	};
</pre>
<br>Из объектов класса member, как из звеньев, может формироваться двухсвязный список. В 
классе member имеется статический компонент-указатель last_memb на последний объект, 
уже включенный в список. <br>Когда список пуст, значение last_memb должно быть равно 
нулевому указателю NULL. <br>Связь между объектами как звеньями списка организуется с 
помощью last_memb == NULL.
<br>Выполняет "подключение" объекта к списку компонентная функция add().
<br>Статическая функция reprint() позволяет "перебрать" звенья списка (объекта класса 
member) в порядке от конца к началу и вывести символы ("содержания") объектов на 
экран.
<br>Конструктор инициализирует компонент char bukva каждого создаваемого объекта.
<pre>
	// MEMBER.CPP - определения компонентных функций класса member
	#include&lt;iostream.h&gt;
	#include&lt;stdio.h&gt;		// Для описания нулевого указателя NULL
	#include "member.h"
	void member <b>::</b> add(void)	// Добавление элемента в конец списка
	{	if (last_memb == NULL)
			this <b>-></b> prev = NULL;
		else
			{ last_memb <b>-></b> next = this; prev = last_memb; }
		last_memb = this; this <b>-></b> next = NULL;
	}
	void member <b>::</b> reprint(void)	// Вывод на дисплей содержимого списка;
	{	member *uk;	// Вспомогательный указатель
		uk = last_memb;
		if (uk == NULL)
			{ cout << "\nСписок пуст!"; return; }
		else
			cout << "\nСодержимое списка: ";
		//печать в обратном порядке значений элементов списка
		while (uk != NULL)
		{	cout << uk <b>-></b> bukva << '\t'; 
			uk = uk <b>-></b> prev;
		}
	}
</pre>
<br>Вне класса указатель last_memb до включения в список первого элемента 
инициализируется нулевым значением (NULL). Поэтому первым шагом выполнения 
функции add будет проверка значения last_memb. Если он равен нулю, то в список 
включается первый элемент (объект), для которого указатель prev на предшествующий 
элемент должен быть нулевым. Для подключения объекта к уже существующему списку 
необходимо указателю next последнего в списке объекта присвоить значение указателя 
this (адрес добавляемого объекта). В качестве указателя на своего предшественника (prev) 
подключаемый объект получает значение last_memb. Затем последним становится 
обрабатываемый (только что подключенный) объект (last_memb = this;) и обнуляется его 
указатель next на последующий объект в списке.
<p>Компонентная функция reprint () описана в классе как статическая, что никак не 
сказывается на ее определении. Первое действие функции - "настройка" вспомогательного 
указателя uk на последний включенный в список объект. Его адрес всегда является 
значением указателя last_memb. Если список пуст, то на этом выполнение функции 
завершается. В противном случае в цикле печатаются значения uk <b>-></b> bukva и указатель 
"перемещается" к предыдущему звену списка.
<p>В следующей программе инициализирован статический указатель last_memb, создаются 
объекты класса member, объединяются компонентной функцией add() в двухсвязный 
список, и этот список выводится на экран дисплея с помощью статической функции 
reprint().
<pre>
	#include&lt;iostream.h&gt;		// статические компоненты, указатель this
	#include&lt;conio.h&gt;
	#include "member.cpp"
	member *member <b>::</b> last_memb = NULL; // Инициализация статического компонента
	void main()
	{	// Формирование объектов класса member:
		member A('a'); member B('b'); member C('c'); member D('d'); clrscr();
		member <b>::</b> reprint();		// Вызов статической компонентной функции
		A.add(); B.add(); C.add(); D.add();	// Включение объектов в двусвязный список
		// Печать в обратном порядке значений элементов списка
		member <b>::</b> reprint();
		getch();
	}

	<b><i>Результат выполнения программы:</i></b>	Список пуст!
						Содержимое списка: d с b a
</pre>
<br>Все компонентные данные класса member имеют статус собственных (private). Они недоступны из других частей программы. Доступ к классу обеспечивают только компонентные функции, имеющие статус public.
<p> &nbsp; </p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=a>&nbsp 5 &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>