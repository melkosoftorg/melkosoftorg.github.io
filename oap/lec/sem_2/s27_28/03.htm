<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>ОП | СР 27_28</title>
<link rel="stylesheet" type="text/css" href="03_files/lec.css">
</head>
<body>
<a name="#start"></a>
<table class="pages" align="center" border="0" cellpadding="0" cellspacing="0">
<tbody><tr colspan="5">
<td>&nbsp;&nbsp;<a href="http://prep.scc/%7Eblp/uch/op/plan_2.htm" class="p">Календарно-тематический план</a>&nbsp;&nbsp;</td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s27_28/index.htm" class="p">&nbsp; План лекции &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s27_28/01.htm" class="p">&nbsp; 1 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s27_28/02.htm" class="p">&nbsp; 2 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s27_28/03.htm" class="a">&nbsp; 3 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s27_28/04.htm" class="p">&nbsp; 4 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s27_28/05.htm" class="p">&nbsp; 5 &nbsp;</a></td>
</tr>
</tbody></table>
<!-- -------Inside table------- -->
<table border="0" cellpadding="5" cellspacing="0" width="98%">
<tbody><tr><td class="usual">
<p class="dbi" align="center"><br>Работа со связанными списками</p>
<p>Со связанными списками можно проделывать такие манипуляции, как
</p><ul><li>добавление,
</li><li>удаление,
</li><li>изменение элементов списка.
</li></ul>
<p>Изменение элементов не представляет собой ничего особенного, а вот их добавление и удаление - далеко не тривиальные операции.
</p><p>Элементы списка связаны между собой через указатели. Большая 
часть работы по добавлению и удалению элементов состоит в 
манипулировании этими указателями. Элементы можно добавлять в начало, 
середину или конец списка. От этого зависит способ изменения указателей.
</p><p>Рассмотрим общие подходы к некоторым операциям со связанными 
списками. При этом будем использовать ту же структуру person, что и в 
предыдущих примерах.
</p><p align="center"><b>Предварительная подготовка</b></p>
<p>Прежде чем организовывать связанный список, необходимо определить 
структуру данных для этого списка и объявить начальный указатель. 
Поскольку список создается пустым, его начальный указатель следует 
инициализировать значением NULL. Нужен также еще один указатель на ту же
 структуру, чтобы с его помощью добавлять элементы в список.
</p><p>В итоге получается следующий код:
</p><pre>			struct person
			{
				char name[20];
				struct person *Next;
			};
			struct person *New;
			struct person *Head;
			Head = NULL;
</pre>
<p align="center"><b>Добавление элемента в начало списка</b></p>
<p>Если начальный указатель равен NULL, то список пустой, и новый 
элемент станет его единственным членом. Если же начальный указатель не 
равен NULL, то список уже содержит один или несколько элементов. Тем не 
менее, в каждом из этих случаев процедура добавление элемента в начало 
списка остается одной и той же:
</p><ol>
<li>создать экземпляр структуры с выделением памяти для него функцией malloc(),
</li><li>установить указатель следующего узла в структуре нового элемента списка равным текущему значению начального указателя.
<br>Если список пустой, это будет NULL, в противном случае - адрес текущего первого элемента.
</li><li>установить начальный указатель равным адресу нового элемента.
</li></ol>
<p>Вот код, выполняющий эти задачи:
</p><pre>			New = (struct person*) malloc(sizeof(struct person));
			New -&gt; Next = Head;
			Head = New;
</pre>
<p>Обратите внимание на приведение типа перед функцией malloc() для 
корректного присваивания возвращаемого адреса указателю на структуру.
</p><p><table align="center" border="1" cellpadding="5" cellspacing="10" width="90%">
<tbody><tr><td class="rule">
<b>Внимание:</b> Очень важно изменять указатели в правильном порядке. Если первым изменить начальный указатель, то потеряется весь список!
</td></tr>
</tbody></table>
</p><p><b><i>Рисунок схематически демонстрирует процедуру добавления нового элемента в пустой список</i></b>
</p><p><table align="center" border="0" width="70%">
<tbody><tr valign="top"><td width="30%"><img src="03_files/image002.gif" alt="До первого добавления">
</td><td width="30%"><img src="03_files/image004.gif" alt="Добавляемые значения">
</td><td width="40%"><img src="03_files/image005.gif" alt="После добавления">
</td></tr>
<tr><td colspan="2" align="center"><i>Перед добавлением</i></td><td align="center"><i>После добавления</i>
</td></tr>
</tbody></table>
</p><p>Следующий <b><i>рисунок демонстрирует процедуру добавления нового элемента в непустой список</i></b>
</p><p><table align="center" border="0" width="70%">
<tbody><tr valign="top"><td width="15%"><img src="03_files/image004.gif" alt="Добавляемые значения">
</td><td width="30%"><img src="03_files/image006.gif" alt="До добавления">
</td></tr>
<tr><td colspan="2" align="center"><i>Перед добавлением</i>
</td></tr>
<tr><td colspan="2"><img src="03_files/image007.gif" alt="После добавления">
</td></tr>
<tr><td colspan="2" align="center"><i>После добавления</i>
</td></tr>
</tbody></table>
</p><p>Обратите внимание, что для распределения памяти под новый элемент используется функция malloc().
</p><p>По мере добавления новых элементов для них также выделяется память без размещения уже существующих заново.
</p><p>Для этой цели можно также использовать функцию calloc (). Следует
 знать важное различие между двумя функциями распределения памяти: 
calloc() инициализирует вновь созданный элемент, a malloc() этого не 
делает.
</p><p><table align="center" border="1" cellpadding="5" cellspacing="10" width="90%">
<tbody><tr><td class="rule">
<b>Совет:</b> Всегда инициализируйте указатели значением NULL при их 
объявлении. Не оставляйте указатели с неопределенными значениями - таким
 образом вы просто напрашиваетесь на ошибку.
</td></tr>
</tbody></table>
</p><p>&nbsp;
</p><p align="center"><b>Добавление элемента в конец списка</b></p>
<p>Для добавления элемента в конец списка следует сначала дойти от 
начального указателя до последнero элемента в списке. После нахождения 
последнего элемента следует выполнить следующие операции:
</p><ol>
<li>создать экземпляр структуры данных, распределив память с помощью функции malloc().
</li><li>установить указатель в текущем последнем элементе на добавляемый элемент (адрес которого возвратила функция malloc ()).
</li><li>установить указатель в добавленном элементе равным NULL, чтобы таким образом сделать его новым последним элементом списка.
</li></ol>
<p>Вот код для выполнения этих операций:
</p><pre>			person *current;
			...
			current = Head;
			while(current -&gt; Next != NULL)
				current = current -&gt; Next;
			New = (struct person*) malloc(sizeof(struct person));
			current -&gt; Next = New;
			New -&gt; Next = NULL;
</pre>
<p><b><i>На рисунке схематически показана процедура добавления нового элемента в конец связанного списка.</i></b>
</p><p><table align="center" border="0" width="70%">
<tbody><tr valign="top"><td width="30%"><img src="03_files/image006.gif" alt="До добавления">
</td><td width="15%"><img src="03_files/image004.gif" alt="Добавляемые значения">
</td></tr>
<tr><td colspan="2" align="center"><i>Перед добавлением</i>
</td></tr>
<tr><td colspan="2"><img src="03_files/image008.gif" alt="После добавления">
</td></tr>
<tr><td colspan="2" align="center"><i>После добавления</i>
</td></tr>
</tbody></table>
</p><p align="center"><b>Добавление элемента в середину списка</b></p>
<p>При работе со связанным списком в основном приходится добавлять 
элементы не в начало и не в конец, а куда-то в середину списка. Куда 
именно помещается новый элемент, зависит от назначения списка и способа 
его организации - например, от наличия сортировки по одному или 
нескольким полям данных.
</p><p>Поэтому вначале необходимо найти то место в списке, на которое нужно поместить новый элемент, а затем уже добавить сам элемент.
</p><p>Для этого следует выполнить такие операции:
</p><ol>
<li>найти существующий элемент в списке, после которого должен стоять новый элемент. Назовем его маркером.
</li><li>создать экземпляр структуры, выделив для него память с помощью функции malloc().
</li><li>установить указатель в маркере на новый элемент (адрес которого возвратила функция malloc()).
</li><li>установить указатель в новом элементе на тот элемент, на который перед этим указывал маркер.
</li></ol>
<p>Вот как может выглядеть соответствующий код:
</p><pre>			struct person *marker;
			// Сначала - поиск маркера в списке
			...
			New = (struct person*) malloc(sizeof(struct person));
			New -&gt; Next = marker-&gt;Next;
			marker -&gt; Next = New;
</pre>
<p><b><i>На рисунке этот процесс показан схематически.</i></b>
</p><p><table align="center" border="0" width="70%">
<tbody><tr valign="top"><td width="30%"><img src="03_files/image006.gif" alt="До добавления">
</td><td width="15%"><img src="03_files/image004.gif" alt="Добавляемые значения">
</td></tr>
<tr><td colspan="2" align="center"><i>Перед добавлением</i>
</td></tr>
<tr><td colspan="2"><img src="03_files/image009.gif" alt="После добавления">
</td></tr>
<tr><td colspan="2" align="center"><i>После добавления</i>
</td></tr>
</tbody></table>

</p><p align="center"><b>Удаление элемента из списка</b></p>
<p>Удаление элемента из списка представляет собой довольно простую 
задачу, связанную с манипулированием указателями. Эта операция зависит 
от того, в каком месте списка находится элемент.
</p><ul>
<li>Для удаления первого элемента сделайте начальный указатель равным адресу второго элемента списка.
</li><li>Для удаления последнего элемента сделайте указатель в предпоследнем элементе равным NULL.
</li><li>Для удаления любого другого элемента сделайте указатель в 
предшествующем ему элементе равным адресу элемента, следующего за 
удаляемым элементом.
</li></ul>
<p>Кроме того, память, занимаемую этим элементом, необходимо освободить,
 чтобы программа не тратила памяти больше, чем ей действительно 
необходимо (это называется утечкой памяти). Освобождение памяти 
выполняется функцией free().
</p><p>Вот как удаляется первый элемент из списка:
</p><pre>			free(Head);
			Head = Head -&gt; Next;
</pre>
<p>А этот фрагмент кода удаляет последний элемент из списка:
</p><pre>			struct person *current1, *current2;
			current1 = Head;
			current2 = current1 -&gt; Next;
			while(current2 -&gt; Next != NULL)
			{
				current1 = current2;
				current2 = current1 -&gt; Next;
			}
			free(current1 -&gt; Next);
			current1 -&gt; Next = NULL;
			if(Head = current1)
			Head = null;
</pre>
<p>Наконец, удаление элемента из середины списка выполняется таким образом:
</p><pre>			struct person *current1, *current2;
			// здесь идет код для установки указателя current1 на элемент
			// непосредственно перед удаляемым элементом
			current2 = current1 -&gt; Next;
			free(current1 -&gt; Next);
			current1 -&gt; Next = current2 -&gt; Next;
</pre>
<p>После выполнения любой из этих групп операторов без вызова функции 
free() удаленный элемент все еще существовал бы где-то в памяти, хотя в 
списке его уже не было бы, потому что ни один указатель из списка на 
него не указывал бы. В программе, предназначенной для реального 
практического применения, обязательно нужно освобождать память, 
занимаемую удаленным элементом. Для этого и нужна функция free ().
</p><p>&nbsp;
</p></td></tr>
</tbody></table>
<!-- -------End of Inside table------- -->
<table class="pages" align="center" border="0" cellpadding="0" cellspacing="0">
<tbody><tr colspan="5">
<td>&nbsp;&nbsp;<a href="http://prep.scc/%7Eblp/uch/op/plan_2.htm" class="p">Календарно-тематический план</a>&nbsp;&nbsp;</td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s27_28/index.htm" class="p">&nbsp; План лекции &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s27_28/01.htm" class="p">&nbsp; 1 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s27_28/02.htm" class="p">&nbsp; 2 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s27_28/03.htm" class="a">&nbsp; 3 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s27_28/04.htm" class="p">&nbsp; 4 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s27_28/05.htm" class="p">&nbsp; 5 &nbsp;</a></td>
</tr>
</tbody></table>
<a name="#end"></a>

</body></html>