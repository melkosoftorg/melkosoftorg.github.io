<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>ОП | СР 29_32</title>
<link rel="stylesheet" type="text/css" href="03_files/lec.css">
</head>

<body>
<a name="#start"></a>
<table class="pages" align="center" border="0" cellpadding="0" cellspacing="0">
<tbody><tr colspan="5">
<td>&nbsp;&nbsp;<a href="http://prep.scc/%7Eblp/uch/op/plan_2.htm" class="p">Календарно-тематический план</a>&nbsp;&nbsp;</td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s29_32/index.htm" class="p">&nbsp; План лекции &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s29_32/01.htm" class="p">&nbsp; 1 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s29_32/02.htm" class="p">&nbsp; 2 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s29_32/03.htm" class="a">&nbsp; 3 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s29_32/04.htm" class="p">&nbsp; 4 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s29_32/05.htm" class="p">&nbsp; 5 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s29_32/06.htm" class="p">&nbsp; 6 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s29_32/07.htm" class="p">&nbsp; 7 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s29_32/08.htm" class="p">&nbsp; 8 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s29_32/09.htm" class="p">&nbsp; 9 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s29_32/10.htm" class="p">&nbsp; 10 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s29_32/11.htm" class="p">&nbsp; 11 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s29_32/12.htm" class="p">&nbsp; 12 &nbsp;</a></td>
</tr>
</tbody></table>
<!-- -------Inside table------- -->
<table border="0" cellpadding="5" cellspacing="0" width="98%">
<tbody><tr><td class="usual"><p class="dbi" align="center"><br>Создание файла последовательного доступа</p>
<p>C++ не предписывает никакой структуры файлу. Таким образом, понятия, 
вроде запись, не существуют в файлах языка C++. Следовательно, 
программист должен задавать структуру файлов в соответствии с 
требованиями прикладных программ.
</p><p>В примере показано, каким образом программист может задавать простую структуру записей в файле.
<br>Программа создает простой файл последовательного доступа, который 
можно использовать в системе платежных счетов по кредиторской 
задолженности для помощи в управлении деньгами по этим счетам.
<b></b></p><pre><b>	// Создание последовательного файла
	#include &lt;iostream.h&gt;
	#include &lt;fstream.h&gt;
	#include &lt;stdlib.h&gt;
	main ( )
	{
		ofstream outClientFile("clients.dat", ios :: out);
		if (! outClientFile)
		{
			cerr &lt;&lt; "Файл не может быть открыт" &lt;&lt; endl;
			exit(1);
		}
		cout &lt;&lt; "Введите счет, имя и баланс." &lt;&lt; endl
			&lt;&lt; "Введите EOF для окончания ввода." &lt;&lt; endl &lt;&lt; "? ";
		int account; char name [10] ; float balance;
		while (cin &gt;&gt; account &gt;&gt; name &gt;&gt; balance)
		{
			outClientFile &lt;&lt; account &lt;&lt; ' ' &lt;&lt; name &lt;&lt; ' ' &lt;&lt; balance &lt;&lt; endl;
			cout &lt;&lt; "? ";
		}
		return 0;
	}
	
	<i>Результаты</i></b>	Введите счет, имя и баланс.
			Введите EOF для окончания ввода.
			? 100 Иванов 45.98
			? 200 Петров 23.11
			? 400 Сидоров -9.76
			? 500 Перцев 0.0
			? ^Z
</pre>
<p>Для каждого клиента программа получает номер счета, имя клиента, 
баланс клиента (сумма, которую клиент должен компании за товары и 
услуги, полученные в прошлом). Данные, полученные для каждого клиента, 
образуют запись. Номер счета в этом приложении используется в качестве 
ключа записи, то есть файл будет создаваться и обрабатываться в 
соответствии с порядком номеров счетов. Эта программа предполагает, что 
пользователь вводит записи в последовательности номеров счетов.
</p><p>В более полную систему платежных счетов может быть включена 
возможность сортировки, позволяющая пользователю вводить записи в 
произвольной последовательности - записи будут потом рассортированы и 
записаны в файл.
</p><p>В приведенной выше программе файлы открываются путем создания объектов классов потоков ifstream, ofstream или fstream.
<br>Файл должен быть открыт для вывода, так что создается объект ofstream.
<br>Конструктору объекта передаются два аргумента - имя файла и режим открытия файла.
</p><p>Для объекта ofstream режим открытия файла может быть
</p><ul><li>или ios :: out - для вывода данных в файл,
</li><li>или ios :: app - для добавления данных в конец файла (без модификации каких-либо данных, уже имеющихся в файле).
</li></ul>
<p>Существующие файлы, открываемые режимом ios :: out, усекаются - все данные в файле отбрасываются.
<br>Если какой-то файл еще не существует, тогда создается файл с тем же именем.
</p><p>Объявление&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>ofstream outClientFile("clients.dat", ios :: out);</b>
<br>создает объект outClientFile класса ofstream, связанный с файлом clients.dat, который открывается для вывода.
</p><p>Аргументы "clients.dat" и ios&nbsp;::&nbsp;out передаются 
конструктору класса ofstream, который открывает файл. Это устанавливает 
"линию связи" с файлом.
</p><p>По умолчанию объекты класса ofstream открыты для вывода, поэтому 
для открытия файла clients.dat для вывода может быть использован 
оператор
</p><p><b></b></p><center><b>ofstream outClientFile("clients.dat");</b></center><p></p>
<p>&nbsp;</p>
<p class="dbi" align="center">Режимы открытия файлов</p>
<p></p><center><table width="90%">
<tbody><tr><td width="25%">ios :: арр</td><td width="75%">Записать все данных в конец файла
</td></tr>
<tr><td valign="top">ios :: ate</td><td>Переместиться в конец исходного открытого файла. Данные могут быть записаны в любое место файла.
</td></tr>
<tr><td>ios :: in</td><td>Открыть файл для ввода
</td></tr>
<tr><td>ios :: out</td><td>Открыть файл для вывода
</td></tr>
<tr><td valign="top">ios :: trunc</td><td>Отбрасывать содержимое файла, если он существует (это по умолчанию делается для ios::out).
</td></tr>
<tr><td valign="top">ios :: nocreate</td><td>Если файл не существует, то операция его открытия не выполняется
</td></tr>
<tr><td valign="top">ios :: noreplace</td><td>Если файл существует, то операция его открытия не выполняется
</td></tr>
</tbody></table></center>
<p>Объект класса ofstream может быть создан без открытия какого-то файла - в этом случае файл может быть связан с объектом позднее.
</p><p>Например, объявление &nbsp;&nbsp;<b>ofstream outClientFile;</b>&nbsp;&nbsp;
создает объект &nbsp;outClientFile&nbsp; класса ofstream.
</p><p>Функция-элемент open класса ofstream открывает файл и связывает его с существующим объектом класса:
&nbsp;&nbsp;&nbsp;<b>outClientFile.open("clients.dat", ios&nbsp;::&nbsp;out);</b>
</p><p>После создания объекта класса ofstream и попытки открыть его программа проверяет, была ли операция открытия файла успешной.
</p><p>Фрагмент программы
</p><pre><b>
		if (!outClientFile)
		{
			cerr &lt;&lt; "Файл не может быть открыт" &lt;&lt; endl;
			exit (1);
		}
</b></pre>
<p>использует перегруженную функцию-операцию operator - элемент класса ios, для определения того, успешно ли открылся файл.
<br>Условие возвращает ненулевое значение (true), если при выполнении 
операции open для потока устанавливаются или failbit - при вводе данных 
неправильного типа - или badbit - при неуспешном завершении операции.
</p><p>Некоторые возможные ошибки являются следствием попытки
</p><ul><li>открыть для чтения несуществующий файл,
</li><li>открыть файл для чтения без разрешения,
</li><li>открытия файла для записи, когда на диске нет свободного места.
</li></ul>
<p>Когда условие указывает, что попытка открытия файла была безуспешной,
 выводится сообщение "Файл не может быть открыт" и вызывается функция 
exit для завершения программы.
<br>Аргумент функции exit возвращается среде окружения, из которой 
программа была вызвана. Аргумент 0 показывает, что программа завершается
 нормально, а любое другое значение, указывает среде окружения, что 
программа прекратила выполнение из-за ошибки.
<br>Значение, возвращаемое функцией exit, используется средой окружения 
(чаще всего операционной системой) для соответствующей реакции на 
ошибку.
</p><p>Другая перегруженная функция-операция&nbsp;&nbsp;&nbsp;<b>operator void*</b>&nbsp;&nbsp;-
 элемент класса ios, превращает поток в указатель, так что можно 
проверить, является ли он 0 (нулевым указателем), или имеет ненулевое 
значение (любое другое значение указателя).
</p><p>Если для потока устанавливаются failbit или badbit, то возвращается 0 (false).
<br>Условие в заголовке оператора while автоматически вызывает функцию-элемент operator&nbsp;void*:
&nbsp;&nbsp;&nbsp;<b>while (cin &gt;&gt; account &gt;&gt; name &gt;&gt; balance)</b>
</p><p>Это условие истинно, пока для cin не устанавливаются ни failbit, 
ни badbit. Ввод маркера конца файла устанавливает failbit для cin. 
Функция operator void* может быть использована для проверки конца файла в
 объекте ввода вместо явного вызова функции-элемента eof.
</p><p>Если файл открылся успешно, то программа начинает обрабатывать 
данные. Следующий оператор запрашивает пользователя о вводе различных 
полей каждой записи или информацию о конце файла, если ввод данных 
завершен:
</p><pre><b>
		cout &lt;&lt; "Введите счет, имя и баланс." &lt;&lt; endl
			&lt;&lt; "Введите EOF - для окончания ввода." &lt;&lt; endl &lt;&lt; " ? " ;

</b></pre>
<p class="dbi" align="center">Список комбинаций клавиш для ввода признака конца файла<br>в различных операционных системах</p>
<p></p><center><table width="50%">
<tbody><tr><td width="70%">UNIX</td><td width="30%">&lt;ctrl&gt; + d
</td></tr>
<tr><td>IBM PC и совместимые</td><td>&lt;ctrl&gt; + z
</td></tr>
<tr><td>Macintosh</td><td>&lt;ctrl&gt; + d
</td></tr>
<tr><td>VAX (VMS)</td><td>&lt;ctrl&gt; + z
</td></tr>
</tbody></table></center>
<p>Строка&nbsp;&nbsp;&nbsp;<b>while (cin &gt;&gt; account &gt;&gt; name &gt;&gt; balance)</b>
&nbsp;&nbsp;&nbsp;вводит каждый набор данных и определяет, не введен ли признак конца файла.
<br>Когда будет достигнут конец файла или вводятся неверные данные, 
операция извлечь из потока &gt;&gt; возвращает 0 (обычно операция 
извлечь из потока возвращает cin) и оператор while завершает свою 
работу.
<br>Пользователь должен вводить признак конца файла, чтобы сообщить программе о том, что ввод необходимых данных завершен.
<br>Оператор while продолжает выполнение цикла до тех пор, пока не будет введен маркер конца файла.
</p><p>Оператор&nbsp;&nbsp;&nbsp;<b>outClientFile &lt;&lt; account &lt;&lt; " " &lt;&lt; name &lt;&lt; " " &lt;&lt; balance &lt;&lt; endl;</b>
<br>записывает набор данных в текстовый файл "clients.dat", который 
может быть прочитан с помощью любого текстового редактора, используя 
операцию поместить в поток &lt;&lt; и объект outClientFile, связанный с 
файлом в начале программы.
</p><p>Как только вводится признак конца файла, функция main 
завершается. Это приводит к тому, что объект outClientFile уничтожается 
вызовом его деструктора, который закрывает файл clients.dat.
</p><p>Объект ofstream может быть явным образом закрыт программистом с помощью функции-элемента close:
&nbsp;&nbsp;&nbsp;<b>outClientFile.close();</b>
</p><p><table align="center" border="1" cellpadding="5" cellspacing="10" width="90%">
<tbody><tr><td class="rule"><b>Совет по повышению эффективности</b>
<br>Закрывайте явным образом каждый файл, как только станет понятным, что программа не будет обращаться к этому файлу снова.
<br>Это поможет сократить используемые ресурсы, которые программа 
продолжает потреблять длительное время после того, когда ей уже не надо 
обращаться к данному файлу.
<br>Этот прием делает программу также более ясной.
</td></tr>
</tbody></table>
</p><p>&nbsp;</p>
</td></tr>
</tbody></table>
<!-- -------End of Inside table------- -->
<table class="pages" align="center" border="0" cellpadding="0" cellspacing="0">
<tbody><tr colspan="5">
<td>&nbsp;&nbsp;<a href="http://prep.scc/%7Eblp/uch/op/plan_2.htm" class="p">Календарно-тематический план</a>&nbsp;&nbsp;</td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s29_32/index.htm" class="p">&nbsp; План лекции &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s29_32/01.htm" class="p">&nbsp; 1 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s29_32/02.htm" class="p">&nbsp; 2 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s29_32/03.htm" class="a">&nbsp; 3 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s29_32/04.htm" class="p">&nbsp; 4 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s29_32/05.htm" class="p">&nbsp; 5 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s29_32/06.htm" class="p">&nbsp; 6 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s29_32/07.htm" class="p">&nbsp; 7 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s29_32/08.htm" class="p">&nbsp; 8 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s29_32/09.htm" class="p">&nbsp; 9 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s29_32/10.htm" class="p">&nbsp; 10 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s29_32/11.htm" class="p">&nbsp; 11 &nbsp;</a></td>
<td><a href="http://prep.scc/%7Eblp/uch/op/lec/sem_2/s29_32/12.htm" class="p">&nbsp; 12 &nbsp;</a></td>
</tr>
</tbody></table>
<a name="#end"></a>

</body></html>