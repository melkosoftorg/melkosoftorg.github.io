<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОАП | Лекция № 43</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td>&nbsp&nbsp<a href="#end" class=p>Конец страницы</a>&nbsp&nbsp</td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr>
<td class=usual>
<p align=center class=dbi><br>Побитовые операции</p>
<p>Поразрядные операции можно применять только к целочисленным переменным (char, int, long).<br>Они позволяют производить операции очень низкого уровня - битового.
<p>Для обработки на уровне битов C++ имеет следующие операции:<ul>
<li><b><<</b> - сдвиг влево битового представления значения левого целочисленного операнда на количество 
разрядов, равное значению правого целочисленного операнда,
<p><li><b>>></b> - сдвиг вправо битового представления значения левого целочисленного операнда на количество 
разрядов, равное значению правого целочисленного операнда,
<p><li><b>&</b> - поразрядная коньюнкция <b>И</b> битовых представлений значений целочисленных операндов,
<p><li><b>|</b> - поразрядная дизъюнкция <b>ИЛИ</b> битовых представлений значений целочисленных операндов,
<p><li><b>^</b> - поразрядное исключающее <b>ИЛИ</b> битовых представлений значений целочисленных операндов,
<p><li><b>~</b> - побитовое отрицание <b>НЕ</b> - поразрядное инвертирование внутреннего двоичного кода.</ul>
<p>Информация 1 бит - это 0 или 1 (ложь или истина). 
<p>Для понимания побитовых операций необходимо вспомнить о двоичном представлении 
любой информации. Например, двоичное представление некоторых чисел 

<p><center><table border=0 cellpadding=5 cellspacing=5>
<tr><td>0 - 0000</td><td>1 - 0001</td><td>2 - 0010</td><td>3 - 0011</td><td>4 - 0100</td><td>5 - 0101
</td></tr>
<tr><td>6 - 0110</td><td>7 - 0111</td><td>8 - 1000</td><td>9 - 1001</td><td>10 - 1010</td><td>11 - 1011
</td></tr>
<tr><td>12 - 1100</td><td>13 - 1101</td><td>14 - 1110</td><td>15 - 1111</td><td>16 - 10000</td><td>17 - 10001
</td></tr>
</table></center>
<p><center><table border=0 cellpadding=5 cellspacing=5>
<tr><td>для символов:</td><td>r - 01110010</td><td>m - 01101101</td><td>ы - 11101011
</td></tr>
</table></center>
<p> &nbsp; </p>
<a name="01"></a>
<p align=center class=dbi><br>Сдвиг влево &nbsp; <<</p>
<p>В выражении &nbsp; <b>a = b << c;</b> &nbsp; производится сдвиг значения <b>b</b> влево на <b>c</b> бит. 
В освободившиеся справа биты <b>b</b> заносятся нули.
<p>Например, &nbsp; 4 << 2 = 16, &nbsp; поскольку 4<sub>10</sub> = 100<sub>2</sub>. 
<br>Сдвиг << равноценен добавлению двух нулей справа, то есть получим 10000<sub>2</sub>, 
что соответствует 20<sub>8</sub> или 16<sub>10</sub>.
<pre>
	printf("%d << %d = %d в 10 c/c = %o в 8 c/c", 4, 2, (4 << 2), (4 << 2));
	4 << 2 = 16 в 10 c/c = 20 в 8 c/c
</pre>
<p>Сдвиг влево на N позиций эквивалентен умножению значения операнда на 2<sup>N</sup>. 
<br>В примере 4 << 2 = 16, то есть 4 &#8729; 2<sup>2</sup> = 16.
<p>Аналогичную операцию выполним с кодом символа r: &nbsp; r << 1.
<pre>
	unsigned char m = 'r';
	printf("%c %d %o\n", m, m, m);
	printf("%c << 1 - %c %d %o\n", m, (m << 1), (m << 1), (m << 1));

	Получим:		r	114	162
			r << 1	ф	228	344
</pre>
<p>Десятичное представление кода символа r - 114, после выполнения операции r << 1 
получили код 228 (114 &#8729; 2<sup>1</sup> = 228), соответствующий символу ф.
<p> &nbsp; </p>
<a name="02"></a>
<p align=center class=dbi><br>Сдвиг вправо &nbsp; >></p>
<p>В выражении &nbsp; <b>a = b >> c;</b> &nbsp; производится сдвиг значения <b>b</b> вправо на <b>c</b> бит. 
В освободившиеся слева биты <b>b</b> заносятся нули.
<p>Например, &nbsp; 4 >> 2 = 1, &nbsp; поскольку 4<sub>10</sub> = 100<sub>2</sub>. 
<p>На самом деле сдвиг вправо на N позиций несколько сложнее. Следует отметить две 
особенности:<ol>
<li>исчезновение младших разрядов, выходящих за разрядную сетку, например, 4 >> 5.
<li>отсутствие стандарта на правило заполнения освобождающихся левых разрядов. 
<br>В стандарте языка сказано, если левый операнд есть целое значение с отрицательным 
знаком, то при сдвиге вправо заполнение освобождающихся левых разрядов определяется 
реализацией.
Возможны варианты:<ul>
<li>арифметический сдвиг вправо - освобождающиеся разряды заполняются значениями знакового разряда,
<li>логический сдвиг вправо - освобождающиеся разряды заполняются нулями.
</ul></ol>
<br>При положительном левом операнде сдвиг вправо на N позиций эквивалентен уменьшению значения 
левого операнда в 2<sup>N</sup> раз с отбрасыванием дробной части результата. 
<br>Например:<br><center>5 >> 2 = 1 &nbsp; (5<sub>10</sub> = 101<sub>2</sub>, &nbsp; 1<sub>10</sub> = 001<sub>2</sub>),
<br>14 >> 2 = 3 &nbsp; (14<sub>10</sub> = 1110<sub>2</sub>, &nbsp; 3<sub>10</sub> = 0011<sub>2</sub>)</center>. 
<p> &nbsp; </p>
<a name="03"></a>
<p align=center class=dbi><br>Поразрядная коньюнкция &nbsp; &</p>
<p>При выполнении операции поразрядное И в битовом представлении результата только 
те биты равны единице, которым соответствуют единичные биты обоих операндов.
<p><i><b><center>Примеры операций</center></b></i>
<p><center><table border=1 cellpadding=5 cellspacing=2>
<tr><td><center><b>Десятичные числа</b></center>
</td><td><center><b>Двоичные числа</b></center>
</td><td><center><b>Десятичные числа</b></center>
</td><td><center><b>Двоичные числа</b></center>
</td></tr>
<tr><td><b>10 & 3 = 2</b>
</td><td>1010 & 0011 = 0010
</td><td><b>13 & 7 = 5</b>
</td><td>1101 & 0111 = 0101
</td></tr>
<tr><td><b>6 & 5 = 4</b>
</td><td>110 & 101 = 100
</td><td><b>7 & 11 = 3</b>
</td><td>0111 & 1011 = 0011
</td></tr>
</table></center>
<p> &nbsp; </p>
<a name="04"></a>
<p align=center class=dbi><br>Поразрядная дизъюнкция &nbsp; |</p>
<p>В соответствии с названием операция поразрядное ИЛИ позволяет получить единицу в 
тех разрядах результата, где хотя бы один из битов равен единице.
<p><i><b><center>Примеры операций</center></b></i>
<p><center><table border=1 cellpadding=5 cellspacing=2>
<tr><td><center><b>Десятичные числа</b></center>
</td><td><center><b>Двоичные числа</b></center>
</td><td><center><b>Десятичные числа</b></center>
</td><td><center><b>Двоичные числа</b></center>
</td></tr>
<tr><td><b>10 | 3 = 11</b>
</td><td>1010 | 0011 = 1011
</td><td><b>13 | 7 = 15</b>
</td><td>1101 | 0111 = 1111
</td></tr>
<tr><td><b>6 | 5 = 7</b>
</td><td>110 | 101 = 111
</td><td><b>17 | 9 = 25</b>
</td><td>10001 | 01001 = 11001
</td></tr>
</table></center>
<p> &nbsp; </p>
<a name="05"></a>
<p align=center class=dbi><br>Поразрядное исключающее ИЛИ &nbsp; ^</p>
<p>При выполнении этой операции результат формируется при поразрядной обработке кодов операндов.
В тех разрядах, где оба операнда имеют одинаковые двоичные значения (1 и 1, 0 и 0), 
результат принимает значение 0.
<br>В тех разрядах, где биты операндов не совпадают, результат равен 1.
<p>Например, в результате исполнения фрагмента программы 
<pre>
	unsigned char	m = 'ы',	// код 11101011 - ы
			a = 'f';	// код 01100110 - f
	cout << "До ^\t" <<  m << '\t' << a << endl;
	m = m ^ a;		// код 10001101 - Н
	a = m ^ a;			// код 11101011 - ы
	m = m ^ a;		// код 01100110 - f
	cout << "После ^\t" << m << '\t' << a << endl;
</pre>
<p>переменные m и a обменялись значениями без использования вспомогательной переменной.
<pre>
		До ^	ы       f
		После ^	f       ы
</pre>
<p> &nbsp; </p>
<a name="06"></a>
<p align=center class=dbi><br>Побитовое отрицание&nbsp; ~</p>
<p>Операция поразрядного отрицания иначе называется операцией дополнения или инвертирования 
битов и является унарной - одноместной.
<p>Значение операнда в виде внутреннего битового представления обрабатывается таким 
образом, что формируется значение того же типа и длины, что и операнд. В битовом 
представлении результата все цифры заменяются на противоположные: 0 на 1, 1 на 0.
<p>Например, для фрагмента программы, где w - число в восьмеричной системе счисления,  
<pre>
	unsigned char w = '\156', y = ~w;
	printf("\n\n%c %d %o \t %c %u %o\n", w, w, w, y, y, y);

	получим результат:	n - 110 - 156	С - 145 - 221
<pre>
<br>То есть восьмеричный код 156 соответствует символу n, двоичный код которого (1 байт)
01101110.
<br>Заменим все цифры на противоположные, получим 10010001, соответствующее 
восьмеричному коду 221 символа С.
<p> &nbsp; </p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td>&nbsp&nbsp<a href="#start" class=p>Начало страницы</a>&nbsp&nbsp
&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
<FONT color="#FFFF66" size=1><i>Copyright</i> &copy; <a class=p href="http://prep.scc/~blp">
Болгак Л. П.</a> <i>2003</i></font></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>