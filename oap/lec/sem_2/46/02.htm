<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | Лекция № 46</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=a>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr>
<td class=usual>
<p align=center class=dbi><br>Абстрактные классы</p>
<b><i>Абстрактным классом называется</i></b> класс, в котором есть хотя бы одна чистая (пустая) 
виртуальная функция.
<p><b><i>Чистой виртуальной называется</i></b> компонентная функция, которая имеет следующее 
определение:
<p><center>virtual тип имя_функции(список_формальных_параметров) = 0;</center>
<p>Конструкция <b>"= 0"</b> называется "чистый спецификатор".
<p>Пример описания чистой виртуальной функции: &nbsp; &nbsp; virtual void fpure(void) = 0;
<p>Чистая виртуальная функция "ничего не делает" и недоступна для вызовов. Ее назначение 
- служить основой для подменяющих ее функций в производных классах значит 
невозможно создать самостоятельные объекты абстрактного класса. Абстрактный класс 
может использоваться только в качестве базового для производных классов. При создании 
объектов такого производного класса в качестве подобъектов создаются объекты 
абстрактного базового класса.
<br><center><table>
<tr><td><b><i>Имеется абстрактный класс B</i></b>
</td><td> &nbsp; &nbsp; &nbsp; &nbsp; 
</td><td><b><i>Производные от класса B классы:</i></b>
</td></tr>
<tr><td valign="top"><pre>
class В
{	protected:
		virtual void func(char) = 0;
		void sos(int);
};
</pre>
</td><td> &nbsp; &nbsp; 
</td><td><pre>
class D <b>:</b> public В
{	<b>...</b>
	void func(char);
};
class E <b>:</b> public В
{
	void sos(int);
};
</pre></td></tr>
</table></center>
В классе D чистая виртуальная функция func() заменена конкретной виртуальной 
функцией того же типа. Функция B <b>::</b> sos() наследуется классом D и доступна в нем и в его 
методах.
<br>Класс D не абстрактный.
<p>В классе E переопределена функция B <b>::</b> sos(), а виртуальная функция B <b>::</b> func() 
унаследована.
Тем самым класс B становится абстрактным и может использоваться только как базовый.
<p>Как всякий класс, абстрактный класс может иметь явно определенный конструктор. Из 
конструктора возможен вызов методов класса но любые прямые или опосредованные 
обращения к чистым виртуальным функциям приведут к ошибкам во время выполнения 
программы.
<p>Рассмотрим программу, в которой на основе базового класса point построен абстрактный 
класс figure.<br>В классе figure определены:<ul>
<li>конструктор,
<li>чистая виртуальная функция show() для вывода изображения фигуры на экран дисплея,
<li>в класс входят методы:
<ul><li>hide() - убрать изображение фигуры с экрана дисплея
<li>move() - переместить изображение фигуры в заданную точку экрана.
</ul></ul>
Функции hide() и move() обращаются к чистой виртуальной функции show(). Реальное 
выполнение show() возможно только после создания производного класса, в котором 
чистая виртуальная функция show() будет подменена компонентной функцией для 
изображения конкретной фигуры.
<pre>
	// FIGURE.CPP - определение абстрактного класса figure на базе класса point
	#include "point.cpp"
	class figure <b>:</b> public point
	{	public:
			figure (point p) <b>:</b> point(p<b>.</b>givex(), p<b>.</b>givey()) { }	// Конструктор класса figure
			// Чистая виртуальная функция для будущего изображения фигур:
			virtual void show() = 0;
			void hide()	// Функция для удаления изображения фигуры
			{	int bk, cc;
				bk = getbkcolor(); cc = getcolor();
				// Обращение к чистой виртуальной функции
				setcolor(bk); show();
				setcolor(cc);
			}
			void move(point p)	// Перемещение фигуры в точку p
			{ hide(); x = p<b>.</b>givex(); y = p<b>.</b>givey(); show(); }
	};
</pre>
На базе класса figure определим неабстрактные классы:
<pre>
	// ELLIPS.FIG - конкретный класс "эллипс" на основе figure
	class ellips <b>:</b> public figure
	{	int rx, ry;
		public:	ellips (point d, int radx, int rady) <b>:</b> figure(d)	// Конструктор
			{ rx = radx; ry = rady; }
			void show() { ellipse(x, y, 0, 360, rx, ry); return; }
	};

	// CIRC.FIG - конкретный класс "окружность"
	class circ <b>:</b> public figure
	{	int radius;
		public:	circ(point e, int rad) : figure(e)			// Конструктор
			{ radius = rad; }
			void show() { circle(x, y, radius); }
	};
</pre>
В программе используются все три класса и виртуальные функции
<pre>
	#include&lt;graphics.h>
	#include&lt;conio.h>
	#include&lt;stdio.h>
	#include&lt;stdlib.h>
	#include "..\\h\\init.h"
	#include "figure.cpp"
	#include "circ.fig"
	#include "ellips.fig"
	void main(void)
	{	point A(100, 80), B(300, 200); circ C (A, 60); ellips E(B, 200, 100);
		{
			init();
		  	A<b>.</b>show(); getch(); B<b>.</b>show(); getch();	// Изобразить точку - point <b>::</b> show()
			C<b>.</b>show(); getch();			// Показать окружность - circ <b>::</b> show():
			E<b>.</b>show(); getch();			// Показать эллипс - ellips <b>::</b> show():
			// Совместить фигуры - circ <b>::</b> figure <b>::</b> move():
			C<b>.</b>move(B); getch();
			E<b>.</b>hide(); getch() ;			// Убрать эллипс - ellips <b>::</b> figure <b>::</b> hide():
			// Убрать окружность - circ <b>::</b> figure <b>::</b> hide():
			C<b>.</b>hide(); getch();
		} closegraph();
	}
</pre>
На базе класса figure определены два производных класса: circ (окружность) и ellips 
(эллипс), для которых унаследованный класс point определяет центры фигур. В обоих 
классах определены конкретные методы show() и из абстрактного класса figure 
унаследованы функции move() и hide().
<p>Абстрактные классы пользуются "ограниченными правами":<ul>
<li>невозможно создать объект абстрактного класса,
<li>абстрактный класс нельзя употреблять для задания типа параметра функции или в 
качестве типа возвращаемого функцией значения,
<li>абстрактный класс нельзя использовать при явном приведении типов. В то же 
время можно определять указатели и ссылки на абстрактные классы.
<li>объект абстрактного класса не может быть формальным параметром функции, 
однако формальным параметром может быть указатель абстрактного класса, что 
дает возможность передавать в вызываемую функцию в качестве фактического 
параметра значение указателя на производный объект, заменяя им указатель на 
абстрактный базовый класс.</ul>
Сформируем односвязный список, в элементы которого будут включаться объекты 
разных классов, производных от одного абстрактного класса. В качестве абстрактного 
базового класса выберем класс figure. Список в целом будет описываться классом chain.
<br>В класс chain входят в качестве компонентов:<ul>
<li>статический указатель на последний элемент, уже включенный в список (last),
<li>статический указатель на начало списка (begin),
<li>указатель в объекте на следующий элемент списка (next),
<li>указатель в объекте на абстрактный базовый класс figure (pfig).</ul>
Параметр конструктора класса chain пусть имеет тип указателя на абстрактный 
базовый класс figure.
<br>В качестве фактических параметров будем использовать ссылки на конкретные объекты 
классов, производных от абстрактного класса figure. Тем самым в односвязный список 
включаются конкретные фигуры (окружность - класс circ, эллипс - класс ellips).
<p><center><img src="l48_01.gif"></center>
<pre>
	#include&lt;graphics.h>
	#include&lt;conio.h>
	#include&lt;stdio.h>
	#include&lt;stdlib.h>
	#include "..\\h\\init.h"
	#include "point.cpp"	// Базовый класс для figure
	#include "figure.cpp"	// Абстрактный класс, производный от point:
	#include "circ.fig"		// Класс, производный от абстрактного figure:
	#include "ellips.fig"	// Класс, производный от абстрактного figure:
	class chain	// Объекты класса - фигуры, включенные в односвязный список:
	{	// Объект - элемент в односвязном списке
		static chain *last;	// Указатель на последний элемент в списке:
		chain *next;	// Указатель в объекте на следующий элемент:
		public:
			// Указатель на фигуру, входящую в элемент списка:
			figure *pfig;
			static chain *begin;	// Указатель на начало списка:
			chain(figure *p) ;		// Конструктор:
			static void showAll(void);	// Функция изображает все фигуры списка:
	};
	// Внешнее описание и инициализация статических компонентов класса:
	chain * chain <b>::</b> begin = NULL;		// Начало списка
	chain *chain <b>::</b> last = NULL;			// Последний элемент в списке
	void chain <b>::</b> showAll(void)			// Изображение элементов списка
	{	chain *uk = begin;			// Настройка на начало списка
		while (uk != NULL)		// Цикл до конца списка
		{	uk -> pfig -> show();	// Нарисовать конкретную фигуру
			uk = uk -> next;		// Настройка на следующий элемент
		}
	}
	// Конструктор создает и включает в список объект, связав его с конкретной фигурой
	// из класса, производного от абстрактного:
	chain <b>::</b> chain(figure *p)		// р - адрес включаемой фигуры
	{	if (begin == NULL)	// Определили начало списка
			begin = this;
		else
			last -> next = this;	// Связь с предыдущим элементом
		pfig = p;			// Запоминаем адрес включаемой фигуры
		next = NULL;		// Пометим окончание списка
		last = this;		// Запоминаем адрес последнего  элемента списка
	}
	void main()
	{	point A(100, 80), B(300, 200);
		circ C(A, 60); ellips E(B, 200, 100);
		{	init();
			A<b>.</b>show(); getch(); B.show(); getch();	// Изобразить точку - point<b>::</b>show()
			C<b>.</b>show(); getch();		// Показать окружность - circ<b>::</b>show():
			chain ca(&C);	// Включить в список первый элемент - окружность С
			E<b>.</b>show(); getch();		// Показать эллипс - ellips<b>::</b>show()
			chain ce(&E);		// Включить в список эллипс
			C<b>.</b>move(B); getch();	// Совместить фигуры - circ<b>::</b>figure<b>::</b>move():
			E<b>.</b>hide(); getch();		// Убрать эллипс - ellips<b>::</b>figure<b>::</b>hide()
			C<b>.</b>hide(); getch();		// Убрать окружность - circ<b>::</b>figure<b>::</b>hide():
			chain <b>::</b> showAll(); getch();	// Изобразить все фигуры из списка:
		} closegraph();
	}
</pre>
Статическая компонентная функция chain <b>::</b> showAll() обеспечивает вывод на экран 
изображений всех фигур, включенных в односвязный список. <br>Указатель uk типа chain * 
позволяет обратиться к компоненту pfig - указателю на абстрактный базовый класс figure. 
После выполнения конструктора chain() значением pfig является ссылка на объект 
некоторого производного от figure класса. Именно оттуда выбирается соответствующая 
функция show(), подменяющая чистую виртуальную функцию figure <b>::</b> show(). Тем самым 
на экран выводится изображение конкретной фигуры.
<p>В основной программе формируются точки A, B и на них, как на центрах, создаются 
объекты C (окружность) и Е (эллипс). В графическом режиме выводятся на экран и 
убираются с экрана изображения всех созданных объектов. Затем функцией ShowAll() 
рисуются все объекты, включенные в список.
<p> &nbsp; </p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=a>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>