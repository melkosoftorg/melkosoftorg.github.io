<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | Лекция № 46</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=a>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<!--tr><td class=rule>
Внимание!
<ol>В окнах такого цвета будут отображаться правила и примечания относительно 
лекционного материала
</ol></td></tr-->
<tr>
<td class=usual>
<p align=center class=dbi><br>Полиморфные классы</p>
К механизму виртуальных функций обращаются в тех случаях, когда в базовый класс 
необходимо поместить функцию, которая должна по-разному выполняться в производных 
классах, в каждом производном классе требуется свой вариант этой функции.
<p>Базовый класс может описывать фигуру на экране без конкретизации ее вида, а 
производные классы (треугольник, эллипс и так далее) однозначно определяют ее формы 
и размеры. Если в базовом классе ввести функцию для изображения фигуры на экране, то 
выполнение этой функции будет возможно только для объектов каждого из производных 
классов, определяющих конкретные изображения.
<p>Классы, включающие виртуальные функции, играют особую роль в объектно-ориентированном программировании и носят название - полиморфные.
<br>Рассмотрим, как ведут себя при наследовании не виртуальные компонентные функции с 
одинаковыми именами, типами и сигнатурами параметров.<br>Если в базовом классе 
определена некоторая компонентная функция, то такая же функция (с тем же именем, того 
же типа и с тем же набором и типами параметров) может быть введена в производном 
классе.
<pre>
	// BASE.DIR - определения базового и производного классов
	struct base
	{
		void fun(int i) { cout << "\nbase <b>::</b> i = " << i; }
	};
	struct dir : public base
	{
		void fun (int i) { cout << "\ndir <b>::</b> i = " << i; }
	};
</pre>
Внешне одинаковые функции void fun(int) определены в базовом классе base и в производном классе dir.
<p><b><i>В теле класса dir</i></b> обращение к функции fun(), принадлежащей классу base, может быть 
выполнено с помощью полного квалифицированного имени, явно включающего имя 
базового класса: base <b>::</b> fun(). <br>При обращении в классе dir к такой же (по внешнему виду) 
функции, принадлежащей классу dir, достаточно использовать имя fun() без 
предшествующего квалификатора.
<p>В программе, где определены и доступны оба класса base и dir, обращения к функциям 
fun(), одинаковым в базовом и производном классах, могут быть выполнены с помощью 
указателей на объекты соответствующих классов. <br>В программе введены три указателя на объекты разных классов.
<pre>
	#include&lt;iostream.h&gt;
	#include&lt;conio.h&gt;
	#include "base.dir" // Определения классов
	void main(void)
	{
		base B, *bp = &B;
		dir D, *dp = &D;
		base *pbd = &D; clrscr();
		bp -> fun(1);		// Печатает : base <b>::</b> i = 1
		dp -> fun(5);		// Печатает : dir <b>::</b> i = 5
		pbd -> fun(4);		// Печатает : base <b>::</b> i = 4
		getch();
}

	<b><i>Результаты выполнения программы:</i></b>	base <b>::</b> i = 1
						dir <b>::</b> i = 5
						base <b>::</b> i = 4
</pre>
Инициализация указателя pbd: ссылка на производный класс (на объект D) автоматически 
преобразуется в ссылку на прямой базовый класс (base *). Преобразование ссылки на 
базовый класс в ссылку на производный класс, невозможно (запрещено синтаксисом).
Вызов pbd -> fun() приводит к вызову функции из базового класса. Указатель pbd имеет 
тип base*, его значение - адрес объекта D класса dir. Выбор функции зависит только от 
типа указателя, но не от его значения. "Настроив" указатель базового класса на объект 
производного класса, не удается с помощью этого указателя вызвать функцию из 
производного класса.
<p>Пусть в базовом классе figure определена компонентная функция void show(). Так как 
внешний вид фигуры в базовом классе еще не определен, то в каждый из производных 
классов нужно включить свою функцию void show() для формирования изображения на 
экране. Доступ к функции show() производного класса возможен только с помощью 
явного указания области видимости:имя_производного_класса <b>::</b> show()
либо с использованием имени конкретного объекта:
имя_объекта_производного_класса.show()
<br>В обоих случаях выбор нужной функции выполняется при написании исходного текста 
программы и не изменяется после компиляции - режим раннего (статического 
связывания).
<p>Большую гибкость (особенно при использовании уже готовых библиотек классов) 
обеспечивает позднее (отложенное), или динамическое связывание, которое 
предоставляется механизмом виртуальных функций. Любая нестатическая функция 
базового класса может быть сделана виртуальной, если в ее объявлении использовать 
спецификатор virtual.
<pre>
	#include&lt;iostream.h&gt;
	#include&lt;conio.h&gt;
</pre>
	Опишем в базовом классе base виртуальную функцию: void vfun(int).
<pre>
	struct base
	{	virtual void vfun(int i)
		{ cout << "\nbase <b>::</b> i = " << i; }
	};
</pre>
Введем два производных класса dir1 и dir2, где определим функции с такими же 
прототипами, но без спецификатора virtual.
<pre>
	struct dir1 : public base
	{	void vfun(int i)
		{ cout << "\ndir1 <b>::</b> i = " << i; }
	};

	struct dir2 : public base
	{	void vfun(int i)
		{ cout << "\ndir2 <b>::</b> i = " << i; }
	};

	void main(void)
	{	base B, *bp = &B;
		dir1 D1, *dp1 = &D1;
		dir2 D2, *dp2 = &D2; clrscr();
		bp -> vfun(1);		// Печатает: base <b>::</b> i = 1
		dp1 -> vfun(2);		// Печатает: dir1 <b>::</b> i = 2
		dp2 -> vfun(3);		// Печатает: dir2 <b>::</b> i = 3
		bp=&D1; bp -> vfun(4);	// Печатает: dir1 <b>::</b> i = 4
		bp=&D2; bp -> vfun(5);	// Печатает: dir2 <b>::</b> i = 5
		getch();
	}

	<b><i>Результат работы программы:</i></b>	base <b>::</b> i = 1
					dir1 <b>::</b> i = 2
					dir2 <b>::</b> i = 3
					dir1 <b>::</b> i = 4
					dir2 <b>::</b> i = 5
</pre>
Доступ к функциям vfun() через указатель bp на базовый класс: когда bp принимает 
значение ссылки &B на объект класса base, вызывается функция из базового класса, затем 
bp последовательно присваиваются значения ссылок на объекты производных классов 
&D1, &D2, и выбор соответствующего экземпляра функции vfun() каждый раз 
определяется именно объектом. Интерпретация каждого вызова виртуальной функции 
через указатель на базовый класс зависит от значения этого указателя, то есть от типа 
объекта, для которого выполняется вызов. Интерпретация вызова через указатель не 
виртуальной функции зависит только от типа указателя.
<p>Виртуальными могут быть только компонентные функции какого-либо класса. После того 
как функция определена как виртуальная, ее повторное определение в производном классе 
(с тем же самым прототипом) создает в этом классе новую виртуальную функцию, причем 
спецификатор virtual может не использоваться.
<p>В производном классе нельзя определять функцию с тем же именем и с той же сигнатурой 
параметров, но с другим типом возвращаемого значения, чем у виртуальной функции 
базового класса. Это приводит к ошибке на этапе компиляции.
<br>Если в производном классе ввести функцию с тем же именем и типом возвращаемого 
значения, что и виртуальная функция базового класса, но с другой сигнатурой 
параметров, то эта функция производного класса не будет виртуальной. В этом случае с 
помощью указателя на базовый класс при любом значении этого указателя выполняется 
обращение к функции базового класса (несмотря на спецификатор virtual и присутствие в 
производном классе похожей функции).<p>Рассмотрим некоторые особенности виртуальных 
функций.
<pre>
	#include&lt;iostream.h&gt;
	#include&lt;conio.h&gt;
	struct base
	{	virtual void f1(void) { cout << "\nbase <b>::</b> f1"; }
		virtual void f2(void) { cout << "\nbase <b>::</b> f2"; }
		virtual void f3(void) { cout << "\nbase <b>::</b> f3"; }
	};
	struct dir : public base
	{	void f1(void) { cout << "\ndir <b>::</b> f1"; }	// Виртуальная функция:
		// Ошибка в типе функции: int f2(void) { cout << "\ndir <b>::</b> f2"; }
		void f3(int i) { cout << "\ndir <b>::</b> f3 <b>::</b> i = " << i; }	// Не виртуальная функция:
	};
	void main(void)
	{	base B, *pb = &B; clrscr();
		dir D, *pd = &D;
		pb -> f1(); pb -> f2(); pb -> f3(); pd -> f1(); pd -> f2();
		// Ошибка при попытке без параметра вызвать dir<b>::</b>f3(int): pd->f3();
		pd -> f3(0); pb = &D; pb -> f1(); pb -> f2(); pb -> f3(); getch();
		// Ошибочное употребление или параметра, или указателя: pb->f3(3);
	}

	<b><i>Результат выполнения программы:</i></b>		base <b>::</b> f1
						base <b>::</b> f2
						base <b>::</b> f3
						dir <b>::</b> f1
						base <b>::</b> f2
						base <b>::</b> f3 <b>::</b> i = 0
						dir <b>::</b> f1
						base <b>::</b> f2
						base <b>::</b> f3
</pre>
Три виртуальные функции базового класса по-разному воспринимаются в производном классе.
<ul>
<li>dir <b>::</b> f1() - виртуальная функция, подменяющая функцию base <b>::</b> f1().
<li>Функция base <b>::</b> f2() наследуется в классе dir так же, как и функция base <b>::</b> f3().
<li>Функция dir <b>::</b> f3(int) - совершенно новая компонентная функция (не виртуальная) 
производного класса, никак не связанная с базовым классом. Поэтому невозможен 
вызов f3(int) через указатель на базовый класс.
<li>Виртуальные функции base <b>::</b> f2() и base <b>::</b> f3() оказались не переопределенными в 
производном классе dir. Поэтому при всех вызовах без параметров f3() 
используется только компонентная функция базового класса.
</ul>
При подмене виртуальной функции требуется полное совпадение сигнатур функций в 
базовом и производном классах.
<p>Виртуальной функцией может быть только, нестатическая компонентная функция. 
<p>Виртуальной не может быть глобальная функция. Функция, подменяющая виртуальную 
функцию, в производном классе может быть описана как со спецификатором virtual, так и 
без него. В обоих случаях она будет виртуальной, то есть ее вызов возможен только для 
конкретного объекта. Виртуальная функция может быть объявлена дружественной (friend) 
в другом классе.
<p>Механизм виртуального вызова может быть подавлен с помощью явного использования полного квалифицированного имени.
<pre>
	struct base
	{	virtual int f(int j)
		{ return j * j; }
	};
	struct dir : public base
	{	int f(int i)
		{ return base <b>::</b> f(i * 2); }
	};
</pre>
<p>&nbsp;</p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=a>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>