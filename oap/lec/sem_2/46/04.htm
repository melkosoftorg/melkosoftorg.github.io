<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | Лекция № 46</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=a>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr>
<td class=usual>
<p align=center class=dbi><br>Классы и шаблоны <br>(для BC++, начиная с версии 3.1)</p>
Шаблоны, которые иногда называют родовыми или параметризованными типами, 
позволяют создавать (конструировать) семейства родственных функций и классов. 
<p>Шаблон семейства функций (function template) определяет неограниченное множество 
родственных функций и имеет следующий вид:
<p><center>template <список_параметров шаблона> определение функции</center>
<p>Угловые скобки - неотъемлемый элемент определения, список параметров шаблона 
должен быть заключен именно в угловые скобки.
<p>Аналогично определяется шаблон семейства классов:
<p><center>template <список_параметров_шаблона> определение класса</center>
<p>Шаблон семейства классов определяет способ построения отдельных классов подобно 
тому, как класс определяет правила построения и формат отдельных объектов. В 
определении класса, входящего в шаблон, особую роль играет имя класса. Оно является 
не именем отдельного класса, а параметризованным именем семейства классов.
<br>Определение шаблона может быть только глобальным.
<p>Рассмотрим векторный класс (в числе данных одномерный массив). Какой бы тип ни 
имели элементы массива, в этом классе должны быть определены одни и те же базовые 
операции, например доступ к элементу по индексу и другие. Если тип элементов вектора 
задавать как параметр шаблона класса, то система будет формировать вектор нужного 
типа (и соответствующий класс) при каждом определении конкретного объекта. 
<p>Следующий шаблон позволяет автоматически формировать классы векторов с 
указанными свойствами:
<pre>
	// TEMPLATE.VEC - шаблон векторов, Т - параметр шаблона class
	template &lt;class T>
	class Vector
	{	T *data;			// Начало одномерного массива
		int size;			// Количество элементов в массиве
		public:
			Vector(int);	// Конструктор класса vector
			// Деструктор. Расширение действия (перегрузка) операции "[ ]":
			~Vector() { delete[] data; }
			T& operator[] (int i) { return data[i]; }
	};
	template &lt;class T>		// Внешнее определение конструктора класса:
	Vector &lt;T> <b>::</b> Vector(int n)
	{	data = new T[n];
		size = n;
	};
</pre>
Когда шаблон введен, появляется возможность определять конкретные объекты 
конкретных классов, каждый из которых параметрически порожден из шаблона. <p>Формат 
определения объекта одного из классов, порождаемых шаблоном классов:
<p><center>имя параметризованного_класса <фактические_параметры шаблона>
имя объекта(параметры_конструктора);</center>
<p>Например, определить вектор, имеющий восемь вещественных координат типа double, 
можно: <p><center>Vector <double> Z(8);</center>
<pre>
	// формирование классов с помощью шаблона
	#include "template.vec"		// Шаблон классов "вектор"
	#include&lt;iostream.h>
	#include&lt;conio.h>
	main ()
	{	clrscr();
		Vector &lt;int> X(5);		// Создаем объект класса "целочисленный вектор":
		Vector &lt;char> C(5);	// Создаем объект класса "символьный вектор":
		for (int i = 0; i < 5; i++)	// Определяем компоненты векторов:
		{	X[i] = i;
			C[i] = 'A' + i;
		}
		for (i = 0; i < 5; i++)
			cout << " " << X[i] << ' ' << C[i];
		getch(); return 0;
	}

	<i>Результат выполнения программы:</i>	0 A  1 В  2 С  3 D  4 Е
</pre>
Шаблон семейства классов с общим именем Vector используется для формирования двух 
классов с массивами целого и символьного типов. В соответствии с требованием 
синтаксиса имя параметризованного класса, определенное в шаблоне (vector), 
используется в программе только с последующим конкретным фактическим параметром 
(аргументом), заключенным в угловые скобки. Параметром может быть имя стандартного 
или определенного пользователем типа. <br>В примере использованы стандартные типы int и 
char. Использовать имя vector без указания фактического параметра шаблона нельзя - 
никакое умалчиваемое значение при этом не предусматривается.
<p>В списке параметров шаблона могут присутствовать формальные параметры, не 
определяющие тип, параметры, для которых тип фиксирован:
<pre>
	#include&lt;iostream.h>
	template &lt;class T, int size = 64>
	class row
	{	T *data;
		int length;
		public:
			row()
			{ length = size; data = new T[size]; }
			~row() { delete[] data; }
			T& operator [] (int i)
			{ return data[i]; }
	};
	void main()
	{	row &lt;float, 8> rf;
		row &lt;int, 8> ri;
		for(int i = 0; i < 8; i++)
		{
			rf[i] = i; ri[i] = i * i;
		}
		for(i = 0; i < 8; i++)
			cout << " " << rf[i] << ' ' << ri[i];
	}

	<i>Результат выполнения программы:</i>	0 0   1 1   2 4   3 9   4 16   5 25   6 36   7 49
</pre>
В качестве аргумента, заменяющего при обращении к шаблону параметр size, взята 
константа. В общем случае может быть использовано константное выражение, однако 
выражения, содержащие переменные, использовать в качестве фактических параметров 
шаблонов нельзя.
<p> &nbsp; </p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=a>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>