<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | Лекция № 44</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=a>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr>
<td class=usual>
<p align=center class=dbi><br>Расширение действия (перегрузка) стандартных операций</p>
Язык C++ дает возможность распространять действия стандартных операций на 
операнды, для которых эти операции первоначально в языке не предполагались. 
<br>Например, если S1 и S2 - символьные строки, то их конкатенацию (соединение) удобно 
было бы обозначить как: S1 + S2, чего не предусмотрено в языке C++. <br>Однако, если 
определить S1 и S2 как объекты некоторого класса, например, уже введенного класса 
stroka, то для них можно ввести операцию +, выполняемую по таким правилам, которые 
заранее выбрал программист. <br>Для этих целей язык C++ позволяет распространить 
действие любой стандартной операции на новые типы данных, вводимые пользователем, 
используя механизм перегрузки стандартных операций.
<p><b><i>Для распространения действия операции на новые пользовательские типы данных</i></b> 
программисту необходимо определить специальную функцию, называемую "операция-функция" (operator function). <br><b><i>Формат определения операции-функции:</i></b>
<pre>
	тип_возвращаемого_значения operator знак_операции (список аргументов)
	{
		операторы_тела_операции-функции
	}
</pre>
<p>Типом возвращаемого значения операции-функции является класс, для которого она определена. Хотя операция-функция может возвращать данные любого типа.
<p>При необходимости может добавляться и прототип операции-функции с таким форматом:
<pre>
	тип_возвращаемого_значения operator знак_операции (список аргументов);
</pre>
<p>И в прототипе, и в заголовке определения операции-функции используется ключевое 
слово operator, вслед за которым помещен знак операции. <br>Если принять, что конструкция
&nbsp; &nbsp; operator знак_операции &nbsp; &nbsp; есть имя некоторой функции, то определение и прототип операции-функции подобны 
определению и прототипу обычной функции языка C++. <br>Например, для распространения 
действия бинарной операции * на объекты класса T может быть введена функция с 
заголовком &nbsp; &nbsp; &nbsp; &nbsp; Т operator * (Т x, Т y).
<br>Определенная таким образом операция называется перегруженной (по-английски - 
overload), а сам механизм - перегрузкой или расширением действия стандартных операций 
языка C++. <p>Операция-функция определяет алгоритм выполнения перегруженной 
операции, когда эта операция применяется к объектам класса, для которого операция-функция введена. <br>Чтобы явная связь с классом была обеспечена операция-функция 
должна быть либо компонентом класса, либо она должна быть определена в классе как 
дружественная, либо у нее должен быть хотя бы один параметр типа класс (или ссылка на 
класс).
<p>Распространим действие операции + на объекты класса "символьные строки", для чего 
используем определенный в <a href="../42/03.htm#01" target="blank">STROKA.CPP</a> класс stroka, в котором len длина строки и ch - 
указатель на символьный массив с текстом строки. <br>В классе stroka два конструктора. 
<ul><li>Один для создаваемого объекта выделяет память заданных размеров и оформляет ее как пустую строку. 
<li>Второй формирует объект класса stroka по уже существующей строке, заданной в качестве фактического параметра.
</ul>
<p>Вне класса определим операцию-функцию с заголовком
<pre>
			stroka& operator + (stroka& A, stroka& В),
</pre>
<p>распространяющую действие операции + на объекты класса stroka. <br>Определение 
операции-функции размещено ниже основной программы, в которой используется 
выражение с операцией +, примененной к объектам класса stroka. Такое размещение 
текста определения операции-функции потребовало применения ее прототипа, который 
помещен до функции main().
<pre>
	#include "stroka.cpp"			// Определение класса "символьные строки"
	#include&lt;conio.h&gt;
	stroka& operator + (stroka & A, stroka & B);	// Прототип функции
	void main(void)
	{	stroka X("Qui"), Y(" Vivra"), Z(" Verra!"), C;
		C = X + Y + Z + " - Поживем - увидим!"; clrscr();
		C.display(); getch();
	}
	// Расширение действия операции + на строковые операнды;
	stroka& operator + (stroka& a, stroka& b)
	{	int ii = a.len_str() + b.len_str();	// Длина строки-результата:
		stroka *ps;			// Вспомогательный указатель
		ps = new stroka(ii) ;		// Создаем объект в динамической памяти:
		strcpy(ps -> string(), a.string());	// Копируем строку из а :
		strcat(ps -> string(), b.string()) ;	// Присоединяем строку из b :
		ps -> len_str() = ii;			// Записываем значение длины строки
		return *ps;			// Возвращаем новый объект stroka
	}
	
	<i>Результат выполнения программы:</i>
				Длина строки: 36
				Содержимое строки: Qui Vivra Verra! - Поживем - увидим!
</pre>
<p>Операция-функция, расширяющая действие операции + на операнды типа stroka&, 
используется трижды в одном выражении X + Y + Z + "- Поживем - увидим!"
<p>Кроме сокращенной формы вызова (с помощью выражения с операндами нужных типов) 
возможна и полная форма вызова:
<pre>
			operator знак_операции(фактические_параметры);
</pre>
<p>Например, к тому же результату приведет последовательность операторов:
<pre>
0		C = operator + (X, Y);
		C = operator + (C, Z);
		C = operator + (C, " - Поживем - увидим!");
</pre>
<p><b><i>Внешнее определение операции-функции члена класса</i></b> имеет вид:
<pre>
	возвращаемый_тип имя класса :: operator знак_операции (список аргументов)
	{ операторы_тела_операции-функции }
</pre>
<p><b><i>Возможность перегрузки бинарной операции представляют компонентные функции 
классов.</i></b>
<br>Когда операция-функция - член класса перегружает бинарный оператор, у функции будет только один параметр.
Этот параметр получит тот объект, который расположен справа от оператора.
Объект слева ганерирует вызов операции-функции и передается неявно, с помощью <a href="../43/05.htm">указателя this</a>.
<p>Введем операцию + для точек на экране дисплея, определяемых классом point1. 
Для краткости упростим определение класса, оставив только самые необходимые 
компоненты, дополнительно введем операцию-функцию, расширяющую действие 
бинарной операции + :
<pre>
	#include&lt;graphics.h>
	#include&lt;conio.h>
	#include&lt;stdio.h>
	#include&lt;stdlib.h>
	#include"..\\h\\init.h"
	class point1				// Точка на экране
	{	protected:			// Защищенные компоненты (данные) класса
			int x, y;			// Координаты точки
		public:				// Общедоступные принадлежащие классу функции:
			point1 (int xi = 0, int yi = 0)	// Конструктор
			{ x = xi; y = yi; };
			void show(void)		// Изобразить точку и отметить ее окружностью
			{	putpixel(x, y, getcolor());
				circle(x, y, 3);
			}
			// Прототип компонентной операции-функции
			point1 operator + (point1& p);
	};
	// Внешнее определение компонентной операции-функции:
	point1 point1 :: operator + (point1 &p) 
	{	point1 d;
		d.x = this -> x + p.x;	d.y = this -> y + p.y;
		return d;
	}
	void main()
	{	init();
		// Создаются невидимые точки - объекты
		point1 A(200, 50), D(50, 120);
		// Точка с умалчиваемыми координатами (0, 0)
		point1 B;
		// Показать на экране точку
		A.show(); getch();		// A(200, 50)
		B.show(); getch();		// B(0, 0)
		D.show(); getch();		// D(50, 120)
		// Неявное обращение к операции-функции
		B = A + D;
		B.show(); getch();		// B(250, 170)
		// Явный вызов операции-функции
		B = A.operator + (B);
		B.show(); getch();		// B(450, 220)
		closegraph();
	}
</pre>
<p><center>В результате выполнения программы выводятся последовательно точки:
<br>A(200, 50); B(0, 0); D(50, 120); B(250, 170); B(450,220)</center>
<p>Если операция-функция определена как принадлежащая классу, то вызвать ее явно можно 
с использованием имени объекта или указателя на объект и операции выбора компонентов 
(-> или .). <br>То есть в этом случае вызов операции-функции подобен вызову обычной 
компонентной функции класса.
<pre>
	point1 *ptr = &A;		// Указатель "настроен" на объект A класса point1
	В = ptr -> operator + (D);	// Операция + выполняется, как A + D
</pre>
<p>Рассмотрим программу, результатом работы которой является вывод на экран десяти 
наклонных линий. В ней рассматривается перегрузка унарной операции ++ и бинарной 
операции -. <br>Если учесть, что выражение my_point - Point(60, 110); возвращает значение 
типа Point, то можно использовать вычитание последовательно с несколькими 
операндами: <br><center>my_point = my_point - Point(60, 110) - Point(20, 10);</center>
<pre>
	#include&lt;iostream.h>
	#include&lt;graphics.h>
	#include&lt;conio.h>
	#include&lt;stdio.h>
	#include&lt;stdlib.h>
	#include"..\\h\\init.h"
	class Point
	{	int x, y;
		public:	Point(int InitX, int InitY)
			{ x = InitX; y = InitY; }
			Point operator++(void)
			{ return Point(x++, y++); }
			Point operator - (Point my_p)
			{ return Point(x - my_p.x, y - my_p.y); }
			void put_point(void)
			{ putpixel(x, y, 1); }
	};
	void main(void)
	{	
		init();
		Point my_point(10, 200);
		for(int j = 0; j < 10; j++)
		{	for(int i =0 ; i < 100; i++)
			{
				++my_point;
				my_point.put_point();
			}
			my_point = my_point - Point(60, 110);
		}
		cout << "Нажмите любую клавишу";
		getch(); closegraph();
	}
</pre>
<p>Имеется <b><i>возможность перегрузить оператор относительно класса так,
что правый операнд будет объектом базового типа</i></b>, например, целого, а не объектом того класса,
членом которого является операция функция.
<pre>
	// Перегрузка оператора + как для операции ob + ob,
	// так и для операции ob + int
	#include&lt;iostream.h>
	#include&lt;conio.h>
	class coord
	{	int x, y;	// значения координат
		public:
			coord() { x = 0; y= 0; }
			coord(int i, int j) { x = i; y = j; }
			void get_xy(int &i, int &j) { i = x; j = y; }
			coord operator + (coord ob2);	// ob + ob
			coord operator + (int i);		// ob + int
	};
	// Перегрузка оператора + относительно класса coord
	coord coord :: operator + (coord ob2)
	{	coord temp;
		temp.x = x + ob2.x;
		temp.y = y + ob2.y;
		return temp;
	}
	// Перегрузка оператора + для операции ob + int
	coord coord :: operator + (int i)
	{	coord temp;
		temp.x = x + i;
		temp.y = y + i;
		return temp;
	}
	int main()
	{	coord o1(10, 10), o2(5, 3), o3;
		int x, y; clrscr();

		// сложение двух объектов вызов функции operator + (coord)
		o3 = o1 + o2; o3.get_xy(x, y);
		cout << "(o1 + o2) X: " << x << ", Y: " << y << "\n";
		
		// сложение объекта и целого вызов функции operator + (int)
		o3 = o1 + 100; o3.get_xy(x, y);
		cout << "(o1 + 100) X: " << x << ", Y: " << y << "\n";
		getch(); return 0;
	}
	
	<i>Результат выполнения программы:</i>	(o1 + o2)&nbsp;&nbsp; X:&nbsp; &nbsp;15, Y: &nbsp;&nbsp;13
						(o1 + 100) X: 110, Y: 110

</pre>
<p><b><i>Отметим особенности оформления операции-функции в виде дружественной функции 
класса.</i></b><br>Выполним перегрузку унарной операции минус <b>-</b> (поменять знак числа).
<br>Введем класс "радиус-вектор N-мерного пространства" и определим для него
операцию-функцию, изменяющую направление вектора на противоположное.
<pre>
	#include&lt;iostream.h&gt;
	#include&lt;conio.h&gt;
	class vector				// Класс "радиус-вектор"
	{	int N;				// Размерность пространства
		double *x;			// Указатель на массив координат
		friend vector& operator - (vector &) ;	// Прототип операции-функции
		public:	vector (int n, double *xn)	// Конструктор
			{ N = n; x = xn; }
			void display();		// Компонентная функция печати вектора
	};
	void vector <b>::</b> display()			// Определение компонентной функции
	{	cout << "\nКоординаты вектора:";
		for (int i = 0; i < N; i++) 
			cout << "\t" << x[i];
	}
	vector& operator - (vector & v) 		// Определение операции-функции
	{	for (int i = 0; i < v.N; i++) 
			v.x[i] = -v.x[i];
		return v;
	}
	void main()				// Иллюстрирующая программа
	{	double A[] = { 1.0, 2.0, 3.0, 4.0 };	// Определяем массив:
		vector V(4, A);			// Создан объект класса vector
		clrscr(); V.display();		// Вывод на экран
		V = -V;				// Перегруженная операция
		V.display(); getch();		// Вывод на экран
	}
	
	<i>Результат выполнения программы:</i>	Координаты вектора:&nbsp; &nbsp; 1 &nbsp; 2 &nbsp; 3 &nbsp;4
						Координаты вектора: &nbsp; -1 -2 -3 -4
</pre>
<p><b><i>Рассмотрим перегрузку оператора индекса массива</i> [ ].</b>
<br>Оператор [ ] можно перегружать только как функцию - член класса, операция-функция которой имеет следующую форму:
<pre>
			тип имя_класса :: operator [ ] (int индекс)
			{ операторы_тела_операции-функции }
</pre>
<p>Перегрузка оператора [ ] позволяет, например, обеспечивать контроль границ массива.
Рассмотрим пример безопасного массива с контролем границ массива, что позволяет
при нарушении границ генерировать соответствующее сообщение и завершать программу
еще до того, как будет повреждена какая-либо ячейка памяти.
<pre>
	#include&lt;iostream.h>
	#include&lt;conio.h>
	#include&lt;stdlib.h>
	const int SIZE = 5;
	class arraytype
	{	int a[SIZE];
		public:
			arraytype();
			int &operator[] (int i);
	};
	// Конструктор
	arraytype :: arraytype()
	{	int i;
		for (i = 0; i < SIZE; i++)
			a[i] = i;
	}
	// Обеспечение контроля границ для массива типа arraytype
	int &arraytype :: operator[] (int i)
	{	if(i < 0 || i > SIZE - 1)
		{	cout << "\nЗначение индекса ";
			cout << i << " находится за пределами границ массива \n";
			exit(1);
		}
		return a[i];
	}
	int main()
	{	clrscr();
		arraytype ob;
		int i;
		// Здесь проблем нет
		for(i = 0; i < SIZE; i++)
			cout << ob[i] << " ";
		// А здесь при выполнении программы генерируется ошибка, поскольку 
		// значение SIZE + 100 не входит в заданный диапазон
		ob[SIZE + 100] = 99;		// Ошибка !!!
		getch(); return 0;
	}

	<i>Результат выполнения программы:</i>
			0 1 2 3 4
			Значение индекса 105 находится за пределами границ массива
</pre>
<p>Безопасный массив увеличивает расход ресурсов, что не во всех ситуациях может оказаться приемлемым.
Именно из-за непроизводительного расхода ресурсов в C++ отсутствует встроенный контроль границ массивов.
Тем не менее, в тех приложениях, в которых желательно обеспечить целостность границ, реализация безопасного массива будет лучшим решением.
<p> &nbsp; </p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=a>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>