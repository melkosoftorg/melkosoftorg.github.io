<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | Лекция № 44</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=a>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr>
<td class=usual>
<p align=center class=dbi><br>Дружественные функции</p>
В языке C++ существует возможность доступа к компонентам класса с атрибутом private 
из функций, не являющихся компонентами этого класса. Ее обеспечивают дружественные 
функции. <p>По определению, <b><i>дружественной функцией класса называется функция, 
которая, не являясь его компонентом, имеет доступ к его защищенным и 
собственным компонентам</i></b>. <p>Функция не может стать другом класса "без его согласия". 
<br>Для получения прав друга функция должна быть описана в теле класса со 
спецификатором <b><i>friend</i></b>, что предоставляет функции права доступа к защищенным и 
собственным компонентам.
<pre>
	#include&lt;conio.h&gt;
	class charlocus		// Класс - "символ в заданной позиции экрана":
	{	int x, y;		// Координаты знакоместа на экране дисплея
		char cc;		// Значение символа, связанного со знакоместом
		// Прототип дружественной функции для замены символа:
		friend void friend_put (charlocus *, char);
		public:
			charlocus(int xi, int yi, char ci)		// Конструктор
			{ x = xi; y = yi; cc = ci; }
			void display (void)			// Вывести символ на экран
			{ gotoxy(x, y); putch(cc); }
	};
	// Дружественная функция замены символа в конкретном объекте
	void friend_put(charlocus *p, char c)
	{ p -> cc = c; }
	void main (void)
	{	charlocus D(20, 4, 'd');			// Создать объект D
		charlocus S(10, 10, 's');			// Создать объект S
		clrscr(); D.display(); getch(); S.display(); getch();
		// заменить символы объектов, что демонстрирует вывод на экран * и #
		friend_put(&D, '*'); D.display(); getch(); friend_put(&S, '#'); S.display(); getch();
	}
	
	<b><i>Программа последовательно выводит на экран</i></b>	d (в позицию 20, 4),
							s (в позицию 10, 10),
							* (в позицию 20, 4),
							# (в позицию 10, 10).
</pre>
<br>Функция friend_put() описана в классе charlocus как дружественная функция и определена 
как обычная глобальная функция (вне класса без указания его имени, без операции <b>::</b> и без 
спецификатора friend). Как дружественная, она получает доступ к собственным данным 
класса и изменяет значение символа того объекта, адрес которого будет передан ей как 
значение первого параметра.
<p><b><i>Дружественная функция при вызове не получает указателя this.</i></b> Объекты классов должны 
передаваться дружественной функции только явно через аппарат параметров. При вызове 
дружественной функции <b><i>нельзя использовать</i></b> операции выбора:
<pre>
	имя_объекта.имя_функции		и	укаэатель_на_объект -> имя_функции
</pre>
поскольку дружественная функция не является компонентом класса, на нее не 
распространяется и действие спецификаторов доступа (public, protected, private). Место 
размещения прототипа дружественной функции внутри определения класса безразлично. 
Права доступа дружественной функции не изменяются и не зависят от спецификаторов 
доступа.
<p>Итак, дружественная функция<ul>
<li>не может быть компонентной функцией того класса, по отношению к которому 
определяется как дружественная;
<p><li>может быть глобальной функцией (как в предыдущей программе):
<br> &nbsp;  &nbsp;  &nbsp;  &nbsp; class CL { friend int f1(...); ... };
<br> &nbsp;  &nbsp;  &nbsp;  &nbsp; int f1(...) { тело_функции }
<p><li>может быть компонентной функцией другого ранее определенного класса:
<br> &nbsp;  &nbsp;  &nbsp;  &nbsp; class CLASS { ... char f2(...); ... };
<br> &nbsp;  &nbsp;  &nbsp;  &nbsp; class CL { ... friend char CLASS::f2(...); ... };
<br>В примере класс CLASS с помощью своей компонентной функции f2() получает 
доступ к компонентам класса CL. Компонентная функция некоторого класса 
(CLASS) может быть объявлена дружественной функцией другому классу (CL), 
если только определение этого первого класса размещено раньше, чем определение 
второго (CL).
<p><li>может быть дружественной по отношению к нескольким классам:
<p> &nbsp;  &nbsp;  &nbsp;  &nbsp; // Предварительное неполное определение класса
<br> &nbsp;  &nbsp;  &nbsp;  &nbsp; class CL2;
<br> &nbsp;  &nbsp;  &nbsp;  &nbsp; class CL1 { friend void ff(CL1,CL2); ... };
<br> &nbsp;  &nbsp;  &nbsp;  &nbsp; class CL2 { friend void ff(CL1,CL2); ... };
<br> &nbsp;  &nbsp;  &nbsp;  &nbsp; void ff(...) { тело функции }
</ul>
<br>Использование механизма дружественных функций позволяет упростить интерфейс 
между классами. Например, дружественная функция позволит получить доступ к 
собственным или защищенным компонентам сразу нескольких классов. Тем самым из 
классов можно иногда убрать компонентные функции, предназначенные только для 
доступа к этим "скрытым" компонентам.
<p> &nbsp; </p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=a>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>