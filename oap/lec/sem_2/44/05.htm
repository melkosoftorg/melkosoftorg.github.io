<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | Лекция № 44</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=a>&nbsp 5 &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr>
<td class=usual>
<p align=center class=dbi><br>Особенности использования перегрузки</p>
<p><center>Существует несколько операций, не допускающих перегрузки: 
<P><table border=0 cellpadding=2>
<tr><td><b>.</b>
</td><td> - </td><td> прямой выбор компонента структурированного объекта,
</td></tr>
<tr><td>  <b>.*</b>
</td><td> - </td><td> обращение к компоненту через указатель на него,
</td></tr>
<tr><td>  <b>?:</b>
</td><td> - </td><td> условная операция,
</td></tr>
<tr><td>  <b>::</b>
</td><td> - </td><td> операция указания области видимости,
</td></tr>
<tr><td>  <b>sizeof</b>
</td><td> - </td><td> операция вычисления размера в байтах,
</td></tr>
<tr><td>  <b>#</b>
</td><td> - </td><td> препроцессорная операция,
</td></tr>
<tr><td>  <b>##</b>
</td><td> - </td><td> препроцессорная операция.
</td></tr>
</table></center>
<p>При расширении действия (при перегрузке) стандартных операций нельзя и нет 
возможности изменять их приоритеты (иначе компилятор окончательно запутается).
<br>Нельзя изменить для перегруженных операций синтаксис выражений, то есть невозможно 
ввести унарную операцию = или бинарную операцию ++.
<br>Нельзя вводить новые лексические обозначения операций, даже формируя их из 
допустимых символов. Например, возведение в степень ** из языка Фортран нельзя 
ввести в языке C++.
<p><b><i>Любая бинарная операция @</i></b> определяется для объектов класса двумя разными способами:<ul>
<li>либо как компонентная функция с одним параметром.
<br> &nbsp; &nbsp; &nbsp; х @ y означает вызов х<b>.</b>operator @(y),
<p><li>либо как глобальная (возможно дружественная) функция с двумя параметрами.
<br> &nbsp; &nbsp; &nbsp; х @ y означает вызов operator @(x, y).
<br>Операции-функции с названиями operator =, operator [], operator -> не могут быть 
глобальными функциями, а должны быть нестатическими компонентными функциями.
</ul>
<p><b><i>Любая унарная операция $</i></b> определяется для объектов класса также двумя способами:<ul>
<li>либо как компонентная функция без параметров,
<p><li>либо как глобальная (возможно дружественная) функция с одним параметром.
<br>Для префиксной операции $ выражение $z означает вызов компонентной функции 
z<b>.</b>operator $() или вызов глобальной функции operator $(z).
<br>Для постфиксной операции выражение z$ означает либо вызов компонентной функции 
z<b>.</b>operator $(), либо вызов глобальной функции operator $(z).</ul>
<p><b>В начальных версиях языка C++</b> при перегрузках операций ++ и -- не делалось различия 
между постфиксной и префиксной формами. <br>Например, в примере действие операции ++ 
распространено на объекты класса pair с помощью дружественной операции-функции с 
одним параметром: &nbsp; friend pair& operator ++(pair &);
<br>Операция -- перегружена с помощью компонентной операции-функции класса pair, не 
имеющей параметров: &nbsp; pair& pair <b>::</b> operator -- ();
<pre>
	#include&lt;iostream.h&gt;
	#include&lt;conio.h&gt;
	class pair				// Класс "пара чисел":
	{	int N;				// Целое число
		double x;			// Вещественное число
		friend pair& operator ++(pair &);	// Дружественная функция:
		public:	pair (int n, double xn)	// Конструктор
			{ N = n; x = xn; }
			void display()
			{ cout << "\nКоординаты: N = " << N << "\tx = " << x; }
			pair& operator --()		// Компонентная функция
			{ N -= 1; x -= 1.0; return *this; }
	};
	pair& operator ++(pair& P)			// Дружественная функция
	{ P<b>.</b>N += 1; P<b>.</b>x += 1.0; return P; }
	void main()
	{	
		pair Z(10, 20.0); clrscr();
		Z<b>.</b>display(); ++Z; Z<b>.</b>display(); --Z; Z<b>.</b>display(); Z++; Z<b>.</b>display();
		Z--; Z<b>.</b>display(); getch();
	}
	
	<i>Результат выполнения программы:</i>	Координаты: N = 10	х = 20
						Координаты: N = 11	х = 21
						Координаты: N = 10	х = 20
						Координаты: N = 11	х = 21
						Координаты: М = 10	х = 20
</pre>
<p><b>В современной версии языка C++</b> принято соглашение, что перегрузка префиксных 
операций ++ и -- ничем не отличается от перегрузки других унарных операций, то есть 
глобальные и, возможно, дружественные функции operator ++() и operator --() с одним 
параметром некоторого класса определяют префиксные операции ++ и --. <br>Компонентные 
операции-функции без параметров определяют те же префиксные операции. <p>При 
расширении действия постфиксных операций ++ и -- операции-функции должны иметь 
еще один дополнительный параметр типа int. <br>Если для перегрузки используется 
компонентная операция-функция, то она должна иметь один параметр типа int. <br>Если 
операция-функция определена как глобальная (не компонентная), то ее первый параметр 
должен иметь тип класса, а второй - тип int.
<br>Когда в программе используется соответствующее постфиксное выражение, то операция-функция вызывается с нулевым целым параметром.
<pre>
	// для BC++ 3.1 и выше - необычная перегрузка унарных операций ++, --
	#include&lt;iostream.h&gt;
	class pair				// Класс "пара чисел":
	{	int N;				// Целое число
		double x;			// Вещественное число
		// Дружественная функция для префиксной операции
		friend pair& operator ++(pair&);
		// Дружественная функция для постфиксной операции
		friend pair& operator ++(pair&,int);
		public:	pair (int n, double xn)	// Конструктор
			{ N = n; x = xn; }
			void display()
			{ cout << "\nКоординаты: N = " << N << " x = " << x; }
			pair& operator --()		// Компонентная функция (префиксная --):
			{ N /= 10; x /= 10; return *this; }
			pair& operator --(int k) 	// Компонентная функция (постфиксная --):
			{ N /= 2; x /= 2.0; return *this; }
	};
	pair& operator ++(pair& P)			// Префиксная операция ++
	{ P<b>.</b>N *= 10; P<b>.</b>x *= 10; return P; }
	pair& operator ++(pair& P, int k) 		// Постфиксная операция ++:
	{ P<b>.</b>N = P<b>.</b>N * 2 + k; P<b>.</b>x = P<b>.</b>x * 2 + k; return P; }
	void main()
	{	pair Z(10, 20.0); Z<b>.</b>display();
		++Z; Z<b>.</b>display(); --Z; Z<b>.</b>display();
		Z++; Z<b>.</b>display(); Z--; Z<b>.</b>display();
	}
	
	<b><i>Результаты выполнения программы:</i></b>	Координаты: N = 10	х = 20
						Координаты: N = 100	x = 200
						Координаты: N = 10	х = 20
						Координаты: N = 20	х = 40
						Координаты: N = 10	х = 20
</pre>
<p>Для демонстрации полной независимости смысла перегруженной операции от ее 
традиционного (стандартного) значения в операциях-функциях для префиксных операций 
++ соответствуют увеличению в 10 раз, а -- уменьшению в 10 раз. <br>Для постфиксных 
операций ++ определили как увеличение в 2 раза, а -- как уменьшение в 2 раза. <br>Попытки 
использовать в постфиксных операциях-функциях значение дополнительного параметра 
<br>int k подтверждает его равенство 0.
<p> &nbsp; </p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=a>&nbsp 5 &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>