<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | СР 21</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr><td class=usual><p align=center class=dbi><br>Указатели на функции</p>
<p>Указатели на функции - это одно из дополнительных средств вызова функции.
При выполнении программы код каждой ее функции располагается в памяти по определенному адресу.
Указатель на функцию содержит начальный адрес функции - ее точку входа.
С помощью указателей программа может выбрать вызов одной из нескольких функций по какому-либо критерию или условию.
<p align=center class=dbi><br>Объявление указателя на функцию</p>
<p>Как и любая другая переменная, указатель на функцию должен быть объявлен, чтобы его можно было использовать.
<br>Общая форма объявления следующая:
<p align=center><b>тип (*имя_указателя) (список_параметров);</b></p>
<p>Скобки вокруг имени указателя обязательны, поскольку приоритет операции <b>*</b> сравнительно низок -
ниже, чем скобок со списком параметров.
Поэтому оператор без скобок вокруг имени указателя является объявлением функции,
возвращающей указатель типа int, а не объявлением указателя на функцию.
<p>Например, объявления указателей на функцию:
<pre>
	// указатель на функцию, принимающую один аргумент типа int и возвращающую значения того же типа
	int (*func1) (int x);
			
	// указатель на функцию с двумя аргументами типа double и возвращаемым значением типа void
	void (*func2) (double y, double z);
	
	// указатель на функцию, принимающую массив указателей типа char и возвращающую значение типа char
	char (*func3) (char *ptr[]);
		
	// указатель на функцию без аргументов и с пустым типом (void) возвращаемого значения
	void (*func4) ();			
</pre>
<p align=center class=dbi>Инициализация и использование указателя на функцию</p>
<p>Чтобы указатель действительно указывал на что-то, его необходимо не только объявить, но еще и инициализировать.
При этом должно строго соблюдаться соответствие возвращаемого типа и списка параметров функции.
<p>Следующий пример иллюстрирует:
<ul>
<li type="disc">определение функции,
<li type="disc">объявление и инициализацию указателя, имеющего совпадающие с функцией списки параметров и типы возвращаемый значений,
<li type="disc">вызов функции и вызов функции с использованием указателя.
</ul>
<pre>
	// вызов функции по указателю
	#include&lt;stdio.h&gt;
	#include&lt;conio.h&gt;
	// определение функции
	double square(double x)
	{
		return x * x;
	}
	// объявление указателя на функцию
	double (*ptr)(double x);

	void main(void)
	{
		clrscr();
		// инициализация указателя на функцию ptr адресом функции square()
		ptr = square;
		// вызов функции square() двумя способами
		printf("%f%f", square(1.1), ptr(1.1));
		getch();
	}

	<i>Результаты:</i></b>	1.210000	1.210000
</pre>
<p>Имя функции без скобок является указателем на функцию, на константу, которую нельзя изменить.
В противоположность этому, указатель является переменной, значение которой можно изменить.
В разные моменты времени такая переменная может указывать на разные функции, если это будет необходимо.
<p>Рассмотрим программу, иллюстрирующую возможность инициализации указателя значением адреса трех различных функций: one(), two(), other().
<pre>
	// использование указателя для вызова разных функций по обстоятельствам
	#include&lt;stdio.h&gt;
	#include&lt;conio.h&gt;
	// определение функций
	void two(void)
	{
		puts("нажали 2");
	}
	void one(void)
	{
		puts("нажали 1");
	}
	void other(void)
	{
		puts("нажали не 1 или 2");
	}
	void func1(int val)
	{
		// локальное объявление указателя на функцию
		void (*ptr) (void);
		// выбор одной из функций и помещение ее адреса в ptr
		if(val == 1)
			ptr = one;
		else if(val == 2)
			ptr = two;
		else
			ptr = other;
		// вызов ptr, то есть соответствующей функции через него
		ptr();
	}
	void main(void)
	{
		clrscr();
		int nbr;
		// бесконечный цикл, оканчивающийся на нажатие 0
		for(; ;)
		{	puts("0 - выход, любое целое - работа"); scanf("%d", &nbr);
			if(nbr == 0)
				break;
			func1(nbr);
		}
	}
	
        	<i>Результаты:</i></b>	0 - выход, любое целое - работа
			2
			нажали 2
			0 - выход, любое целое - работа
			-9
			нажали не 1 или 2
			0 - выход, любое целое - работа
			1
			нажали 1
			0 - выход, любое целое - работа
			0
</pre>
<p>Одна из задач, для которой указатели на функции могут оказаться полезными, - это сортировка.
Иногда в зависимости от ситуации приходится применять сортировку по различным правилам,
как показано в следующей программе:
<ul>
<li type="disc">по алфавиту,
<li type="disc">в порядке, обратном алфавитному.
</ul>
<p>С помощью указателей программа сможет корректно вызвать нужную функцию сортировки.
<pre>
	// управление порядком сортировки с помощью указателей на функции
	#include&lt;stdio.h&gt;
	#include&lt;stdlib.h&gt;
	#include&lt;string.h&gt;
	#include&lt;conio.h&gt;
	#define MAXLIN	25
	char *lin[MAXLIN];
	// определение функций
	int get_lin(char *lin[])
	{
		int n = 0;
		char buff[80];		// временное хранилище для строк
		puts("Для окончания ввода Enter в начале строки");
		while(n < MAXLIN && gets(buff) != 0 && buff[0] != '\0')
		{
			if((lin[n] = (char*) malloc(strlen(buff) + 1)) == NULL)
        			return -1;
			strcpy(lin[n++], buff);
		}
		return n;
	}
	// сравнение в алфавитном порядка
	int alpha(char *p1, char *p2)
	{
		return(strcmp(p2, p1));
	}
	// сравнение в порядке, обратном алфавитному
	int reverse(char *p1, char *p2)
	{
		return(strcmp(p1, p2));
	}
	void sort(char *p[], int n, int sort_type)
	{
		int a, b; char *x;
		// указатель на функцию, принимающую два указателя на строки в качестве аргументов
		int (*comp) (char *s1, char *s2);
		// присваивание указателю адреса функции сравнения в зависимости от аргумента sort_type
		comp = (sort_type) ? reverse : alpha;
		for(a = 1; a < n; a++)
		{	for(b = 0; b < n - 1; b++)
			{	if(comp(p[b], p[b + 1]) > 0)
				{	x = p[b];
					p[b] = p[b + 1];
					p[b + 1] = x;
				}
			}
		}
	}
	// вывод на экран
	void print_str(char *p[], int n)
	{
		int count;
		for(count = 0; count < n; count++)
			printf("%s\n", p[count]);
	}
	void main(void)
	{
		clrscr();
		int num_of_lin, sort_type;
		// чтение строк с клавиатуры
		num_of_lin = get_lin(lin);
		if(num_of_lin < 0)
		{	puts("Ошибка, проблемы с памятью");
			exit(-1);
		}
		puts("0 - в порядке, обратном алфавитному, 1 - в алфавитном порядка");
		scanf("%d", &sort_type);
		sort(lin, num_of_lin, sort_type);
		print_str(lin, num_of_lin);
	}
        
	<i>Результаты:</i></b>	Для окончания ввода Enter в начале строки                   
			Red                                                         
			Black                                                       
			Brown                                                       
			Yellow                                                      
			Cyan                                                        
			                                                    
			0 - в порядке, обратном алфавитному, 1 - в алфавитном порядке
			1                                                           
			Black                                                       
			Brown                                                       
			Cyan                                                        
			Red                                                         
			Yellow                                                      
</pre>
<p>&nbsp;</p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
</tr>
</table>
<a name=#end></a>
</body>
</html>