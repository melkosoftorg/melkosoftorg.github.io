<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | Лекция № 47</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr><td class=usual>
<p> &nbsp; </p><a name="01"></a>
<p align=center class=dbi><br>Прерывания</p>
<p><b><i>int86</i></b> - выполняет прерывания от математического обеспечения микропроцессора 8086
<br><b><i>int86x</i></b> - поддерживает прерывания математического обеспечения микропроцессора 8086. 
<p><b><i>Синтаксис</i></b> int int86(int intr_num, union REGS *inregs, union REGS *outregs);
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int int86x(int intr_num, union REGS *inregs, union REGS * outregs, strust SREGS *segregs);
<p>Тип прерывания определяется аргументом intr_num.
<br>Перед выполнением прерывания математического обеспечения, функции копируют значения регистров из параметра inregs в сами регистры. 
<br>int86x также перед выполнением прерывания программного обеспечения копирует значения параметров segregs-->x.ds и segregs-->x.es в соответствующие регистры, что позволяет программам, использующим 
"дальние" указатели (указатели с атрибутом "far") или большие модели памяти - определять, какой сегмент обрабатывается в момент данного программного прерывания.
<br>После возврата из прерывания, обе функции копируют текущие значения регистров в параметр outregs, а статус флажка системного переноса в поле x.cflag параметра outregs. 
<br>int86x к тому же восстанавливает регистр DS.
<br>Если флажок переноса установлен, это означает что произошла ошибка.
<br>int86 и int86x возвращают значение регистра AX после выхода из прерывания. 
<br>Если флажок переноса установлен (outregs-->x.cflag != 0) - произошла ошибка - функции присваивают глобальной переменной _doserrno код ошибки.
<p> &nbsp; </p><a name="02"></a>
<p><b><i>intdos</i></b> - поддерживает прерывания MS-DOS
<br><b><i>intdosx</i></b> - поддерживает прерывания MS-DOS
<p><b><i>Синтаксис</i></b>	int intdos(union REGS *inregs, union REGS *outregs);
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int intdosx(union REGS * inregs, union REGS *outregs, struct SREGS *segregs);
<p>Функции выполняют прерывание DOS 0x21 для запуска заданной функции DOS.
<br>Значение параметра inregs-->h.al определяет запускаемую функцию DOS.
<br>intdosx в дополнение к вышеописанному копирует значения параметров segregs-->x.ds и segregs-->x.es в соответствующие регистры перед вызовом функции DOS. 
<br>Это средство позволяет программам, использующим "дальние" указатели (указатели с атрибутом "far") или большие модели памяти, определять какой сегмент используется в процессе выполнения функции.
<br>После возврата из прерывания 0x21 обе функции копируют текущие значения регистров в параметр outregs, а статус флажка системного переноса в поле x.cflag параметра outregs. 
<br>К тому же intdosx восстанавливает регистр DS. 
<br>Если фдажок переноса имеет значение, отличное от 0, это означает, что произошла ошибка.
<br>intdosx позволяет вызывать функции DOS, которые принимают в качестве аргумента значение регистра DS, отличное от стандартного сегмента данных, или которые используют в качестве аргумента регистр ES.
<br>После завершения вызова подпрограммы DOS, intdos и intdosx возвращают значение регистра AX.
<br>Если флажок переноса установлен (outregs-->x.cflag != 0) - ошибку, переменная _doserrno получает в качестве значения код ошибки.
<p> &nbsp; </p><a name="03"></a>
<p><b><i>intr</i></b> - поддерживает альтернативный интерфейс для выполнения прерываний математического обеспечения микропроцессора 8086.
<br><b><i>Синтаксис</i></b>	void intr(int intr_num, struct REGPACK *preg);
<p>intr генерирует прерывание математического обеспечения микропроцессора 8086, заданное аргументом intr num.
<br>intr перед выполнением прерывания копирует значения регистров из структуры REGPACK *preg непосредственно в регистры. 
<br>После завершения прерывания функция intr копирует текущее значение регистров в параметр preg. 
<br>Значения флажков остаются законсервированными.
<br>Функции intr передаются параметры:
<ul><li>intr num - номер выполняемого прерывания;
<li>preg - адрес структуры, содержащий:
<li>(a) - входные регистры перед вызовом;
<li>(b) - значения регистров после вызова прерывания.</ul>
<p>Структура REGPACK *preg (описанная в файле dos.h) имеет формат:
<pre>		struct REGPACK
		{
			unsigned r_ax, r_bx, r_cx, r_dx;
			unsigned r_bp, r_si, r_di, r_ds, r_es, r_flags;
		}
</pre>
<p>Никакое значение не возвращается, REGPACK *streg содержит значения регистров после вызова прерывания.
<p> &nbsp; </p><a name="04"></a>
<p><b><i>getvect</i></b> - получает содержимое вектора прерывания.
<br><b><i>Синтаксис</i></b>	void interrupt(*getvect(int intr_num))();
<p>getvect считывает значение вектора с именем intr_num и интерпретирует прочитанное значение, как "дальний" указатель (с атрибутом "far") на некоторую функцию прерывания.
<br>getvect возвращает 4-х байтовое значение, хранящееся в векторе прерывания с именем intr_num. 
<p> &nbsp; </p><a name="05"></a>
<p><b><i>disable</i></b> - делает прерывания невозможными
<br><b><i>enable</i></b> - разрешает прерывания
<br><b><i>geninterrupt</i></b> - генерирует прерывание программного обеспечения
<p><b><i>Синтаксис</i></b>	void disable(void);
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; void enable(void); 
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; void geninterrupt(int intr_num);
<p>Данные макрокоманды разработаны с целью обеспечения программистов гибким средством контроля над прерываниями на физическом уровне.
<br>disable делает прерывания невозможными. Разрешено только прерывание NMI с внешнего устройства. 
<br>enable разрешает прерывания, при этом могут возникать прерывания с любых устройств.
<br>geninterrupt запускает программное обеспечение для обработки непредвиденных ситуаций, в частности для прерываний, поставляемых аргументом intr_num.
<br>disable и enable не имеют возвращаемого значения. 
<br>Для geninterrupt возвращаемое значение зависит от типа вызванного прерывания.
<p> &nbsp; </p><a name="06"></a>
<p><b><i>getcbrk</i></b> - получает параметры контроля над прерываниями.
<br><b><i>Синтаксис</i></b>	int getcbrk(void);
<p>getcbrk использует системный вызов MS-DOS 0x33 для получения текущих параметров контроля над прерываниями.
<br>getcbrk возвращает 0 если контроль над прерываниями выключен (off), и 1, если контроль включен (on).
<p> &nbsp; </p><a name="07"></a>
<p><b><i>segread</i></b> - считывает значения сегментных регистров
<br><b><i>Синтаксис</i></b>	void segread(struct SREGS *segtbl);
<p>segread помещает текущие значения сегментных регистров, хранимых в SEGREGS в структуру, адресуемую указателем segtbl.
<br>Данный вызов использовать совместно с функциями intdosx и int86x.
<p> &nbsp; </p><a name="08"></a>
<p><b><i>getpsp</i></b> - получает адрес префикса программного сегмента.
<br><b><i>Синтаксис</i></b>	unsigned getpsp(void);
<p>getpsp получает адрес префикса программного сегмента (PSP) посредством системного вызова DOS 0x62. устанавливаемую с помощью кода запуска.
<br>getpsp возвращает адрес сегмента
<p> &nbsp; </p><a name="09"></a>
<p><b><i>environ</i></b> - массив из символьных строк
<br><b><i>Синтаксис</i></b>	extern char * environ[ ];
<p>environ является массивом из символьных строк, используется для доступа и изменения среды процесса. 
<br>Каждая строка массива имеет форму: envvar = varvalue, где envvar - это имя переменной, идентифицирующей операционную среду (такой как PATH), 
<br>varvalue - это строковое значение, которое присваивается переменной envvar (такое как C:\BIN;C:\DOS). 
<br>Строка varvalue может быть пустой.
<br>Когда программа начинает выполняться, атрибуты операционной среды MS-DOS передаются непосредственно в программу. 
<br>envp, третий аргумент функции main, равен первоначальному значению переменной environ.
<br>Массив environ может использоваться функцией getenv.
<p> &nbsp; </p><a name="10"></a>
<p align=center class=dbi><br>Работа с диском</p>
<p><b><i>absread</i></b> - читает данные
<br><b><i>abswrite</i></b> - записывает данные 
<p><b><i>Синтаксис</i></b>	int absread(int drive, int nsects, int sectno, void * buffer); void * buffer);
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int abswrite(int drive, int nsects, int sectno, void * buffer);
<p>Функции считывают и записывают заданные сектора диска, игнорируют логическую структуру диска и не обращают внимание на файлы, блоки FAT или директории.
<br>absread читает заданные сектора диска посредством прерывания системы DOS 0x.25.
<br>abswrite записывает с помощью прерывания системы DOS 0x.26.
<ul><li>drive = номер дисковода (0 = А, 1 = В, и так далее)
<li>nsects = количество читаемых секторов
<li>sectno = начальный логический номер сектора
<li>buffer = адрес памяти, по которому считываются или записываются данные.</ul>
<p>Количество считываемых секторов ограничено суммарным размером сегмента, расположенного выше адреса buffer. 64 К - максимальный размер области памяти, который может быть обработан за один вызов функций absread или abswrite.
<br>При успешном завершении, обе процедуры возвращают нулевое значение.
<br>При возникновении ошибки, процедуры возвращают значение -1 и присваивают переменной errno значение регистра AX, получаемое при системном вызове.
<p> &nbsp; </p><a name="11"></a>
<p><b><i>randbrd</i></b> - читает блок произвольной длины
<br><b><i>randbwr</i></b> - записывает на диск произвольный блок
<p><b><i>Синтаксис</i></b>	int randbrd(struct fcb *fcbptr, int recent);
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int randbwr(struct fcb *fcbptr, int recent);
<p>randbrd считывает количество записей recent, используя блок FCB, адресуемый указателем fcbptr. Записи считываются в память по текущему адресу DTA. Записи считываются с диска, информация берется из поля random record блока FCB. Эта операция выполняется с помощью системного вызова DOS 0x27.
<br>randbwr выполняет почти те же самые действия, что и randbrd, за исключением того, что данные записываются на диск, вместо того, чтобы считываться с диска. Эта операция выполняется с помощью вызова DOS 0x28. Если reccnt=0, файл усекается до длины, указанной в поле random record блока FCB.
<br>Действительное число записей считываемое или записываемое может быть определено с помощью анализа поля random record блока FCB. 
<br>Данное поле после операции будет заполнено информацией о числе действительно записанных или прочитанных записей.
<br>randbrd или randbwr возвращают следующие значения:
<ul><li>0 - все записи прочитаны или записаны,
<li>1 - достигнут конец файла (EOF) и последняя запись прочитана посностью,
<li>2 - считанные записи будут располагаться рядом с адресом 0xFFFF (прочитано записей столько, сколько возможно).
<li>3 - достигунт конец файла и последняя запись обработана не полностью.</ul>
<p>randbwr возвращает 1, если для записи на диск информации не хватает памяти (нет записанных записей).
<p> &nbsp; </p><a name="12"></a>
<p><b><i>getdta</i></b> - получает адрес DTA (рабочего буфера обмена с диском)
<br><b><i>setdta</i></b> - устанавливает адрес DTA. 
<p><b><i>Синтаксис</i></b>	char far * getdta(void);
<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; void setdta(char far * dta);
<p>getdta возвращает текущее значение адреса DTA. 
<br>В малых и средних моделях памяти предполагается, что сегментом является текущий сегмент данных. 
<br>В компактных, больших и сверхбольших моделях памяти адрес, возвращаемый функцией getdta, является реально любым адресом и может быть расположен за пределами программы.
<br>setdta изменяет текущее значение DTA на значение адресного указателя dta.
<br>getdta возвращает указатель на текущий адрес DTA.<br>setdta не возвращает ничего.
<p> &nbsp; </p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>