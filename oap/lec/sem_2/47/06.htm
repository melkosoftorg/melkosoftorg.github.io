<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | Лекция № 47</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=a>&nbsp 6 &nbsp</a></td>
<td><a href="07.htm" class=p>&nbsp 7 &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr><td class=usual>
<p align=center class=dbi><br>Условная компиляция</p>
Рассмотрим директивы, которые управляют условной компиляцией. Они управляют препроцессорной обработкой и позволяют отменить компиляцию частей исходного файла посредством проверки константных выражений или идентификаторов, при которой определяется нужно ли передавать на выход или пропустить данную часть исходного файла на стадии препроцессирования.
<p><b>Команды, позволяющие выполнять проверку условий:</b>
<ul><li>#if целочисленное_константное_выражение
<li>#ifdef препроцессорный_идентификатор
<li>#ifndef препроцессорный_идентификатор</ul>
<p><b>Команды, позволяющие определить диапазон действия проверяемого условия:</b>
<ul><li>#else
<li>#endif</ul>
<p><b>Команда, позволяющая организовать мультиветвления</b> во время обработки препроцессором 
исходного текста программы
<ul><li>#elif константное_выражение</ul>
<p><b><center>Директивы #if, #elif, #else, #endif</center></b>
<p>Общая структура применения директив условной компиляции следующая:
<pre>
		#if целочисленное_константное_выражение
			текст_1
		#else 
			текст_2
		#endif
</pre>
<p>Конструкция #else текст_2 необязательна.
<br>Текст_1 включается в компилируемый текст программы только при истинности проверяемого условия.
<br>Если условие ложно и имеется директива #else, на компиляцию передается текст_2.
<br>Если директива #else и текст_2 отсутствуют, то при ложном условии весь текст от #if до #endif опускается, то есть не включается в компиляцию.
<p>Каждой директиве #if в исходном файле должна соответствовать закрывающая директива #endif. 
<br>Между директивами #if и #endif допускается нуль или более директив #elif и не более одной директивы #else. 
<br>Директива #else, если она есть, должна быть расположена непосредственно перед директивой #endif.
<p>Например, директивы #if, #endif управляют компиляцией одним из трех вызовов функций.
<br>Вызов функции credit() компилируется, если идентификатор CREDIT определен.
<br>Если определен идентификатор DEBIT, то компилируется функциональный вызов debit().
<br>Если ни один идентификатор не определен, то компилируется вызов printerror(). 
<br>Не забывайте, что CREDIT и credit - это различные идентификаторы в C++.
<pre>
		#if defined (CREDIT)
			credit();
		#elif defined (DEBIT)
			debit();
		#else
			printerror();
		#endif
</pre>
<p>Препроцессор выбирает отдельный участок текста на основе вычисления целочисленного_константного_выражения, следующего за #if или #elif директивой, пока не будет найдено выражение со значением истина (не нуль). 
<br>Выбирается текст, следующий за истинным константным выражением, до ближайшего знака номера #.
<br>Если  целочисленное_константное_выражение не истинно или отсутствует директива #elif, то препроцессор выбирает текст после записи #else.
<br>Если запись #else опущена, а выражение директивы #if ложно, то текст не выбирается.
<p>Ограниченное константное выражение не может содержать sizeof выражений, кастовых выражений, перечислимых констант, но может содержать специальные константные выражения defined (идентификатор). Это константное выражение истинно, если заданный идентификатор в текущий момент определен, в противном случае выражение ложно.
<br>Идентификатор, определенный как пустой текст, рассматривается как определенный.
<p>Директивы #if, #elif, #else, #endif могут быть вложенными. Каждая из вложенных директив #else, #elif, #endif принадлежит к ближайшей предшествующей директиве #if.
<p>В следующих примерах предполагается, что константа DLEVEL предварительно определена.
<br>Рассмотрим две последовательности вложенных #if, #else, #endif директив. 
<br>Первая последовательность директив обрабатывается, если DLEVEL > 5.
<br>В противном случае обрабатывается вторая последовательность.
<pre>
		#if DLEVEL > 5
			#define SIGNAL 1
			#if STACKUSE == 1
				#define STACK 200
			#else
				#define STACK 100
			#endif
		#else
			#define SIGNAL 0
			#if STACKUSE == 1
				#define STACK 100
			#else
				#define STACK 50
			#endif
		#endif
</pre>
<p>В следующем примере используются директивы #elif, #else, чтобы сделать один из четырех выборов, основанных на значении константы DLEVEL.
<br>Здесь определяется константа STACK равной 0, 100 или 200, в зависимости от значения DLEVEL. 
<br>Если DLEVEL > 5, то компилируется вызов функции display(debugptr), а константа STACK не определяется.
<pre>
		#if DLEVEL == 0
			#define STACK 0
		#elif DLEVEL == 1
			#define STACK 100
		#elif DLEVEL > 5
			display ( debugptr );
		#else
			#define STACK 200
		#endif
</pre>
<p>Рассмотрим использование директив препроцессора для управления объявлениями спецификатора регистровой памяти register в переносимом исходном файле.
<br>Если программа содержит больше объявлений переменных класа памяти register, чем может предоставить машина, то компилятор не объявит лишние переменные как регистровые. 
<pre>
		#define REG1 register
		#define REG2 register
		#if defined(M_86)
			#define REG3
			#define REG4
			#define REG5
		#else
			#define REG3 register
			#if defined(M_68000)
				#define REG4 register
				#define REG5 register
			#endif
		#endif
</pre>
<p>REG1 и REG2 определяются как ключевые слова register, чтобы объявить регистровую память для двух наиболее важных переменных в программе. Например, в следующем фрагменте переменные b и c имеют больший приоритет, чем a или d.
<pre>
		func(REG3 int a)
		{	REG1 int b;
			REG2 int c;
			REG4 int d;
			...
		}
</pre>
<p>Когда определен идентификатор М_86, препроцессор удаляет идентификаторы REG3 и REG4 из файла путем замены его на пустой текст. Регистровую память в этом случае получат переменные b и c.
<br>Когда определен идентификатор М_68000, то все четыре переменные объявляются с классом памяти register.
<br>Когда не определены оба идентификатора, то объявляются с регистровой памятью три переменные a, b и c.
<p><b><center>Директивы #ifdef и #ifndef
<p>#ifdef идентификатор<p>#ifndef идентификатор</center></b>
<p>Директивы #ifdef и #ifndef выполняют те же самые задачи, что и директива #if, использующая defined(идентификатор).
<br>Эти директивы могут быть использованы там же, где используется директива #if, и используются исключительно для компактности записи.
<p><b><i>В директиве #ifdef</i></b> идентификатор проверяется, определен ли с помощью директивы #define к текущему моменту идентификатор, помещенный после #ifdef.
<br>Если идентификатор определен, то есть является препроцессорным, то текст_1 используется компилятором.
<p><b><i>В директиве #ifndef</i></b> идентификатор проверяется обратное условие - истинным считается неопределенность идентификатора, то есть тот случай, когда идентификатор не был использован в команде #define или его определение было отменено командой #undef.
<p>Файлы, предназначенные для препроцессорного включения в программу, обычно снабжают защитой от повторного включения, которое может произойти, если несколько файлов, в каждом из которых, в свою очередь, запланировано препроцессорное включение одного и того же файла, объединяются в общий текст программы.
<br>Например, такими средствами защиты снабжены все заголовочные файлы стандартной библиотеки.
<p>Для созданного нами файла <a href="../42/05.htm#01">point.h</a> схема защиты от повторного включения может быть следующей:
<pre>
		#ifndef POINTH
			#define POINTH 1
		...	// Включаемый текст файла point.h
		#endif
</pre>
<p><b><center>Операция defined</center></b>
<p>При условной обработке текста операция defined используется только с директивами #if и #elif, позволяет установить, определен или не определен некоторый идентификатор. 
<br>Выражения вида &nbsp; <b>defined(идентификатор)</b> &nbsp; или &nbsp; <b>defined идентификатор</b> &nbsp; принимают единичное значение, если идентификатор определен (то есть он встречался в командах #define), и нулевое значение в противном случае.
<p>Таким образом, следующие директивы дают один и тот же результат:
<pre>
		#if defined A	эквивалентно	#ifdef A
		#if !defined A	эквивалентно	#ifndef A
</pre>
<p>Преимуществом оператора defined является возможность его использования в выражениях.
<p>Например, важный_текст должен быть передан компилятору только в том случае, если 
идентификатор Y определен как препроцессорный, а идентификатор N не определен. 
<br>Директивы препроцессора в этом случае могут быть следующими:
<pre>
		#if defined Y && !defined N
			важный_текст
		#endif
</pre>
<p> &nbsp; </p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=a>&nbsp 6 &nbsp</a></td>
<td><a href="07.htm" class=p>&nbsp 7 &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>