<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | Лекция № 47</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr><td class=usual>
<p align=center class=dbi><br>Работа на уровне BIOS</p>
<p><b><center>bios.h</center></b>
<p><center><table border=1 cellpadding=5>
<tr><td><b><center>Имя</center></b></td><td><b><center>Назначение</center></b></td></tr>
<tr><td><a href="#01">bioskey</a></td><td>интерфейс с клавиатурой при помощи функций BIOS</td></tr>
<tr><td><a href="#02">bioscom</a></td><td>коммуникации ввода/вывода</td></tr>
<tr><td><a href="#03">biosdisk</a></td><td>ввод/вывод с жестких/гибких дисков.</td></tr>
<tr><td><a href="#04">biosequip</a></td><td>проверяет оборудование</td></tr>
<tr><td><a href="#05">biosmemory</a></td><td>возвращает размер оперативной памяти.</td></tr>
<tr><td><a href="#06">biosprint</a></td><td>ввод/вывод на принтер.</td></tr>
<tr><td><a href="#07">biostime</a></td><td>возвращает значение времени дня.</td></tr>
</table></center><p> &nbsp; </p><a name="01"></a>
<p><b><i>bioskey</i></b> - интерфейс с клавиатурой при помощи функций BIOS
<br><b><i>Синтаксис</i></b>	int bioskey(int cmd);
<p>Описание bioskey посредством прерывания BIOS 0x16 выполняет различные операции клавиатуры. 
<br>Параметр cmd определяет операцию. Значение, возвращаемое функцией bioskey, зависит от выполняемой операции, которая определяется аргументом cmd.
<p><center><table width="90%" border=1 cellpadding=5>
<tr><td><b><center>cmd</center></b></td><td><b><center>Операция</center></b></td></tr>
<tr><td valign="top"><b><center>0</center></b></td><td>Возвращает код, получаемый в результате нажатия очередной клавиши на клавиатуре.
<br>Если младшие 8 битов не нулевые, это означает, что была  нажата клавиша, соответствующая коду ASCII.
<br>Если младшие 8 битов равны 0, то старшие 8 битов являются расширенными кодами клавиатуры, описание которых можно прочесть в документе: "Техническое справочное руководство по IBM PC".</td></tr>
<tr><td valign="top"><b><center>1</center></b></td><td>Производится проверка, имело ли место нажатие клавиши.
<br>Если при проверке возвращается значение 0 - клавиша не была нажата.
<br>В противном случае возвращается значение очередной нажатой  клавиши. Сам же код очередной нажатой клавиши сохраняется и будет возвращен при следующем вызове функции bioskey при значении параметра cmd, равном нулю.</td></tr>
<tr><td valign="top"><b><center>2</center></b></td><td>Запрашивает текущей статус клавиш типа SHIFT. Значение получается при логическом сложении следующих кодов (операции "ИЛИ"):
<ul>Бит &nbsp; 7 &nbsp; 0x80 &nbsp; INSERT &nbsp; нажат<br>Бит &nbsp; 6 &nbsp; 0x40 &nbsp; CAPS &nbsp; нажат<br>Бит &nbsp; 5 &nbsp; 0x20 &nbsp; NUM LOCK &nbsp; нажат
<br>Бит &nbsp; 4 &nbsp; 0x10 &nbsp; SCROLL LOCK &nbsp; нажат<br>Бит &nbsp; 3 &nbsp; 0x08 &nbsp; ALT &nbsp; нажат<br>Бит &nbsp; 2 &nbsp; 0x04 &nbsp; CTRL &nbsp; нажат<br>Бит &nbsp; 1 &nbsp; 0x02 &nbsp; LEFT SHIFT &nbsp; нажат<br>Бит &nbsp; 0 &nbsp; 0x01 &nbsp; RIGHT SHIFT &nbsp; нажат</ul>
</td></tr></table></center>
<pre>
 	// bioskey - выполняет операции с клавиатурой
 	#include&lt;stdio.h>
 	#include&lt;bios.h>
 	#include&lt;ctype.h>
 	#define RIGHT &nbsp; 0x0001
 	#define LEFT &nbsp; &nbsp; 0x0002
 	#define CTRL &nbsp; &nbsp; 0x0004
 	#define ALT &nbsp; &nbsp; &nbsp; 0x0008
 	main()
 	{	int key, modif,i; clrscr();
 		for (i = 1; i < 15; i++)
 		{ // функция 1 возвращает 0 пока не будет нажата клавиша - ожидание ввода
 			while(bioskey(1) == 0);
 			// функция 0 выдает значение клавиши
 			key = bioskey(0);
 			// функция 2 определяет, используются ли клавиши типа SHIFT
 			modif = bioskey(2);
 			if (modif)
 			{	printf("[");
 				if ( modif & RIGHT ) printf("RIGHT");
 				if ( modif & LEFT )  printf("LEFT");
 				if ( modif & CTRL )  printf("CTRL");
 				if ( modif & ALT )   printf("ALT");
				printf("] ");
			}
			// вывести символ нажатой клавиши
			printf("[");
			if (isascii ( key & 0xff )) printf ("%c", key);
			else printf ("%#0x",key);
			printf("]\n");
		} getch();
	}
</pre>
<p> &nbsp; </p><a name="02"></a>
<p><b><i>bioscom</i></b> - коммуникации ввода/вывода
<br><b><i>Синтаксис</i></b>	int bioscom(int cmd, char byte, int port);
<p>bioscom выполняет коммуникации RS232 через порт ввода / вывода, поставляемый параметром port.
<ul>port = 0 соответствует COM1,<br>port = 1 соответствetn COM2 и так далее.</ul>
<p>Значение переменной cmd может быть одно из следующих:
<ul><br>0 - устанавливает параметры коммуникаций для значения переменной  byte,<br>1 - пересылает символ (значение переменной byte) через линии коммуникации,<br>2 - получает символ с линий коммуникации,<br>3 - возвращает текущее состояние коммуникационного порта.</ul>
<p>Переменная byte может принимать значение, состоящее из комбинаций битов: 
<ul>0x02 - 7 битов данных, 0x20 - 150 бод,<br>0x03 - 8 битов данных, 0x40 - 300 бод,<br>0x00 - 1 стоповый бит, 0x60 - 600 бод,<br>0x04 - 2 стоповых бита, 0x80 - 1200 бод,<br>0x00 - нет проверки на четность, 0xA0 - 2400 бод,<br>0x08 - проверка на нечетность, 0xC0 - 4800 бод,<br>0x18 - проверка на четность, 0xE0 - 9600 бод.<br>0x00 - 110 бод,</ul>
<p>Например, переменная byte имеет значение 0xEB(0xE0|0x08|0x00|0x03).<br>Это устанавливает для коммуникационного порта скорость передачи 9600 бод, контроль на нечетность, 1 стоповый бит, и 8 информационных битов .
<p>Для всех значений параметра cmd значение, возвращаемое функцией, представляет собой шестнадцатибитовое целое число, где 8 старших битов - это биты состояния, а 8 младших битов - это изменяемая часть, зависящая от значения параметра cmd.
<p>Старшие биты в возвращаемом значении имеют характеристики:
<ul>бит 15 - простой,<br>бит 14 - передающий сдвиговый регистр пуст,<br>бит 13 - передающий регистр хранения пуст,<br>бит 12 - обнаружено прерывание,<br>бит 11 - ошибка формирования кадра синхронизации,<br>бит 10 - ошибка четности,<br>бит 9 - ошибка переполнения,<br>бит 8 - готовность данных.</ul>
<p>Если значение параметра cmd равно 1 и если установлен 15-ый бит, то значение параметра byte не может быть передано. Иначе, оставшиеся старшие и младшие биты устанавливаются соответствующим образом.
<br>Если переменная cmd имеет значение 2, переменная byte читается в младшие биты возвращаемого значения (если не было ошибки).
<br>Если произошла ошибка, устанавливается по крайней мерее один из старших битов.
<br>Если ни один из старших битов не был установлен, значит байт был принят без ошибки.
<br>Если переменная cmd имеет значение 0 или 3, возвращаемое значение имеет старшие биты, как они были определены выше, а младшие биты опреде ляются следующим образом:
<ul>бит 7 - обнаружен принятый линейный сигнал,<br>бит 6 - кольцевой индикатор,<br>бит 5 - набор данных готов,<br>бит 4 - готовность к передаче,
<br>бит 3 - детектор ошибки принимаемого линейного сигнала,<br>бит 2 - кольцевой детектор заднего фронта,<br>бит 1 - готовность набора данных ошибки,<br>бит 0 - готовность к передаче данных об ошибке.</ul>
<pre>
	// bioscom - выполняет ввод / вывод из последовательного порта
	#include&lt;bios.h>
	#include&lt;conio.h>
	#define COM1 0
	#define DATA_READY 0x100
	#define SETTINGS (0x80 | 0x02 | 0x00 |0x00)
	main()
	{	register int in, out, st; clrscr();
		bioscom(0, SETTINGS, COM1);
		cprintf("...BIOSCOM [ESC] - exit...\n");
		while(1)
		{	st = bioscom(3, 0, COM1);
			if (st & DATA_READY)
				if ((out = bioscom(2, 0, COM1) & 0x7F) != 0) putch(out);
			if ( kbhit())	// проверка - есть ли символы в буфере клавиатуры
			{
				if ( ( in = getch() ) == '\x1B')
					return ( 0 );
				bioscom(0, in, COM1);
			}
		} return 0; getch();
	}
</pre><p> &nbsp; </p><a name="03"></a>
<p><b><i>biosdisk</i></b> - ввод/вывод с жестких/гибких дисков.
<br><b><i>Синтаксис</i></b>	int biosdisk(int cmd, int drive, int head, int track, int sector, int nsects, void * buffer);
<p>biosdisk использует команду прерывания 0x13 для того, чтобы передать выполнение дисковых операций непосредственно системе BIOS.
<br>drive представляет собой число, которое показывает, какой дисковод используется в данной функции:
<ul>0 - для 1-го устройства чтения гибких дисков,<br>1 - для 2-го устройства чтения гибких дисков,<br>3 - для 3-го устройства и так далее.</ul>
<p>Для жестких дисковых устройств, параметр drive, со значением 
<ul>0x80 задает первый дисковод,<br>0x81 задает второй дисковод, <br>0x82 задает третий дисковод и так далее.</ul>
<p>То есть для жестких дисков указывается физический адрес дисковода, а не его логическая партиция. Прикладная программа должна будет самостоятельно интерпретировать таблицу партиций, если это потребуется.
<br>cmd обозначает выполняемую операцию. В зависимости от значения cmd, остальные параметры могут требоваться или нет. 
<p><center><table width="90%" border=0 cellpadding=2>
<tr><td valign="top"><b>0</b></td><td> Сбрасывает дискетную систему. Это побуждает устройство управления дисководами производить аппаратный сброс. Все остальные параметры игнорируются.</td></tr>
<tr><td valign="top"><b>1</b></td><td> Возвращает статус последней дисковой операции. Все остальные параметры игнорируются.</td></tr>
<tr><td valign="top"><b>2</b></td><td> Считывает в память один или несколько секторов диска. Начальный сектор, подлежащий считыванию задается параметрами head, track и sector. Число считываемых секторов задается параметром nsects. Данные считываются в переменную *buffer, по 512 байтов на сектор.</td></tr>
<tr><td valign="top"><b>3</b></td><td> Записывает на диск из памяти один или более дисковых секторов. Начальный сектор задается параметрами head, track и sector. Число секторов определяется параметром nsects. Данные записываются на диск из переменной buffer, 512 байтов на сектор.</td></tr>
<tr><td valign="top"><b>4</b></td><td> Производит верификацию одного или более секторов. Начальный сектор определяется параметрами head, track, sector. Количество секторов задается в переменной nsects.</td></tr>
<tr><td valign="top"><b>5</b></td><td> Форматирует дорожку. Дорожка определяется параметрами head и track. Переменная buffer является адресным указателем таблицы дескрипторов секторов, которые будут записываться на указанной дорожке.</td></tr>
<tr><td>&nbsp;</td><td><b><center>Для компьютеров типа XT или AT разрешеные значения параметра cmd:</center></b></td></tr>
<tr><td><b>6</b></td><td> Форматирует дорожку и помечает "плохие" сектора.</td></tr>
<tr><td><b>7</b></td><td> Форматирует диск, начиная с заданной дорожки.</td></tr>
<tr><td valign="top"><b>8</b></td><td> Возвращает параметры рабочего дисковода. Данная информация записывается в переменную buffer в первые четыре байта.</td></tr>
<tr><td><b>9</b></td><td> Задает характеристики пары - формирователей.</td></tr>
<tr><td valign="top"><b>10</b></td><td> Производит удлиненное считывание (то есть читается 512 байтов плюс 4 дополнительных байта на каждый сектор).</td></tr>
<tr><td valign="top"><b>11</b></td><td> Выполняет удлиненную запись (записывается 512 байтов плюс 4 дополнительных байта на каждый сектор).</td></tr>
<tr><td><b>12</b></td><td> Выполняет дисковый поиск.</td></tr>
<tr><td><b>13</b></td><td> Чередует сброс дисков.</td></tr>
<tr><td><b>14</b></td><td> Считывает буфер сектора.</td></tr>
<tr><td><b>15</b></td><td> Записывает буфер сектора.</td></tr>
<tr><td><b>16</b></td><td> Проверяет готовность заданного диска.</td></tr>
<tr><td><b>17</b></td><td> Рекалибрует диск.</td></tr>
<tr><td><b>18</b></td><td> Производит диагностику контроллера ЗУПВ.</td></tr>
<tr><td><b>19</b></td><td> Производит диагностику дисковода.</td></tr>
<tr><td><b>20</b></td><td> Производит внутреннюю диагностику контроллера.</td></tr>
</table></center>
<p>Данные операции возвращают байт состояния, состоящий из битов:
<ul>0x00 - Операция завершилась успешно<br>0x01 - Неверная команда<br>0x02 - Адресный маркер не найден<br>0x04 - Запись не найдена<br>0x05 - Сброс завершился неудачно<br>0x07 - Сбой параметра активности дисковода<br>0x09 - Попытка обратиться к адресу (DMA) через границу 64 К<br>0x0B - Обнаружен флажок дефектной дорожки<br>0x10 - Неверный код ECC при чтении диска
<br>0x11 - Корректировка данных по коду исправления ошибок (ECC)<br>0x20 - Сбой при работе контроллера<br>0x40 - Сбой операции поиска<br>0x80 - Узел соединения не реагирует<br>0xBB - Произошла нераспознаваемая ошибка<br>0xFF - Сбой операции распознавания</ul>
<p>Заметим, что код 0x11 не является ошибкой, поскольку данные являются корректными. Возвращаемое значение выдается в любом случае, чтобы дать возможность прикладной программе выработать решение.
<pre>
	// biosdisk - дисковые функции BIOS
	#include&lt;bios.h>
	#include&lt;stdio.h>
	main()
	{	#define CMD 2	// команда чтения сектора
		#define DRIVE 0	// номер дисковода для A:
		#define HEAD 0	// номер головки
		#define TRACK 0	// номер дорожки
		#define SECT 1	// номер секторов
		#define NSECT 1	// число секторов

		int result; char buff[512]; clrscr();
		printf("Попытка чтения дисковода A:\n");
		result = biosdisk(CMD, DRIVE, HEAD, TRACK, SECT, NSECT, buff);
		if (result == 0)
			printf("%0x Успешное чтение диска в дисководе A:\n", result);
		else
			printf("%0x Попытка чтения дисковода A: неудачна\n");
		getch(); return 0;
	}
</pre>
<p> &nbsp; </p><a name="04"></a>
<p><b><i>biosequip</i></b> - проверяет оборудование
<br><b><i>Синтаксис</i></b>	int biosequip(void);
<p>biosequip возвращает целое число, описывающее оборудование, подсоединенное к системе, для чего используется команда прерывания 0x11 системы BIOS.<br>Возвращаемое biosequip значение представляет собой набор из битовых полей:
<ul>бит 15 - количество принтеров,<br>бит 14 - количество принтеров,<br>бит 13 - не используется,<br>бит 12 - подсоединен игровой ввод/вывод,
<br>бит 11 - число портов типа RS232,<br>бит 8 - не используется,<br>бит 7 - число дискет,<br>бит 6 - число дискет,
<ul>00 - 1 дисковод,<br>01 - 2 дисковода,<br>10 - 3 дисковода,<br>11 - 4 дисковода (возможно только, если бит 0 равен 1),</ul>
<br>бит 5 - исходный,<br>бит 4 - видео-режим,<ul>00 - не используется,<br>01 - 40 &#8729; 25 BW с цветной платой,<br>10 - 80 &#8729; 25 BW с цветной платой,<br>11 - 80 &#8729; 25 BW с монохромной платой,</ul>
<br>бит 3 - объединительная плата,<br>бит 2 - размер ЗУПВ,<ul>00 - 16К,<br>01 - 32К,<br>10 - 48К,<br>11 - 64К,</ul>
<br>бит1 - сопроцессор для данных с плавающей точкой,<br>бит 0 - самозагрузка с дискеты.</ul>
<pre>
	// biosequip - проверяет оборудование
	#include&lt;bios.h>
	#include&lt;stdio.h>
	#define CO_PROCESSOR_MASK 0x0002
	main()
	{	int equip_check; clrscr();
		// получить текущую конфигурацию оборудования
		equip_check = biosequip();
		printf("Оборудование %0x\n", equip_check);
		// имеется ли сопроцессор ?
		if (equip_check & CO_PROCESSOR_MASK)
			printf("Сопроцессор установлен \n");
		else
			printf("Сопроцессор не установлен\n");
		getch(); return 0;
	}
</pre>
<p> &nbsp; </p><a name="05"></a>
<p><b><i>biosmemory</i></b> - возвращает размер оперативной памяти.
<br><b><i>Синтаксис</i></b>	int biosmemory(void);
<p>biosmemory, используя команду прерывания 0x12 системы BIOS, возвращает значение, равное размерам оперативной памяти.<br>Возвращаемое значение представляет собой размер оперативной памяти в блоках по 1 К.
<pre>
	// biosmemory - возвращает размер оперативной памяти
	#include&lt;bios.h>
	#include&lt;stdio.h>
	main()
	{	int memory_size; clrscr();
		// возвращает до 640 K
		memory_size = biosmemory();
		printf("Оперативная память %0d K\n", memory_size);
		getch(); return 0;
	}
</pre>
<p> &nbsp; </p><a name="06"></a>
<p><b><i>biosprint</i></b> - ввод/вывод на принтер.
<br><b><i>Синтаксис</i></b>	int biosprint(int cmd, int byte, int port);
<p>biosprint выполняет различные операции на принтере, определяемом параметром port.
<ul>port = 0 соответствует LPT1,<br>port = 1 соответствует LPT2 и так далее.</ul><p>Параметр cmd может быть одним из следующих:<ul>0 - печать символа, содержащегося в переменной byte,
<br>1 - инициализация порта принтера,<br>2 - считывание статуса принтера.</ul><p>Значение параметра byte может заключаться в пределах от 0 до 255.<br>Значение, возвращаемое функцией biosprint в любой из описанных выше операций, представляет собой статус принтера, объединенный посредством операции "ИЛИ" с битовыми значениями:<ul>0x01 - простой устройства,
<br>0x08 - ошибка ввода/вывода,<br>0x10 - включено,<br>0x20 - кончилась бумага,<br>0x40 - подтверждение приема,<br>0x80 - не занято.</ul>
<p>При значении параметра cmd = 0, возвращаемое значение, равное 0x01, означает ошибку вывода.
<pre>
	// biosprint - ввод / вывод на принтер при помощи BIOS
	#include&lt;bios.h>
	#include&lt;stdio.h>
	#include&lt;conio.h>
	main()
	{	#define STATUS 2		// команда получить статус принтера
		#define PORTNUM 0	// LPT1
		int status, abut = 0; clrscr();
		printf("Выключите принтер. Для продолжения нажмите любую клавишу\n");
		getch(); status = biosprint(STATUS, abut, PORTNUM);
		if (status & 0x01)	printf("Таймаут устройства\n");
		if (status & 0x08)	printf("Ошибка ввода/вывода\n");
		if (status & 0x10)	printf("Включено\n");
		if (status & 0x20)	printf("Конец бумаги\n");
		if (status & 0x40)	printf("Подтверждение приема\n");
		if (status & 0x80)	printf("Не занято\n");
		getch(); return 0;
	}
</pre>
<p> &nbsp; </p><a name="07"></a>
<p><b><i>biostime</i></b> - возвращает значение времени дня.
<br><b><i>Синтаксис</i></b>	long biostime(int cmd, long newtime);
<p>biostime либо считывает, либо устанавливает таймер системы BIOS, который подсчитывает время, прошедшее с полуночи по норме приблизительно 18.2 машинных тиков в секунду.
<ul>cmd = 0 - функция biostime возвращает текущее значение таймера,<br>cmd = 1 - значение таймера устанавливается по значению переменной newtime.</ul>
<p>Когда функция biostime работает в режиме чтения таймера системы BIOS, (cmd = 0), возвращаемое значение представляет собой текущее значение таймера.
<pre>
	// biostime - считывание или установка таймера BIOS
	#include&lt;bios.h>
	#include&lt;time.h>
	#include&lt;conio.h>
	main()
	{	long bios_time; clrscr();
		cprintf("Число тиков с полуночи: \r\n");
		cprintf("Число секунд с полуночи: \r\n");
		cprintf("Число минут с полуночи: \r\n");
		cprintf("Число часов с полуночи: \r\n");
		cprintf("\r\nДля выхода нажмите любую клавишу");
		while (!kbhit())	// была ли нажата клавиша
		{	bios_time = biostime(0, 0L);
			gotoxy(40, 1); cprintf("%lu", bios_time);
			gotoxy(40, 2); cprintf("%lu", bios_time / CLK_TCK);
			gotoxy(40, 3); cprintf("%lu", bios_time / CLK_TCK / 60);
			gotoxy(40, 4); cprintf("%lu", bios_time / CLK_TCK / 3600);
		}
		getch(); return 0;
	}
</pre><p> &nbsp; </p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>