<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | Лекция № 26</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=a>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=p>&nbsp 6 &nbsp</a></td>
<td><a href="07.htm" class=p>&nbsp 7 &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr>
<td class=usual>
<p align=center class=dbi><br>Указатели</p>
<b><i>Указатель - это переменная, содержащая адрес некоторых данных, а не их значение, это 
группа ячеек (как правило, две или четыре), в которых может храниться адрес переменной, 
содержащей некоторое значение.</i></b>
<p>Таким образом, имя переменной отсылает к значению прямо, а указатель косвенно. 
<p>Ссылка на значение посредством указателя называется <b><i>косвенной адресацией</i></b>.
<p>Указатели являются специальными объектами в программах на языке C и C++. Различают 
указатели-переменные и указатели-константы. Значениями указателей служат адреса 
участков памяти, выделенных для объектов конкретных типов, поэтому в определении и 
описании указателя всегда присутствует обозначение соответствующего ему типа. 
<p>В простейшем случае <b><i>определение и описание указателя-переменной</i></b> на некоторый объект 
имеют вид:
<pre>			тип *имя_указателя;
</pre>
<p>тип - любой из типов данных языка программирования C++. Он определяет тип переменной, на которую указывает указатель.
<br><b>*</b> &nbsp;&nbsp; - знак операции ссылки по указателю; в данном случае он означает, что <i>имя_указателя</i> является указателем на переменную типа <i>тип</i>, а не самой переменной этого типа.
<br>Имена указателей должны подчиняться тем же требованиям, что и любые другие имена переменных, и быть уникальными.
<p>При необходимости определить несколько указателей на объекты одного и того же типа 
символ * помещают перед каждым именем.
<p>Например: &nbsp &nbsp int *p_ram, *i2p, *i3p, i;
<p>Для того, чтобы указатель указывал на определенную переменную, ему присваивается ее адрес с помощью операции взятия адреса &. Теперь, когда создана переменная ram и указатель p_ram, указатель можно инициализировать оператором присваивания:
<pre>
			имя_указателя = &имя_переменной;

			p_ram = &ram;	// присвоить адрес ram указателю p_ram
</pre>

<p>Как и в случае обычных переменных, использование неинициализированных указателей дает непредсказуемый результат и потенциально опасно, хотя и возможно. Пока указатель не содержит адреса переменной, он бесполезен.
<br>При определении указателя в большинстве случаев целесообразно выполнить его 
инициализацию:
<pre>			тип *имя_указателя инициализатор;
</pre>
<p>Допустимы формы определения указателей:
<pre>
			тип *имя_указателя = инициализирующее выражение;
			тип *имя_указателя (инициализирующее выражение);
</pre>
<p>В качестве инициализирующего выражения должно использоваться константное выражение:
<ul>
<li>явно заданный адрес участка памяти, 
<li>указатель, уже имеющий значение, 
<li>выражение, позволяющее получить адрес объекта с помощью операции &. 
<pre>
		char cc = 'w';		// Символьная переменная типа char
		char *ptr;		// Неинициализированный указатель на объект типа char
		char *pc = &cc;		// Инициализированный указатель на объект типа char
</pre>
<p>Если теперь необходимо вывести значение переменной cc, то операторы
<pre>
		// Прямое обращение к переменной cc
		printf("Код символа %c - %d адрес %u\n", cc, cc, &cc);
		
		// Косвенное обращение к переменной cc
		printf("Код символа %c - %d адрес %u\n", *pc, *pc, pc);
</pre>
<p>Выдадут один и тот же результат:
<pre>
		Код символа w - 119 адрес 4095
</pre>
</ul>
<ol>
<li><b><i>Можно использовать указатель места расположения различных данных и 
различных структур данных.</i></b><br>Изменением адреса, содержащегося в указателе, 
можно манипулировать: создавать, считывать, изменять информацию в различных 
ячейках. Это позволит, например, связать несколько зависимых структур данных с 
помощью одного указателя. 
<li><b><i>Использование указателей позволяет создавать новые переменные в процессе 
выполнения программы. </i></b><br>C позволяет программе запрашивать некоторое количество 
памяти (в байтах), возвращая адреса, которые можно запомнить в указателе. Этот 
прием известен как динамическое распределение. Используя динамическое 
распределение, программа может приспосабливаться к любому объему памяти, в 
зависимости от того, как много (или мало) памяти доступно компьютеру. 
<li><b><i>Можно использовать указатели для доступа к различным элементам структур 
данных: массивам, строкам, структурам.</i></b><br> Указатель указывает место в памяти 
компьютера, а, используя смещение относительно начального адреса можно 
указать целый сегмент памяти, в котором размещены те или иные данные. 
Индексируя указатель, получают доступ к последовательности байтов, которая 
может представлять массив или структуру. 
</ol>
<p align=center class=dbi><br>Ссылки</p>
<p>Определение ссылки: &nbsp;&nbsp;<b>тип &имя_ссылки инициализатор</b>
<p>В соответствии с синтаксисом инициализатора, наличие которого обязательно, определение ссылки может быть таким:
<pre>
			тип &имя_ссылки = инициализирующее выражение;
			тип &имя_ссылки (инициализирующее выражение);
</pre>
<p>Ссылка есть другое имя уже существующего объекта. Поэтому в качестве инициализирующего выражения должно выступать имя некоторого объекта, имеющего место в памяти.
Значением ссылки после определения с инициализацией становится адрес этого объекта.
<p>Например, 
<pre>
		int L = 67;	// определена и инициализирована переменная L
		int &#38;sL = L;	// значением ссылки sL является адрес переменной L
</pre>
<p>Теперь, если изменить значение одной из переменных, такое же значение примет вторая переменная.
<pre>
	#include&lt;conio.h>
	#include&lt;iostream.h>
	void main()
	{	clrscr();
		double L = 1.23, &#38;sL = L;
		cout << "\nL = " << L << "\tsL = " << sL;
		sL = -56.98;
		cout << "\nL = " << L << "\tsL = " << sL;
		L = 856.98;
		cout << "\nL = " << L << "\tsL = " << sL;
		cout << "\nАдреса:\t\t&L = " << &L << "\t\t&#38;sL = " << &#38;sL;
		getch();
	}
	  <i>Результаты:</i>	L = 1.23        sL = 1.23
			L = -56.98      sL = -56.98
			L = 856.98      sL = 856.98
			Адреса:         &L = 0x8fc70ff8         &#38;sL = 0x8fc70ff8
</pre>
<p>Применив к ссылке операцию получения адреса &, определим адрес того объекта, которым инициализирована ссылка.
Поэтому после инициализации значение ссылки изменить нельзя, она всегда смотрит на тот участок памяти, с которым она связана инициализацией.
<br>Ни одна из операций не действует на ссылку, а относится к тому объекту, с которым она связана.
<p>&nbsp;</p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=a>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=p>&nbsp 6 &nbsp</a></td>
<td><a href="07.htm" class=p>&nbsp 7 &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>