<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | СР 29_30</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=a>&nbsp 5 &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr><td class=usual>
<p align=center class=dbi><br>Реализация связанного списка</p>
<p>Рассмотрим программу, использующую связанный список для хранения пяти символов. Вместо символов можно использовать адреса, имена или любые другие данные. Чтобы сделать пример как можно проще, ограничимся одиночными символами в качестве элементов данных.
<p>Сложность программе придает сортировка данных по мере их добавления. Элементы добавляются в начало, середину или конец списка в зависимости от их значений. Данные списка всегда находятся в отсортированном порядке.
<p>В программе демонстрируется добавление записей в связанный список. В ней используются все те же три метода работы со списком: записи могут добавляться в начало, середину или конец списка.
<p>Кроме того, программа учитывает особые случаи добавления первого элемента (в начало списка) и второго элемента (в середину).
<p><b><i>Функции show_list()</i></b> - вывод информации из списка - <b><i>и free_memory_list()</i></b> - освобождение всей памяти, занятой списком - <b><i>работают аналогично:</i></b>
<ul>
<li>Каждая начинает движение по списку с указателя first на его первый элемент.
<li>Далее в цикле while список перебирается элемент за элементом с помощью указателя next_ptr.
<li>Как только next_ptr становится равным NULL, достигается конец списка, и функция заканчивает работу.
</ul>
<p><b><i>Самой важной и самой сложной функцией в этой программе является функция add_to_list().</i></b> В ней содержатся объявления трех указателей, которые используются для указания на три различных элемента списка.
<ul>
<li>Указатель new_rec предназначен указывать на новый элемент, добавляемый в список.
<li>Указатель tmp_rec предназначен для указания на текущий обрабатываемый элемент списка.
<li>Если в списке больше одного элемента, то используется указатель prev_rec на предыдущий обработанный элемент.
</ul>
<p>Функции add_to_list() возвращает адрес указателя на первый элемент.
<p>Работа функции add_to_list(), предназначенной для того, чтобы вставить элемент в заданное место связанного списка, самым подробным образом пояснена в программном коде.
<pre>
// Реализация связанного списка
#include &lt;conio.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#ifndef NULL		// проверяется, определена ли константа NULL
	#define NULL 0
#endif
// Структура данных элемента списка
struct list
{
	int  ch; // в переменной типа int хранится символ типа char
	struct list *next_rec;
};
// Определения типов для структуры и указателя на нее
typedef struct list LIST;
typedef LIST *LISTPTR;
// Прототипы функций
LISTPTR add_to_list(int, LISTPTR);
void show_list(LISTPTR);
void free_memory_list(LISTPTR);
int main(void)
{	clrscr();
	LISTPTR first = NULL;	// указатель на первый элемент инициализируется значением NULL
	int i = 0; int ch;
	char trash[256];	// для очистки буфера stdin
	while (i++ < 5)		// построение списка из 5 элементов
	{	ch = 0;
		printf("\nВведи символ %d, ", i);
		// Проверка, чтобы были введены только буквы
		// можно было использовать функцию isalpha()
		do
		{	printf("\nЗначение от a до z: ");
			ch = getc(stdin);	// ввод следующего символа из буфера
			gets(trash);		// очистка буфера
		} while((ch < 'а' || ch > 'z') && (ch < 'А' || ch > 'Z'));
		// в функцию передается элемент данных и указатель на начало списка 
		first = add_to_list(ch, first);
	}
	show_list(first);		// Вывод всего списка
	free_memory_list(first);	// Освобождение всей памяти
	getch(); return 0;
}
// Функция add_to_list() вставляет символ в список
// Вызов: int ch = символ для помещения в список
// LISTPTR first = адрес начального указателя
// Возвращает: адрес указателя на первый элемент
LISTPTR add_to_list(int ch, LISTPTR first)
{
	LISTPTR new_rec = NULL;		// Адрес новой записи
	LISTPTR tmp_rec = NULL;		// Временный указатель
	LISTPTR prev_rec = NULL;

	// Распределение памяти
	// выделяется память для нового добавляемого элемента.
	// Указатель new_rec устанавливается равным значению, которое возвращает функция malloc()
	new_rec = (LISTPTR) malloc(sizeof(LIST));

	// Если ошибка распределения памяти, программа завершается
	if(!new_rec)
	{	printf("\nПроблемы с памятью!\n");
		exit(1);
	}

	// запись новых данных, если память распределена успешно
	// элемент данных, переданный как аргумент, помещается в структуру -
	// присваивание переданного символа ch полю данных новой записи rec -> ch
	new_rec -> ch = ch;

	// поле next_rec в новой записи устанавливается равным NULL,
	// чтобы не указывать на какой-нибудь случайный адрес
	new_rec -> next_rec = NULL;

	// начинается операция добавления записи в список
	// выполняется проверка, есть ли в списке хотя бы один элемент
	// добавление первого элемента в список, если список пустой
	if (first == NULL)
	{	// начальный указатель делается равным адресу новой записи
		first = new_rec;
		new_rec -> next_rec = NULL;	// лишнее, но так безопаснее
	}

	// если новая запись не является первой, то выполняется блок else 
	else
	{	// проверяется, не следует ли поместить новую запись в самое начало списка
		// то есть, проверка, не вставлять ли перед первым элементом
		if(new_rec -> ch < first -> ch)
		{
			// если новая запись должна стать первой, указатель next_rec в новом элементе
			// устанавливается равным адресу записи, ранее бывшей первой 
			new_rec -> next_rec = first;
			// начальному указателю first присваивается адрес новой записи
			first = new_rec;
		}

		// если новая запись не должна стать самой первой в пока еще пустом списке,
		// или первой в списке, где уже были записи,
		// значит, ее следует добавить в середину или конец списка
		else
		{	// указателю tmp_rec присваивается адрес второй записи в списке
			tmp_rec = first -> next_rec;

			// указателю prev_rec присваивается адрес первой записи
			prev_rec = first;

			// Анализируем, куда вставить элемент
			// если в списке только одна запись, то указатель tmp_rec станет равным NULL,
			// так как ему присваивается значение указателя next_rec в первом элементе,
			// который равен NULL в этом случае
			if(tmp_rec == NULL)
			{
				// добавляем вторую запись в конец
				// указателю prev_rec -> next_rec присваивается адрес нового элемента
				prev_rec -> next_rec = new_rec;
			}
			// если указатель tmp_rec не равен NULL - в списке уже есть больше двух записей
			else
			{	// проверка, не вставляется ли в середину
				// цикл while перебирает остальные записи в поисках места для нового элемента
				while((tmp_rec -> next_rec != NULL))
				{
					// если символ в новом элементе меньше, чем в текущем элементе,
					// то именно сюда и следует поместить новую запись
					if(new_rec -> ch < tmp_rec -> ch)
					{
						// указателю нового элемента присваивается адрес текущего элемента tmp_rec
						new_rec -> next_rec = tmp_rec;

						// Следующие строки содержат контрольный код для проверки и отладки.
						// Их можно было бы удалить:
						// если программа работает правильно, выполнение до них не доходит.
						// После того, как указатель нового элемента становится равным
						// текущему указателю, он должен равняться и указателю на следующий
						// элемент по отношению к предыдущему указателю, то есть опять-таки
						// текущему указателю.
						// Если они не равны, то в программе произошла серьезная ошибка.
						if(new_rec -> next_rec != prev_rec -> next_rec)
						{	printf("ERROR");
							getc(stdin);
							exit(0);
						}

						// указателю предыдущего элемента присваивается адрес нового элемента
						prev_rec -> next_rec = new_rec;
						break;	// элемент вставлен, выход из while
					}

					// если новый символ превосходит по значению символ текущего элемента,
					// то переходим к следующему звену списка
					else
					{	tmp_rec = tmp_rec -> next_rec;
						prev_rec = prev_rec -> next_rec;
					}
				}
				// проверка, не вставляется ли в конец списка
				// если достигается последний элемент списка,
				// то указатель tmp_rec -> next_rec становится равным NULL
				if(tmp_rec -> next_rec == NULL)
				{
					// следует ли вставлять новый элемент до или после последнего элемента списка
					if(new_rec -> ch < tmp_rec -> ch )	// предпоследний
					{	new_rec -> next_rec = tmp_rec;
						prev_rec -> next_rec = new_rec;
					}
					else		// в конец
					{	tmp_rec -> next_rec = new_rec;
						new_rec -> next_rec = NULL;	//лишнее
					}
				}
			}
		}
	} return(first);
}

// Функция show_list() - вывод информации из списка
void show_list(LISTPTR first)
{	LISTPTR cur_ptr;
	int counter = 1;
	printf ("\n\nАдрес записи Позиция Значение Адрес следующей записи\n");
	printf ("============ ======= ======== ======================\n");
	cur_ptr = first;
	while(cur_ptr != NULL)
	{	printf (" %p  ", cur_ptr);
		printf ("    %2i      %c", counter++, cur_ptr -> ch);
		printf ("        %p  \n", cur_ptr -> next_rec	);
		cur_ptr = cur_ptr -> next_rec;
	}
}

// Функция free_memory_list() - освобождение всей памяти, занятой списком
void free_memory_list(LISTPTR first)
{	LISTPTR cur_ptr, next_rec;
	cur_ptr = first;		// Начать сначала
	while(cur_ptr != NULL)		// Идти до конца списка
	{	// Получение адреса следующей записи
		next_rec = cur_ptr -> next_rec;
		// Освобождение текущей записи
		free(cur_ptr);
		// Смещение на одну запись
		cur_ptr = next_rec;
	}
}
	<i>Результаты:</i>
			Введи символ 1,
			Значение от a до z: g
			
			Введи символ 2,
			Значение от a до z: h
			
			Введи символ 3,
			Значение от a до z: d
			
			Введи символ 4,
			Значение от a до z: j
			
			Введи символ 5,
			Значение от a до z: e
			
			Адрес записи Позиция Значение Адрес следующей записи
			=========== ======= ======== =====================
			 9134:0004	1	d		9136:0004
			 9136:0004	2	e		9132:0004
			 9132:0004	3	g		9133:0004
			 9133:0004	4	h		9135:0004
			 9135:0004	5	j		0000:0000
</pre>

<p>Эту программу легко изменить так, чтобы она сортировала имена, номера телефонов или любые другие данные. Кроме того, хотя программа ориентирована на сортировку в алфавитном порядке (от A до Z), столь же легко сделать из нее программу сортировки в обратном порядке (от Z до А).
<p>Возможность добавления элементов в связанный список очень важна, но не менее важно уметь удалять элементы при необходимости. Удаление элементов (записей, узлов, звеньев) выполняется во многом аналогично их добавлению. Элементы можно удалять из начала, середины или конца списка. В каждом из этих случаев требуется корректная модификация указателей. Также необходимо освободить память, занимаемую удаленным элементом списка.
<p><table align=center width=90% border=1 cellpadding=5 cellspacing=10>
<tr><td class=rule>
<b>Помните о различиях в работе функций malloc() и calloc():</b>
<br>функция malloc() не инициализирует выделенный участок памяти, а функция calloc() - инициализирует.
</td></tr>
</table>
<p><table align=center width=90% border=1 cellpadding=5 cellspacing=10>
<tr><td class=rule>
<b>Не забывайте</b> освобождать память, занятую элементами связанного списка, которые вы удаляете.
</td></tr>
</table>
<p>&nbsp;
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=a>&nbsp 5 &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>