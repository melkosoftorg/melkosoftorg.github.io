<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | СР 29_30</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=a>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr><td class=usual>
<p align=center class=dbi><br>Работа со связанными списками</p>
<p>Со связанными списками можно проделывать такие манипуляции, как
<ul><li>добавление,
<li>удаление,
<li>изменение элементов списка.
</ul>
<p>Изменение элементов не представляет собой ничего особенного, а вот их добавление и удаление - далеко не тривиальные операции.
<p>Элементы списка связаны между собой через указатели. Большая часть работы по добавлению и удалению элементов состоит в манипулировании этими указателями. Элементы можно добавлять в начало, середину или конец списка. От этого зависит способ изменения указателей.
<p>Рассмотрим общие подходы к некоторым операциям со связанными списками. При этом будем использовать ту же структуру person, что и в предыдущих примерах.
<p align=center><b>Предварительная подготовка</b></p>
<p>Прежде чем организовывать связанный список, необходимо определить структуру данных для этого списка и объявить начальный указатель. Поскольку список создается пустым, его начальный указатель следует инициализировать значением NULL. Нужен также еще один указатель на ту же структуру, чтобы с его помощью добавлять элементы в список.
<p>В итоге получается следующий код:
<pre>
			struct person
			{
				char name[20];
				struct person *Next;
			};
			struct person *New;
			struct person *Head;
			Head = NULL;
</pre>
<p align=center><b>Добавление элемента в начало списка</b></p>
<p>Если начальный указатель равен NULL, то список пустой, и новый элемент станет его единственным членом. Если же начальный указатель не равен NULL, то список уже содержит один или несколько элементов. Тем не менее, в каждом из этих случаев процедура добавление элемента в начало списка остается одной и той же:
<ol>
<li>создать экземпляр структуры с выделением памяти для него функцией malloc(),
<li>установить указатель следующего узла в структуре нового элемента списка равным текущему значению начального указателя.
<br>Если список пустой, это будет NULL, в противном случае - адрес текущего первого элемента.
<li>установить начальный указатель равным адресу нового элемента.
</ol>
<p>Вот код, выполняющий эти задачи:
<pre>
			New = (struct person*) malloc(sizeof(struct person));
			New -> Next = Head;
			Head = New;
</pre>
<p>Обратите внимание на приведение типа перед функцией malloc() для корректного присваивания возвращаемого адреса указателю на структуру.
<p><table align=center width=90% border=1 cellpadding=5 cellspacing=10>
<tr><td class=rule>
<b>Внимание:</b> Очень важно изменять указатели в правильном порядке. Если первым изменить начальный указатель, то потеряется весь список!
</td></tr>
</table>
<p><b><i>Рисунок схематически демонстрирует процедуру добавления нового элемента в пустой список</i></b>
<p><table border=0 align="center" width="70%">
<tr valign="top"><td width="30%"><img src="image002.gif" alt="До первого добавления">
</td><td width="30%"><img src="image004.gif" alt="Добавляемые значения">
</td><td width="40%"><img src="image005.gif" alt="После добавления">
</td></tr>
<tr><td colspan=2 align="center"><i>Перед добавлением</i></td><td align="center"><i>После добавления</i>
</td></tr>
</table>
<p>Следующий <b><i>рисунок демонстрирует процедуру добавления нового элемента в непустой список</i></b>
<p><table border=0 align="center" width="70%">
<tr valign="top"><td width="15%"><img src="image004.gif" alt="Добавляемые значения">
</td><td width="30%"><img src="image006.gif" alt="До добавления">
</td></tr>
<tr><td colspan=2 align="center"><i>Перед добавлением</i>
</td></tr>
<tr><td colspan=2><img src="image007.gif" alt="После добавления">
</td></tr>
<tr><td colspan=2 align="center"><i>После добавления</i>
</td></tr>
</table>
<p>Обратите внимание, что для распределения памяти под новый элемент используется функция malloc().
<p>По мере добавления новых элементов для них также выделяется память без размещения уже существующих заново.
<p>Для этой цели можно также использовать функцию calloc (). Следует знать важное различие между двумя функциями распределения памяти: calloc() инициализирует вновь созданный элемент, a malloc() этого не делает.
<p><table align=center width=90% border=1 cellpadding=5 cellspacing=10>
<tr><td class=rule>
<b>Совет:</b> Всегда инициализируйте указатели значением NULL при их объявлении. Не оставляйте указатели с неопределенными значениями - таким образом вы просто напрашиваетесь на ошибку.
</td></tr>
</table>
<p>&nbsp;
<p align=center><b>Добавление элемента в конец списка</b></p>
<p>Для добавления элемента в конец списка следует сначала дойти от начального указателя до последнero элемента в списке. После нахождения последнего элемента следует выполнить следующие операции:
<ol>
<li>создать экземпляр структуры данных, распределив память с помощью функции malloc().
<li>установить указатель в текущем последнем элементе на добавляемый элемент (адрес которого возвратила функция malloc ()).
<li>установить указатель в добавленном элементе равным NULL, чтобы таким образом сделать его новым последним элементом списка.
</ol>
<p>Вот код для выполнения этих операций:
<pre>
			person *current;
			...
			current = Head;
			while(current -> Next != NULL)
				current = current -> Next;
			New = (struct person*) malloc(sizeof(struct person));
			current -> Next = New;
			New -> Next = NULL;
</pre>
<p><b><i>На рисунке схематически показана процедура добавления нового элемента в конец связанного списка.</i></b>
<p><table border=0 align="center" width="70%">
<tr valign="top"><td width="30%"><img src="image006.gif" alt="До добавления">
</td><td width="15%"><img src="image004.gif" alt="Добавляемые значения">
</td></tr>
<tr><td colspan=2 align="center"><i>Перед добавлением</i>
</td></tr>
<tr><td colspan=2><img src="image008.gif" alt="После добавления">
</td></tr>
<tr><td colspan=2 align="center"><i>После добавления</i>
</td></tr>
</table>
<p align=center><b>Добавление элемента в середину списка</b></p>
<p>При работе со связанным списком в основном приходится добавлять элементы не в начало и не в конец, а куда-то в середину списка. Куда именно помещается новый элемент, зависит от назначения списка и способа его организации - например, от наличия сортировки по одному или нескольким полям данных.
<p>Поэтому вначале необходимо найти то место в списке, на которое нужно поместить новый элемент, а затем уже добавить сам элемент.
<p>Для этого следует выполнить такие операции:
<ol>
<li>найти существующий элемент в списке, после которого должен стоять новый элемент. Назовем его маркером.
<li>создать экземпляр структуры, выделив для него память с помощью функции malloc().
<li>установить указатель в маркере на новый элемент (адрес которого возвратила функция malloc()).
<li>установить указатель в новом элементе на тот элемент, на который перед этим указывал маркер.
</ol>
<p>Вот как может выглядеть соответствующий код:
<pre>
			struct person *marker;
			// Сначала - поиск маркера в списке
			...
			New = (struct person*) malloc(sizeof(struct person));
			New -> Next = marker->Next;
			marker -> Next = New;
</pre>
<p><b><i>На рисунке этот процесс показан схематически.</i></b>
<p><table border=0 align="center" width="70%">
<tr valign="top"><td width="30%"><img src="image006.gif" alt="До добавления">
</td><td width="15%"><img src="image004.gif" alt="Добавляемые значения">
</td></tr>
<tr><td colspan=2 align="center"><i>Перед добавлением</i>
</td></tr>
<tr><td colspan=2><img src="image009.gif" alt="После добавления">
</td></tr>
<tr><td colspan=2 align="center"><i>После добавления</i>
</td></tr>
</table>

<p align=center><b>Удаление элемента из списка</b></p>
<p>Удаление элемента из списка представляет собой довольно простую задачу, связанную с манипулированием указателями. Эта операция зависит от того, в каком месте списка находится элемент.
<ul>
<li>Для удаления первого элемента сделайте начальный указатель равным адресу второго элемента списка.
<li>Для удаления последнего элемента сделайте указатель в предпоследнем элементе равным NULL.
<li>Для удаления любого другого элемента сделайте указатель в предшествующем ему элементе равным адресу элемента, следующего за удаляемым элементом.
</ul>
<p>Кроме того, память, занимаемую этим элементом, необходимо освободить, чтобы программа не тратила памяти больше, чем ей действительно необходимо (это называется утечкой памяти). Освобождение памяти выполняется функцией free().
<p>Вот как удаляется первый элемент из списка:
<pre>
			free(Head);
			Head = Head -> Next;
</pre>
<p>А этот фрагмент кода удаляет последний элемент из списка:
<pre>
			struct person *current1, *current2;
			current1 = Head;
			current2 = current1 -> Next;
			while(current2 -> Next != NULL)
			{
				current1 = current2;
				current2 = current1 -> Next;
			}
			free(current1 -> Next);
			current1 -> Next = NULL;
			if(Head = current1)
			Head = null;
</pre>
<p>Наконец, удаление элемента из середины списка выполняется таким образом:
<pre>
			struct person *current1, *current2;
			// здесь идет код для установки указателя current1 на элемент
			// непосредственно перед удаляемым элементом
			current2 = current1 -> Next;
			free(current1 -> Next);
			current1 -> Next = current2 -> Next;
</pre>
<p>После выполнения любой из этих групп операторов без вызова функции free() удаленный элемент все еще существовал бы где-то в памяти, хотя в списке его уже не было бы, потому что ни один указатель из списка на него не указывал бы. В программе, предназначенной для реального практического применения, обязательно нужно освобождать память, занимаемую удаленным элементом. Для этого и нужна функция free ().
<p>&nbsp;
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=a>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>