<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | СР 28</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr>
<td class=usual>
<p align=center class=dbi><br>Побитовые операции</p>
<p>Самой элементарной единицей хранения информации в компьютерах является бит. Битовые (двоичные поразрядные) операции C++ дают возможность манипулировать отдельными битами целочисленных переменных типов char, int, long.
<br>Они позволяют производить операции очень низкого уровня - битового.
<p>Информация 1 бит - это 0 или 1 (<i>ложь - False</i> или <i>истина - True</i>). 
<p>Поразрядные двоичные операции особенно часто используются в тех случаях, когда программа на C++ обращается к аппаратным ресурсам компьютера.
<p>Для обработки на уровне битов C++ имеет следующие операции:
<ol>
<p><li>Операции поразрядного сдвига:
<ul>
<p><li type="disc"><b><<</b> - сдвиг влево битового представления значения левого целочисленного операнда на количество 
разрядов, равное значению правого целочисленного операнда,
<p><li type="disc"><b>>></b> - сдвиг вправо битового представления значения левого целочисленного операнда на количество 
разрядов, равное значению правого целочисленного операнда,
</ul>
<p><li>Поразрядные логические операции:
<ul>
<p><li type="disc"><b>&</b> - поразрядная коньюнкция <b>И</b> битовых представлений значений целочисленных операндов,
<p><li type="disc"><b>|</b> - поразрядная дизъюнкция (включающее <b>ИЛИ</b>) битовых представлений значений целочисленных операндов,
<p><li type="disc"><b>^</b> - поразрядное исключающее <b>ИЛИ</b> битовых представлений значений целочисленных операндов,
</ul>
<p><li>Операция дополнения
<ul>
<p><li type="disc"><b>~</b> - побитовое отрицание <b>НЕ</b> - поразрядное инвертирование внутреннего двоичного кода.
</ul></ol>
<p>Для понимания побитовых операций необходимо вспомнить о <a href="../../../../inform/lec/03/index.htm" target="window-1">двоичном представлении</a> 
любой информации. Например, двоичное представление некоторых чисел 
<p><center><table border=0 cellpadding=5 cellspacing=5>
<tr><td>0 - 0000</td><td>1 - 0001</td><td>2 - 0010</td><td>3 - 0011</td><td>4 - 0100</td><td>5 - 0101
</td></tr>
<tr><td>6 - 0110</td><td>7 - 0111</td><td>8 - 1000</td><td>9 - 1001</td><td>10 - 1010</td><td>11 - 1011
</td></tr>
<tr><td>12 - 1100</td><td>13 - 1101</td><td>14 - 1110</td><td>15 - 1111</td><td>16 - 10000</td><td>17 - 10001
</td></tr>
</table></center>
<p><center><table border=0 cellpadding=5 cellspacing=5>
<tr><td>для символов:</td><td>r - 01110010</td><td>m - 01101101</td><td>ы - 11101011
</td></tr>
</table></center>
<p> &nbsp; </p>
<p align=center class=dbi>Операции поразрядного сдвига</p>
<a name="01"></a>
<p>При определенных обстоятельствах операциями сдвига можно воспользоваться для умножения и деления целочисленных переменных на числа, равные степени двойки.
<p align=center class=dbi><br>Сдвиг влево &nbsp; <<</p>
<p>В выражении &nbsp; <b>a = b << c;</b> &nbsp; производится сдвиг значения <b>b</b> влево на <b>c</b> бит. 
В освободившиеся справа биты <b>b</b> заносятся нули.
<p>Например, &nbsp; 4 << 2 = 16, &nbsp; поскольку 4<sub>10</sub> = 100<sub>2</sub>. 
<br>Сдвиг << равноценен добавлению двух нулей справа, то есть получим 10000<sub>2</sub>, 
что соответствует 20<sub>8</sub> или 16<sub>10</sub>.
<pre>
		printf("%d << %d = %d в 10 c/c = %o в 8 c/c", 4, 2, (4 << 2), (4 << 2));
</pre>
<p>Получим:
<pre>
		4 << 2 = 16 в 10 c/c = 20 в 8 c/c
</pre>
<p><i>Сдвиг влево на N позиций эквивалентен умножению значения операнда на 2<sup>N</sup>.</i>
<br>В примере 4 << 2 = 16, то есть 4 &#8729; 2<sup>2</sup> = 16.
<p>Результат умножения путем сдвига влево будет правильным только в том случае, если не произошло переполнение, то есть ни один бит не потерялся при сдвиге за пределы самого старшего разряда.
<p>Аналогичную операцию выполним с кодом символа r: &nbsp; r << 1.
<pre>
		unsigned char m = 'r';
		printf("%c %d %o\n", m, m, m);
		printf("%c << 1 - %c %d %o\n", m, (m << 1), (m << 1), (m << 1));
</pre>
<p>Получим:
<pre>
			r	114	162
		r << 1	ф	228	344
</pre>
<p>Десятичное представление кода символа r - 114, после выполнения операции r << 1 
получили код 228 (114 &#8729; 2<sup>1</sup> = 228), соответствующий символу ф.
<p> &nbsp; </p>
<a name="02"></a>
<p align=center class=dbi><br>Сдвиг вправо &nbsp; >></p>
<p>В выражении &nbsp; <b>a = b >> c;</b> &nbsp; производится сдвиг значения <b>b</b> вправо на <b>c</b> бит. 
В освободившиеся слева биты <b>b</b> заносятся нули.
<p>Например, &nbsp; 4 >> 2 = 1, &nbsp; поскольку 4<sub>10</sub> = 100<sub>2</sub>. 
<p>На самом деле сдвиг вправо на N позиций несколько сложнее. Следует отметить две особенности:
<ol>
<li>исчезновение младших разрядов, выходящих за разрядную сетку, например, 4 >> 5.
<li>отсутствие стандарта на правило заполнения освобождающихся левых разрядов. 
<br>В стандарте языка сказано, если левый операнд есть целое значение с отрицательным 
знаком, то при сдвиге вправо заполнение освобождающихся левых разрядов определяется 
реализацией.
Возможны варианты:<ul>
<li type="disc">арифметический сдвиг вправо - освобождающиеся разряды заполняются значениями знакового разряда,
<li type="disc">логический сдвиг вправо - освобождающиеся разряды заполняются нулями.
</ul></ol>
<p><i>При положительном левом операнде сдвиг вправо на N позиций эквивалентен уменьшению значения 
левого операнда в 2<sup>N</sup> раз с отбрасыванием дробной части результата.</i>
<p>Например:
<pre>
		  5 >> 2 = 1 &nbsp; (5<sub>10</sub> = 101<sub>2</sub>, &nbsp; 1<sub>10</sub> = 001<sub>2</sub>),
		14 >> 2 = 3 &nbsp; (14<sub>10</sub> = 1110<sub>2</sub>, &nbsp; 3<sub>10</sub> = 0011<sub>2</sub>)
</pre> 
<p>Деление путем сдвига вправо является целочисленным делением, при котором отбрасывается дробная часть результата.
<br>Например, если сдвинуть вправо число 5 (двоичное 00000101) на одну позицию с целью разделить его на два, то результат его будет 2 (двоичному 00000010) вместо правильного ответа 2.5. Дробная часть 0.5 отбрасывается.
<p>&nbsp;</p>
<a name="03"></a>
<p align=center class=dbi>Поразрядные логические операции</p>
<p>В этих операциях два операнда сравниваются побитно и бит результата получает значение 0 или 1 в зависимости от значений битов в операндах.
<p align=center class=dbi><br>Поразрядная коньюнкция &nbsp; &</p>
<p>При выполнении операции поразрядное И - AND в битовом представлении результата только 
те биты равны единице, которым соответствуют единичные биты обоих операндов.
<p><i><b><center>Примеры операций</center></b></i>
<p><center><table border=1 cellpadding=5 cellspacing=2>
<tr><td><center><b>Десятичные числа</b></center>
</td><td><center><b>Двоичные числа</b></center>
</td><td><center><b>Десятичные числа</b></center>
</td><td><center><b>Двоичные числа</b></center>
</td></tr>
<tr><td><b>10 & 3 = 2</b>
</td><td>1010 & 0011 = 0010
</td><td><b>13 & 7 = 5</b>
</td><td>1101 & 0111 = 0101
</td></tr>
<tr><td><b>6 & 5 = 4</b>
</td><td>110 & 101 = 100
</td><td><b>7 & 11 = 3</b>
</td><td>0111 & 1011 = 0011
</td></tr>
</table></center>
<p>Операция И используется для отключения (очистки) одного или нескольких битов целочисленной переменной.
<p> &nbsp; </p>
<a name="04"></a>
<p align=center class=dbi><br>Поразрядная дизъюнкция &nbsp; |</p>
<p>В соответствии с названием операция поразрядное ИЛИ - OR позволяет получить единицу в 
тех разрядах результата, где хотя бы один из битов равен единице.
<p><i><b><center>Примеры операций</center></b></i>
<p><center><table border=1 cellpadding=5 cellspacing=2>
<tr><td><center><b>Десятичные числа</b></center>
</td><td><center><b>Двоичные числа</b></center>
</td><td><center><b>Десятичные числа</b></center>
</td><td><center><b>Двоичные числа</b></center>
</td></tr>
<tr><td><b>10 | 3 = 11</b>
</td><td>1010 | 0011 = 1011
</td><td><b>13 | 7 = 15</b>
</td><td>1101 | 0111 = 1111
</td></tr>
<tr><td><b>6 | 5 = 7</b>
</td><td>110 | 101 = 111
</td><td><b>17 | 9 = 25</b>
</td><td>10001 | 01001 = 11001
</td></tr>
</table></center>
<p>Операция ИЛИ используется для включения (установки) одного или нескольких битов целочисленной переменной.
<p> &nbsp; </p>
<a name="05"></a>
<p align=center class=dbi><br>Поразрядное исключающее ИЛИ &nbsp; ^</p>
<p>При выполнении этой операции ИЛИ - XOR результат формируется при поразрядной обработке кодов операндов.
<blockquote>
В тех разрядах, где оба операнда имеют одинаковые двоичные значения (1 и 1, 0 и 0), результат принимает значение 0.
<br>В тех разрядах, где биты операндов не совпадают (0 и 1), результат равен 1.
</blockquote>
<p>Например, в результате исполнения фрагмента программы 
<pre>
		unsigned char	m = 'ы',			// код 11101011 - ы
				a = 'f';			// код 01100110 - f
		cout << "До ^\t" <<  m << '\t' << a << endl;
		m = m ^ a;				// код 10001101 - Н
		a = m ^ a;				// код 11101011 - ы
		m = m ^ a;				// код 01100110 - f
		cout << "После ^\t" << m << '\t' << a << endl;
</pre>
<p>переменные <i>m</i> и <i>a</i> обменялись значениями без использования вспомогательной переменной.
<pre>
		До ^	ы       f
		После ^	f       ы
</pre>
<p> &nbsp; </p>
<a name="06"></a>
<p align=center class=dbi><br>Побитовое отрицание&nbsp; ~</p>
<p>Операция поразрядного отрицания иначе называется операцией дополнения или инвертирования 
битов и является унарной - одноместной.
<p>Значение операнда в виде внутреннего битового представления обрабатывается таким 
образом, что формируется значение того же типа и длины, что и операнд. В битовом 
представлении результата все цифры заменяются на противоположные: 0 на 1, 1 на 0.
<p>Например, для фрагмента программы, где w - число в восьмеричной системе счисления,  
<pre>
		unsigned char w = '\156', y = ~w;
		printf("\n\n%c %d %o \t %c %u %o\n", w, w, w, y, y, y);

		получим результат:	n - 110 - 156	С - 145 - 221
</pre>
<br>То есть, восьмеричный код 156 соответствует символу n, двоичный код которого (1 байт) 01101110.
<br>Заменим все цифры на противоположные, получим 10010001, соответствующее восьмеричному коду 221 символа С.
<p>Рассмотрим, как можно представить отрицательное число при помощи метода <i>дополнения до двух</i>.
<ul type="disc">
<li>Выполним дополнение до единицы (поразрядное дополнение) &nbsp;&nbsp;<i>b = ~a</i>
<li>Выполним дополнение до двух (точное дополнение), для чего добавим единицу к дополнению этого числа до единицы &nbsp;&nbsp;<i>c = b + 1</i>.
</ul>


<pre>
		int a = 5, b = ~a, c = b + 1;
		cout << a << "   " << b << "   " << c;

		получим результат:	5   -6   -5
</pre>
<p> &nbsp; </p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>