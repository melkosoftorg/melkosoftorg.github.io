<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | Лекция № 42</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=a>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=p>&nbsp 6 &nbsp</a></td>
<td><a href="07.htm" class=p>&nbsp 7 &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr>
<td class=usual>
<p align=center class=dbi><br>Конструкторы и деструкторы</p>
Для инициализации объектов класса в его определение можно явно включать 
специальную компонентную <a href="../../sem_1/14/index.htm">функцию</a>, называемую конструктор. <br><i><b>Формат определения 
конструктора в теле класса</b></i> может быть таким:
<pre>
                        имя_класса (список_формальных_параметров)
                        {
                                операторы_тела_конструктора
                        }
</pre>
Имя этой компонентной функции должно совпадать с именем класса. Такая функция 
автоматически вызывается при определении или размещении в памяти с помощью 
оператора <b><i>new</i></b> каждого объекта класса. <p><b><i>Основное назначение конструктора</i></b> - 
инициализация объектов. <p>В соответствии с синтаксисом языка для конструктора не 
определяется тип возвращаемого значения. Даже тип void недопустим. <br>С помощью 
параметров конструктору могут быть переданы любые данные, необходимые для создания 
и инициализации объектов класса.
<p>Конструктор вызывается тогда, когда создается объект. Объект создается при выполнении инструкции объявления объекта.
<br>Для глобальных объектов конструктор объекта вызывается тогда, когда начинается выполнение программы.
Для локальных объектов конструктор вызывается всякий раз при выполнении инструкции объявления переменной.
<p>Конструктор существует для любого класса, причем он может быть создан без явных 
указаний программиста. <br>В классе может быть несколько конструкторов (перегрузка), но 
только один с умалчиваемыми значениями параметров. <br>Нельзя получить адрес 
конструктора. <br>Параметром конструктора не может быть его собственный класс, но может 
быть ссылка на него.
<p>Конструктор нельзя вызывать как обычную компонентную функцию. <p><b>Для явного вызова 
конструктора можно использовать две разные синтаксические формы:</b><ul>
<li>первая форма <b><i>допускается только при непустом списке фактических параметров</i></b>. 
<br>Она предусматривает вызов конструктора при определении нового объекта данного 
класса
<p><center>имя_класса имя_объекта (фактические_параметры_конструктора);</center>
<p><li>вторая форма явного вызова конструктора <b><i>приводит к созданию объекта, не 
имеющего имени</i></b>. <br>Созданный таким вызовом безымянный объект может 
использоваться в тех выражениях, где допустимо использование объекта данного 
класса
<p><center>имя_класса (фактические_параметры_конструктора);</center></ul>
<p>Существуют <b>два способа инициализации данных объекта с помощью конструкторов:</b><ol>
<li>передача значений параметров в тело конструктора,
<p><li>предусматривает применение списка инициализаторов данных объекта. <br>Этот 
список помещается между списком параметров и телом конструктора:
<pre>
        имя_класса (список_параметров) <b>:</b> список_инициализаторов_компонентных_данных
        { 
                тело_конструктора
        }
</pre>
Каждый инициализатор списка относится к компоненту и имеет вид:
<p><center>имя_компонента_данных (выражение)</center>
<br><pre>
Например: 
	class AZ
	{
		int ii; float ее; char сс;
		public:
			AZ(int in, float en, char cn) : ii(5), ee(ii * en + in), cc(cn) 
			{  }
			<b>...</b>
	}; 
	// Создается именованный объект A с компонентами A.ii == 5, A.ее == 17, A.cc == 'd'
	AZ A(2, 3.0, 'd');
	// Создается безымянный объект, в котором ii == 5, ее == 10, cc == 'z', 
	// и копируется в объект Х
	AZ Х = AZ(0, 2.0, 'z');
</pre>
</ol>
<p><b>Противоположные действия по отношению к конструктору вызывают функции 
деструкторы классов (destructor), или разрушители объектов.</b> <p>Например, если объект 
некоторого класса формируется как локальный внутри блока, то целесообразно, чтобы 
при выходе из блока, когда уже объект перестает существовать, выделенная для него 
память была возвращена системе. Желательно, чтобы освобождение памяти происходило 
автоматически и не требовало вмешательства программиста.
<p>Для деструктора предусматривается стандартный формат:
<p><center>~имя_класса() { операторы_тела деструктора };</center>
<p>Название деструктора в C++ всегда начинается с символа тильда ~, за которым без 
пробелов или других разделительных знаков помещается имя класса. <br>У деструктора не 
может быть параметров (даже типа void). <br>Деструктор не имеет возвращаемого значения 
(даже типа void). <br>Вызов деструктора выполняется неявно, автоматически, как только 
объект класса уничтожается.
<p>Деструктор класса вызывается при удалении объекта. Локальные объекты удаляются тогда,
когда они выходят из области видимости. Глобальные объекты удаляются при завершении программы.
<pre>
	#include&lt;conio.h>
	#include&lt;iostream.h>
	class myclass
	{	int a;
		public:
			myclass();	// конструктор
			~myclass();	// деструктор
			void show();
	};
	myclass :: myclass()
	{	cout << "В конструкторе\n";
		a = 10;
	}
	myclass :: ~myclass()
	{	
		cout << "Удаление ...\n";
	}
	void myclass :: show()
	{
		cout << a << endl;
	}
	void main()
	{
		clrscr();
		myclass ob;		// Создать объект
		ob.show();
		getch();
	}
	  
	<i>Результаты выполнения программы:</i>		В конструкторе
							10
							Удаление ...
</pre>

<a name="01"></a>
<p>Перечисленные особенности конструкторов, соглашения о статусах доступа компонентов 
и понятие "деструктор" иллюстрирует определение класса "символьная строка". В 
примере в теле деструктора только один оператор, освобождающий память, выделенную 
для символьного массива при создании объекта класса stroka.
<pre>
	// STROKA.CPP - файл с определением класса "символьная строка"
	#include&lt;string.h&gt;
	#include&lt;iostream.h&gt;
	class stroka
	{	// Скрытые от внешнего доступа данные:
		char *ch;		// Указатель на текстовую строку
		int len;		// Длина текстовой строки
		// Общедоступные функции:
		public:	// Конструкторы объектов: Создает объект как новую пустую строку:
			stroka(int N = 80) <b>:</b> len(0)		// Строка не содержит информации
			{	ch = new char[N + 1];	// Память выделена для массива
				ch[0] = '\0';
			}
			stroka (const char *arch)		// Создает объект по заданной строке
			{	len = strlen(arch); ch = new char[len+1];
				strcpy(ch, arch);
			}
			int& len_str(void) { return len; }	// Возвращает ссылку на длину строки
			char *string(void) { return ch; }	// Возвращает указатель на строку
			void display(void)			// Печатает информацию о строке
			{	cout << "\nДлина строки: " << len;
				cout << "\nСодержимое: " << ch;
			}
			~stroka() { delete ch; }	// Деструктор - освобождает память объекта:
	};
</pre>
<p>В программе создаются объекты класса stroka и выводится информация на дисплей об их 
компонентах:
<pre>
        #include&lt;conio.h&gt;
        #include "stroka.cpp"		// Текст определения класса
        void main()
        {
                stroka LAT("Non Multa, Sed Multum!");
                stroka RUS("Не много, но многое!");
                stroka CTP(20);
                LAT.display();
                cout << "\n\nВ объекте RUS: " << RUS.string() << endl; CTP.display();
        }

        <b><i>Результат выполнения программы:</i></b>		Длина строки: 22
			                                	Содержимое: Non Multa, Sed Multum!
						В объекте RUS: Не много, но многое!
						Длина строки: 0
						Содержимое:
</pre>
<p> &nbsp; </p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=a>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=p>&nbsp 6 &nbsp</a></td>
<td><a href="07.htm" class=p>&nbsp 7 &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>