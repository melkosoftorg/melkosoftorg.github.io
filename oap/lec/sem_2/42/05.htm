<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | Лекция № 42</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=a>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=p>&nbsp 6 &nbsp</a></td>
<td><a href="07.htm" class=p>&nbsp 7 &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr>
<td class=usual>
<p align=center class=dbi><br>Компонентные функции</p>
Компонентная функция <b><i>должна быть обязательно описана в 
теле класса</i></b>. В отличие от обычных (глобальных) функций компонентная функция имеет 
доступ ко всем компонентам класса (с любым статусом доступа).<br>Функция - компонент 
класса имеет ту же область видимости, что и класс, к которому она относится.
<p>В языке C++ программист может влиять на компилятор, предлагая ему оформить ту или 
иную <a href="../../sem_1/12/05.htm">функцию как подставляемую (встраиваемую)</a>. Для этих целей в определении 
функции указывается служебное слово (спецификатор) inline. Модификатор inline, 
помещенный перед типом возвращаемого функцией значения в определении функции, 
рекомендует компилятору генерировать в месте вызова функции копию ее кода (если это 
возможно) с тем, чтобы избежать вызова функции. Подобные действия обоснованы для 
небольших по размеру и часто вызываемых функций. В рассматриваемой программе 
встраиваемая (inline) функция вычисляет объем параллелепипеда. Аргументы по 
умолчанию - самые правые аргументы в списке параметров.
<pre>
		#include&lt;conio.h&gt;
		#include&lt;iostream.h&gt;
		inline int boxVol(int l = 1, int w = 1, int h = 1)
		{
			return l * w * h;
		}
		main()
		{	clrscr();   cout << "Объем параллелепипеда\n\n";
			cout << "Размером по умолчанию " << boxVol();
			cout << "\n10 x 1 x 1 равен " << boxVol(10);
			cout << "\n10 x 5 x 1 равен " << boxVol(10, 5);
			cout << "\n10 x 5 x 3 равен " << boxVol(10, 5, 3);
			getch(); return 0;
		}

	<b><i>Результаты выполнения программы:</i></b>	Объем параллелепипеда
						Размером по умолчанию 1
						10 x 1 x 1 равен 10
						10 x 5 x 1 равен 50
						10 x 5 x 3 равен 150
</pre>
<p>При определении классов их компонентные функции также могут быть специфицированы 
как подставляемые. Кроме явного использования служебного слова inline для этого 
используется соглашение: если определение (не только прототип) принадлежащей классу 
функции полностью размещено в классе (в теле класса), то эта функция по умолчанию 
считается подставляемой. То есть, при каждом вызове этой функции ее код "встраивается" 
непосредственно в точку вызова, что не всегда удобно, так как подставляемыми могут 
быть не всякие функции. (Подставляемая функция не может быть рекурсивной, не может 
содержать циклы, переключатели и так далее.). <br>Это имеет смысл для очень коротких 
функций, как, например, функции print и put_x следующей программы.
<pre>
	#include&lt;iostream.h&gt;
	#include&lt;conio.h&gt;
	struct example		// компоненты структуры по умолчанию имеют атрибут public
	{
		void print(void)	// Подставляемая компонентная функция
			{ cout << "использование структуры\n"; }
		private:
			int a;		// a будет иметь атрибут private
		public:			// остальные компоненты имеют атрибут public
			example(int A) { a = A; }	// Конструктор
			void put_x(void)		// Подставляемая компонентная функция
				{ cout << "Вывод значения a для примера: " << a << "\n"; }
	};
	main()			
	{	// объявление объекта типа example
		example ex1(55); clrscr();
		ex1.print(); ex1.put_x(); getch();
	}
	
	<b><i>Результаты выполнения программы:</i></b>	использование структуры
						Вывод значения a для примера: 55
</pre>
<p>Существует второй способ определения принадлежащих классу функций. Он состоит в 
том, что внутри тела класса помещается только прототип компонентной функции, а ее 
определение - вне класса, как определение любой другой функции, входящей в 
программу. При таком внешнем определении компонентной функции она может быть 
снабжена спецификатором inline, но при этом опять возникнут указанные ограничения, 
накладываемые на подставляемые функции.
<p><b>При внешнем определении компонентной функции</b> программист "должен сообщить" 
компилятору, к какому именно классу она относится. <br>Для этого используется бинарная 
форма операции <b>::</b> (указания области видимости). <br>Формат ее использования в этом 
случае таков:
<p><center>имя_класса <b>::</b> имя_компонентной_функции</center>
<p>Приведенная конструкция, называемая квалифицированным именем компонентной 
функции, означает, что функция есть компонент класса и лежит в области его действия. 
Именно такое определение привязывает функцию к классу и позволяет в ее теле 
непосредственно использовать любые данные класса (его объектов) и любые 
принадлежащие классу функции. (Это относится и к собственным private, и к 
защищенным protected-компонентам.)
<p>При внешнем определении компонентной функции в теле класса помещается ее 
прототип:
<p><center>тип имя_функции(спецификация_и_инициалиэация_параметров);</center>
<p><b>Вне тела класса компонентная функция определяется</b> таким образом:
<p><center>тип имя_класса <b>::</b> имя_функции (спецификация_формальных_параметров)
<br>{ тело_принадлежащей_классу_функции }</center>
<p>Применение в качестве ключа класса служебного слова union приводит к созданию 
классов с несколько необычными свойствами, которые нужны для весьма специфических 
приложений. <p>Пример такого приложения - экономия памяти за счет многократного 
использования одних и тех же участков памяти для разных целей. В каждый момент 
времени исполнения программы объект - объединение содержит только один компонент 
класса, определенного с помощью union. Все компоненты этого класса являются 
общедоступными.
<pre>
	#include&lt;iostream.h&gt;
	#include&lt;string.h&gt;
	#include&lt;conio.h&gt;
	union my_union			// по умолчанию атрибут public
	{	char str[14];
		struct str1_2
		{
			char str1[5]; char str2[8];
		} my_s;
		my_union(char *s);		// Конструктор
		void print(void);		// Описание функции
	};
	my_union <b>::</b> my_union(char *s)		// Конструктор
		{ strcpy(str, s); }
	void my_union <b>::</b> print(void)		// Определение функции
	{	cout << my_s.str2 << '\n';
		my_s.str2[0] = 0; cout << my_s.str1 << '\n';
	}
	void main(void)
	{	clrscr(); my_union ob("МинскБеларусь");
		ob.print(); getch();
	}

	<b><i>Результаты выполнения программы:</i></b>	Беларусь
						Минск
</pre>
<br>Сначала функция print выводит байты из строки my_s.str2. Там будет записано: Беларусь\0. 
<br>Затем в нулевой байт my_s.str2 записывается заключительный нуль и вывод строки my_s.str1 будет осуществляться до этого байта.
<p><b>Изменить статус доступа к компонентам класса</b> можно и с помощью использования в 
определении класса ключевого слова <b>class</b>. 
<br>Все компоненты класса, определение которого начинается со служебного слова class, являются собственными (private), то есть 
недоступными для внешних обращений. 
<a name="01"></a>
<br>Рассмотрим использование класса point.
<pre>
	// POINT.H - описание класса с внешними определениями методов
	#ifndef POINTH
	#define POINTH 1
	class point
	{	// Точка на экране дисплея
		protected:		// Защищенные данные класса:
			int x, y;	// Координаты точки
		public:		// Прототипы общедоступных компонентных функций:
			point(int xi = 0, int yi = 0);	// Конструктор
			int& givex (void);		// Доступ к х
			int& givey (void);		// Доступ к у
			void show(void);		// Изобразить точку на экране
			// Переместить точку в новое место экрана:
			// (xn == 0, yn == 0 - умалчиваемые значения параметров)
			void move(int xn = 0, int yn = 0) ; 
		private:		// Собственная функция класса:
			void hide();		// Убрать с экрана изображение точки
	};
	#endif
</pre>
<br>Так как описание класса point в дальнейшем планируется включать в другие классы, то 
для предотвращения недопустимого дублирования описаний, в текст программы 
включена <b><i><a href="../47/06.htm">условная препроцессорная директива</a> #ifndef POINTH</i></b>. <br>Препроцессорный 
идентификатор POINTH определяется с помощью директивы #define POINTH 1. Тем 
самым текст описания класса point может появляться в компилируемом файле только 
однократно, несмотря на возможность неоднократных появлений директив #include 
"point.h". <br>В прототипе конструктора и в прототипе функции move() имена формальных 
параметров xi, yi, xn, yn можно было бы опустить.
<p>Описание класса с внешним определением его компонентных функций дает возможность, 
не меняя интерфейс объектов класса с другими частями программы, по-разному 
определять его компонентные функции. <br>В примере понятие "точка на экране дисплея" 
можно трактовать несколькими способами. Принципиально различных здесь два подхода: 
<ul><li>использование графического режима дисплея,<li>работа с дисплеем в текстовом 
режиме.</ul><br>Определим компонентные функции класса point следующим образом:
<pre>
	// POINT.СРР - внешнее определение функций класса
	#ifndef POINTCPP
	#define POINTCPP 1
	#include&lt;graphics.h&gt;
	#include "..\\h\\point.h"					// Описание класса point
	// Определение данных объекта
	point <b>::</b> point(int xi, int yi) { x = xi; y = yi; }			
	int& point <b>::</b> givex (void) { return x; }				// Доступ к х
	int& point <b>::</b> givey (void) { return y; }				// Доступ к y
	void point <b>::</b> show(void) { putpixel(x, y, getcolor()); }		// Изобразить точку на экране
	void point <b>::</b> hide(void) { putpixel (x, y, getbkcolor()); }		// Убрать изображение точки
	void point <b>::</b> move(int xn, int yn) { hide(); x = xn; y = yn; show(); }	// Переместить точку
	#endif
</pre>
Как и текст в файле point.h, определения компонентных функций защищены условной 
препроцессорной директивой от дублирования.<br>В определении методов класса point 
используются следующие графические функции:<ul>
<li>void putpixel(int x, int у, int color) - изображает цветом color точку на экране дисплея с координатами (x, y);
<li>int getbkcolor(void) - возвращает номер цвета фона;
<li>int getcolor(void) - возвращает номер цвета изображения.</ul>
Удаление точки с экрана полностью подобно ее изображению, но в качестве цвета рисования выбирается цвет фона.
<p>Конструктор point и прототип функции move () снабжены умалчиваемыми значениями 
параметров. Координаты создаваемой по умолчанию (без указания значений параметров) 
точки равны нулю. Туда же по умолчанию перемещается точка.
<p>Внешнее определение методов класса в противоположность встроенному определению 
позволяет модифицировать принадлежащие классу функции, не изменяя текста описания 
класса. При таком определении методы обычно оформляются компилятором в виде 
глобальных функций, которые вызываются при обращениях к принадлежащим функциям.
<pre>
	#include&lt;graphics.h>		// работа с классом "точка на экране"
	#include&lt;conio.h>
	#include&lt;stdio.h>
	#include&lt;stdlib.h>
	#include "point.cpp"		// Определение класса point
	#include "..\\h\\init.h"
	void main()
	{
		init();
		point A(200, 50);	// Создается невидимая точка А
		point B;		// Невидимая точка B с нулевыми координатами по умолчанию
		point D(500, 200);	// Создается невидимая точка D
		A.show(); getch();		// Показать на экране точку A
		B.show(); getch();		// Показать на экране точку B
		D.show(); getch();		// Показать на экране точку D
		A.move(); getch();		// Переместить точку A
		B.move(50, 60);		// Переместить точку B
		getch(); closegraph ();	// Закрыть графический режим
	}
</pre>
<p> &nbsp; </p>
</td>
</tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=a>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=p>&nbsp 6 &nbsp</a></td>
<td><a href="07.htm" class=p>&nbsp 7 &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>