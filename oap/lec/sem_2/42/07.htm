<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | Лекция № 42</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=p>&nbsp 6 &nbsp</a></td>
<td><a href="07.htm" class=a>&nbsp 7 &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr>
<td class=usual>
<p align=center class=dbi><br>Обращение к компонентам класса</p>
Как только объект класса определен, появляется возможность обращаться к его компонентам.
<p>Существуют различия между обращениями к компонентным данным класса из 
принадлежащих ему функций и из других частей программы.
<p><b><i>Принадлежащие классу функции, имеют полный доступ к его данным</i></b>, то есть для 
обращения к элементу класса из тела компонентной функции достаточно использовать 
только имя элемента.<p>Например, <a href="03.htm#01">в конструкторе класса stroka</a> использован оператор: ch = new char[len + 1];
<br>При определении объекта line класса stroka: stroka line(20); значения присваиваются 
именно переменным line<b>.</b>len и line<b>.</b>ch.
<p><b>Для доступа к компонентным данным из операторов, выполняемых вне определения 
класса</b>, непосредственное использование имен элементов недопустимо. <br>Для обращения к 
элементу объекта нужно использовать операции выбора компонентов класса <br>(<b>.</b> или <b>-></b> )
<ul><li><b><i>с помощью "квалифицированных" имен</i></b>, каждое из которых имеет формат:
<p><center>имя_объекта.имя_класса <b>::</b> имя_компонента</center>
<p>Имя класса с операцией уточнения области действия <b>::</b> обычно может быть опущено, и 
чаще всего для доступа к данным конкретного объекта заданного класса (как и в 
случае структур) используется уточненное имя:<p><center>имя_объекта<b>.</b>имя_элемента</center>
<p>При этом возможности те же, что и при работе с элементами структур. <br>Например, 
можно явно присвоить значения элементам объектов класса example: <p><center>X1<b>.</b>a = dim[3]<b>.</b>a = 2;</center>
<br>Уточненное имя принадлежащей классу (то есть компонентной) функции:
<p><center>имя_объекта<b>.</b>обращение_к_компонентной_функции</center>
<br>обеспечивает вызов компонентной функции класса для обработки данных именно того 
объекта, имя которого использовано в уточненном имени. <br>Например, можно таким 
образом определить значения компонентных данных для определенных объектов 
класса example:
<pre>
	ex1.print();	// Текст "использование структуры"
	ex1.put_x();	// Параметры выбираются a == 55
</pre>
<li>другой способ доступа к элементам объекта некоторого класса предусматривает 
<b><i>явное использование указателя на объект класса и операции косвенного выбора 
компонента</i></b>:
<p><center>указатель_на_объект_класса <b>-></b> имя_элемента</center>
<p>Определив указатель point, адресующий объект D класса example, можно следующим 
образом присвоить значения данным объекта D:
<p><center>point <b>-></b> a = 3; &nbsp; // Присваивание значения элементу объекта D</center>
<br>Указатель на объект класса позволяет вызывать принадлежащие классу функции для 
обработки данных того объекта, который адресуется указателем. Формат вызова 
функции:
<p><center>указатель_на_объект_класса -> обращение_к_компонентной_функции</center>
<br>Например, вызвать компонентную функцию print() для данных объекта D позволяет 
выражение: <p><center>point <b>-></b> print();</center></ul>
<pre>
	#include&lt;iostream.h&gt;		// Операции доступа к компонентам класса <b>.</b> и <b>-></b>
	#include&lt;conio.h&gt;
	class Count
	{	public:	int x;
			void print() { cout << x << endl; }
	};
	main()
	{	Count   counter,		// объект counter
		&counterRef = counter,	// ссылка на counter
		*counterPtr = &counter;	// указатель на counter
		clrscr(); cout << "Присваивание x = 7 и печать по имени объекта: ";
		counter<b>.</b>x = 7; counter<b>.</b>print();
		cout << "Присваивание x = 8 и печать по ссылке: ";
		counterRef<b>.</b>x = 8; counterRef<b>.</b>print();
		cout << "Присваивание x = 10 и печать по указателю: ";
		counterPtr <b>-></b> x = 10; counterPtr <b>-></b> print(); getch(); return 0;
	}
	
	<b><i>Результаты работы программы:</i></b>
					Присваивание x = 7 и печать по имени объекта: 7
					Присваивание x = 8 и печать по ссылке: 8
					Присваивание x = 10 и печать по указателю: 10
</pre>
Данные класса не обязательно должны быть определены или описаны до их первого 
использования в принадлежащих классу функциях. <br>То же самое справедливо и для 
принадлежащих классу функций, то есть обратиться из одной функции класса к другой 
можно до ее определения внутри тела класса. Все компоненты класса "видны" во всех 
операторах его тела. 
<p> &nbsp; </p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=p>&nbsp 6 &nbsp</a></td>
<td><a href="07.htm" class=a>&nbsp 7 &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>