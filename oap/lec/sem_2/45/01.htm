<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | Лекция № 45</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=a>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=p>&nbsp 6 &nbsp</a></td>
<td><a href="07.htm" class=p>&nbsp 7 &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr>
<td class=usual>
<p align=center class=dbi><br>Наследование классов</p>
<b><i>Наследование (inheritance)</i></b> - возможность создания новых классов на основе существующих классов.
<br><i>Наследование</i> - один из главных механизмов языка C++. С его помощью 
можно разрабатывать очень сложные классы, продвигаясь от общего к частному, а также 
"наращивать" уже созданные, получая из них новые классы, немного отличающиеся от 
исходных классов.
<p>Собираясь проектировать сложный класс, необходимо решить, какими наиболее общими 
свойствами должны обладать его объекты, и нет ли похожего на него готового класса. 
<p>Продумать план вновь разрабатываемого класса, а затем переходить к постепенной 
детализации, создавая на основе уже построенных классов новые, которые наследуют 
(inherit) от них свойства и поведение (то есть члены-данные и функции-члены), 
приобретая в то же время новые качества.
<p><i>Класс, на основе которого строится другой класс, класс, который наследуется другим классом, называется <b>базовым классом.</i></b>
<p><i>Построенный класс называется <b>производным классом</b> или подклассом.</i>
<p><table width="100%">
<tr><td align=left valign=top><img src="l47_02.gif" alt="" ismap>
</td><td valign=top><b><i>Человек.</i></b> Мир населен людьми. Любого человека можно описать набором характеристик: фамилию и имя, возраст, страна проживания, ...
<p><b><i>Работник.</i></b> Не все люди работают в фирмах, однако все, кто работает в них, являются людьми. Работник фирмы обладает всеми перечисленными выше характеристиками человека, но при этом у него
есть дополнительные свойства: название фирмы, где он работает, размер заработной платы, ...
<p><b><i>Студент.</i></b> Студент - это не работник фирмы, но тоже человек. У него также есть все описанные выше характеристики человека, плюс некоторые дополнительные:
учебное заведение и специальность, номер студенческого билета, ...
</td></tr></table>
<p>Работник и студент наследуют свойства человека. Поэтому, создавая класс людей вообще, работников фирм и студентов, можно сделать несколько выводов:
<ul><li type="disc"><i>Человек</i> считается базовым классом.
<li type="disc"><i>Работник</i> и <i>Студент</i> являются подклассами, то есть производными классами.
<li type="disc">Между классами <i>Работник</i> и <i>Студент</i> нет взаимосвязи, хотя оба происходят от одного базового класса <i>Человек</i>.
</ul>
<p>Для задания шаблона производного класса используется следующий синтаксис:
<pre>
	class имя_производного_класса : спецификатор_доступа имя_базового_класса
	{
		тело_производного_класса
	} объекты_производного_класса (через запятую);
</pre>
<p>Создадим базовый класс person (компонентные данные: фамилия, имя, возраст) и производный от него класс employee (компонентные данные: заработная плата).
<br><i>Курсивом</i> выделены фрагменты программного кода, относящиеся к классу employee и его объектам.
<pre>
	#include&lt;conio.h>
	#include&lt;iostream.h>
	#include&lt;string.h>
	#define MAX_LEN 81
	// Базовый класс
	class person
	{
		// модификатор protected разрешает доступ к данным только
		// из самого класса и его наследников
		protected:
			char lname[MAX_LEN];
			char fname[MAX_LEN];
			int age;
		public:
			void set_lname(char ln[]) { strcpy(lname, ln); }
			void set_fname(char fn[]) { strcpy(fname, fn); }
			void set_age(int a) { age = a; }
			char *get_name(char *fullname);
			int get_age(void) { return age; }
			person(char ln[] = "бланк", char fn[] = "бланк");
	};
	<i>// Класс производный от класса person.
	// Наличие ключевого слова public дает право классу employee 
	// обращаться к данным объектов типа person
	class employee : public person
	{
		// добавляются только те данные и методы, которых нет в базовом классе
		protected:
			long salary;
		public:
			void set_salary(long sal) { salary = sal; }
			long get_salary() { return salary; }
			employee(char ln[] = "e_бланк", char fn[] = "e_бланк");
	};</i>
	// Конструктор класса person
	person :: person(char ln[], char fn[])
	{	strcpy(lname, ln);
		strcpy(fname, fn);
		age = -1;
	}
	char *person :: get_name(char fullname[])
	{	strcpy(fullname, lname);
		strcat(fullname, " ");
		strcat(fullname, fname);
		return fullname;
	}
	<i>// Конструктор класса employee
	employee :: employee(char ln[], char fn[]) : person(ln, fn)
	{ salary = 0; }</i>
	void main()
	{
		char full[MAX_LEN + MAX_LEN];
		// объекты класса person
		person brad("Иванов", "Петр");
		brad.set_age(21);
		person blank;	// для инициализации - в конструкторе значения по умолчанию
		clrscr();
		cout << "\nЧеловек  brad: " << brad.get_name(full);
		cout << "\n      возраст: " << brad.get_age() << endl;
		cout << "\nЧеловек blank: " << blank.get_name(full);
		cout << "\n      возраст: " << blank.get_age() << endl;
		<i>// объекты класса employee
		employee kyle("Петров", "Иван");
		kyle.set_salary(50000);
		kyle.set_age(32);
		// Если в конструктор класса не передавать параметры, будут использованы параметры по умолчанию
		// employee kyle;
		cout << "\nРаботник kyle: " << kyle.get_name(full);
		cout << "\n      возраст: " << kyle.get_age();
		cout << "\n      зарплата: " << kyle.get_salary() << endl;</i>
		getch();
	}
	<i>Результаты выполнения программы:</i>
				Человек  brad: Иванов Петр
				      возраст: 21

				Человек blank: бланк бланк
				      возраст: -1

				Работник kyle: Петров Иван
				      возраст: 32
				      зарплата: 50000
</pre>
<p>При создании объекта employee фактически сначала создается объект person, а затем уже employee.
<br>При вызове конструктора класса employee вначале вызывается конструктор базового класса person.
Только после его завершения вызывается конструктор подкласса.
<br>Объект не считается созданным до тех пор, пока не будут выполнены оба конструктора по порядку.
<p><b><i>Спецификатор доступа в шаблоне производного класса</i></b> определяет то, как элементы базового класса наследуются производным классом.
<br>Если спецификатором доступа наследуемого базового класса является ключевое слово
<ul><li><b><i>public</i></b>, то все открытые члены базового класса остаются открытыми и в производном.
<br>Поскольку класс base наследуется как открытый, открытые члены класса base -
функции setx() и showx() - становятся открытыми производного класса derived
и поэтому доступны из любой части программы.
<br>Следовательно, совершенно правильно вызывать эти функции из функции main().
<pre>
	#include&lt;iostream.h>
	#include&lt;conio.h>
	class base
	{	int x;
		public:
			void setx(int n) { x = n; }
			void showx() { cout << x << '\n'; }
	};
	// Класс наследуется как открытый
	class derived : public base
	{	int y;
		public:
			void sety(int n) { y = n; }
			void showy() { cout << y << '\n'; }
			// Следующая строка вызовет ошибку поскольку
			// x - закрытый член базового класса недоступен
			// в производном классе - открыть ее и проверить
			// void show_sum() { cout << x + y << '\n'; }
	};
	int main()
	{	clrscr(); derived ob;
		ob.setx(10);	// доступ к члену базового класса
		ob.sety(20);	// доступ к члену производного класса
		ob.showx();	// доступ к члену базового класса
		ob.showy();	// доступ к члену производного класса
		getch(); return 0;
	}
	
	<i>Результаты выполнения программы:</i>
			10
			20
</pre>
<li><b><i>private</i></b>, то все открытые члены базового класса в производном классе становятся закрытыми.
<br>Если в предыдущей программе сделать наследование базового класса с ключевым словом private,
то получим ошибку, поскольку функции showx() и setx() становятся закрытыми в производном классе и недоступны вне его.
<br>Внутри производного класса они остаются доступными.
<pre>
	#include&lt;iostream.h>
	#include&lt;conio.h>
	class base
	{	int x;
		public:
			void setx(int n) { x = n; }
			void showx() { cout << x << '\n'; }
	};
	// Класс наследуется как закрытый
	class derived : private base
	{	int y;
		public:
			// переменная setx доступна внутри класса derived
			void setxy(int n, int m)
			{	setx(n);
				y = m;
			}
			// переменная showx доступна внутри класса derived
			void showxy()
			{	showx();
				cout << y << '\n';
			}
	};
	int main()
	{	clrscr();
		derived ob;
		ob.setxy(10, 20);
		ob.showxy();
		getch(); return 0;
	}
	
	<i>Результаты выполнения программы:</i>
			10
			20
</pre></ul>
<p>В обоих случаях все закрытые члены базового класса в производном классе остаются закрытыми и недоступными.
<p><b><i>Спецификатор доступа protected</i></b> эквивалентен спецификатору private с единственным исключением:
<ul><li>защищенные члены базового класса доступны для членов всех производных классов этого базового класса.
<li>вне базового или производных классов защищенные члены класса недоступны.
</ul>
<p>Когда базовый класс наследуется как
<ul><li>открытый - public - защищенный член базового класса становится защищенным членом производного класса.
<li>закрытый - private - защищенный член базового класса становится закрытым членом производного класса.
<li>защищенный - protected - открытые и защищенные члены базового класса становятся защищенными членами производного класса.
</ul>
<p>Следующая программа иллюстрирует доступ к открытым, закрытым и защищенным членам класса.
<pre>
	#include&lt;iostream.h>
	#include&lt;conio.h>
	class samp
	{	// члены класса, закрытые по умолчанию
		int a;
		protected:	// тоже закрытые члены класса samp
			int b;
		public:
			int c;
			samp(int n, int m) { a = n; b = m; }
			int geta() { return a; }
			int getb() { return b; }
	};
	int main()
	{	samp ob(10, 20); clrscr();
		// Ошибка! Переменная b защищена и поэтому закрыта
		// ob.b = 99;
		// Правильно! Переменная c является открытым членом
		ob.c = 30; 
		cout << ob.geta() << ' ' << ob.getb() << ' ' << ob.c << '\n';
		getch(); return 0;
	}

	<i>Результаты выполнения программы:</i>		10 20 30
</pre>
<p>В следующей программе показано, что происходит, если защищенные члены класса наследуются как открытые.
<pre>
	#include&lt;iostream.h>
	#include&lt;conio.h>
	class base
	{	// закрытые члены класса base, но для производного класса они доступны
		protected:     
			int a, b;   
		public:
			void setab(int n, int m) { a = n; b = m; }
	};
	class derived : public base
	{	int c;
		public:
			void setc(int n) { c = n; }
			// эта функция имеет доступ к переменным a и b класса base
			void showabc()
			{
				cout << a << ' ' << b << ' ' << c << '\n';
			}
	};
	int main()
	{	clrscr();
		derived ob;
		// Переменные a и b здесь недоступны, поскольку являются
		// закрытыми членами классов base и derived
		ob.setab(1, 2); 
		ob.setc(3); 
		ob.showabc(); 
		getch(); return 0;
	}

	<i>Результаты выполнения программы:</i>		1 2 3
</pre>
<p>Технически спецификатор_доступа (public, private, protected) является необязательным атрибутом при определении производного класса.
<br>Если спецификатор доступа не указан и базовый класс определен с ключевым словом
<ul><li><b><i>class</i></b>, то базовый класс по умолчанию наследуется как закрытый.
<li><b><i>struct</i></b>, то базовый класс по умолчанию наследуется как открытый.
</ul>
<p>Например, в программе раздела <a href="../44/02.htm#01">"Друзья классов"</a>: &nbsp; &nbsp; &nbsp; class Point <b>:</b> public Location {...};
<p>Класс Location является базовым и имеет атрибут public. <br>Класс Point является 
производным. <br>Список объектов опущен (после закрывающейся фигурной скобки стоит 
точка с запятой). <br>Двоеточие <b>:</b> отделяет производный класс от базового класса. <br>Атрибут 
класса задается ключевыми словами private и public. Он тоже может опускаться, в этом 
случае принимается атрибут, заданный по умолчанию (для классов он private, а для 
структур - public).<br>Объединение (union) не может быть базовым или производным 
классом.
<p><b><i>Иерархия классов позволяет определять новые классы на основе уже имеющихся.</i></b>
<p>Имеющиеся классы обычно называют базовыми (иногда порождающими), а новые 
классы, формируемые на основе базовых, - производными (порожденными), иногда 
классами-потомками или наследниками.<p><b><i>Производные классы</i></b> "получают наследство" - 
данные и методы своих базовых классов - и, кроме того, могут пополняться собственными 
компонентами (данными и собственными методами).<br>Наследуемые компоненты не 
перемещаются в производный класс, а остаются в базовых классах.<br>Сообщение, обработку 
которого не могут выполнить методы производного класса, автоматически передается в 
базовый класс. Если для обработки сообщения нужны данные, отсутствующие в 
производном классе, то их пытаются отыскать автоматически и незаметно для 
программиста в базовом классе.
<p>Если класс "точка (позиция) на экране" считать базовым классом, то на его основе можно 
построить класс "окно на экране". <br>Данными этого класса будут две точки:<ul>
<li>точка, определяющая левый верхний угол;
<li>точка, определяющая размеры окна, то есть смещения вдоль координатных осей относительно левого верхнего угла.</ul>
<p>Методы класса "окно на экране":<ul>
<li>сместить окно вдоль оси X на DX;
<li>сместить окно вдоль оси Y на DY;
<li>сообщить значение координаты х левого верхнего угла;
<li>сообщить значение координаты y левого верхнего угла;
<li>сообщить размер окна вдоль оси X;
<li>сообщить размер окна вдоль оси Y.</ul>
<p>Конструктор окна на экране: создать окно на экране с заданным именем по двум точкам, определяющим левый верхний угол окна и его размеры.
<p>Деструктор окна на экране: уничтожить окно с заданным именем.
<p>При наследовании некоторые имена методов (компонентных функций) и (или) 
компонентных данных базового класса могут быть по-новому определены в производном 
классе. В этом случае соответствующие компоненты базового класса становятся 
недоступными из производного класса.<p>Для доступа из производного класса к 
компонентам базового класса, имена которых повторно определены в производном 
классе, используется <b><i>операция</i> :: <i>указания (уточнения) области видимости.</i></b>
<p>Любой производный класс может становиться базовым для других классов, и таким 
образом формируется направленный граф иерархии классов и объектов. В иерархии 
производный объект наследует разрешенные для наследования компоненты всех базовых 
объектов. Другими словами, у объекта имеется возможность доступа к данным и методам 
всех своих базовых классов.
<p>Допускается множественное наследование - возможность для некоторого класса 
наследовать компоненты нескольких никак не связанных между собой базовых классов. 
<br>Например, класс "окно на экране" и класс "сообщение" совместно могут формировать 
новый класс объектов "сообщение в окне".
<p> &nbsp; </p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=a>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=p>&nbsp 6 &nbsp</a></td>
<td><a href="07.htm" class=p>&nbsp 7 &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>