<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | Лекция № 45</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=a>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=p>&nbsp 6 &nbsp</a></td>
<td><a href="07.htm" class=p>&nbsp 7 &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr>
<td class=usual>
<p align=center class=dbi><br>Построение производного класса</p>
Построим на основе класса <a href="../42/05.htm#01">point</a> производный класс spot (пятно). <p>Наследуемые 
компоненты класса point:<ul>
<li>int x, y - координаты точки на экране;
<li>point() - конструктор;
<li>givex(), givey() - доступ к координатам точки;
<li>show() - изобразить точку;
<li>move() - переместить точку.
</ul>
Введем дополнительно к наследуемым компонентам в класс spot:<ul>
<li>радиус пятна (rad);
<li>его видимость на экране (vis == 0, когда изображения нет на экране, vis == 1 - изображение есть на экране);
<li>признак сохранения образа в оперативной памяти (tag == 0 - битовый образ не хранится, tag == 1 - битовый образ хранится в памяти);
<li>указатель pspot на область памяти, выделенную для хранения битового образа изображения.
</ul>
<a name="01"></a>
<pre>
	// SPOT.CPP - класс, наследующий данные и методы класса POINT
	#ifndef SPOT
	#define SPOT 1
	#include "point.cpp"	// Определение класса point public позволит сохранить статусы
				// доступа для наследуемых компонентов класса point:
	class spot <b>:</b> public point
	{	protected:		// Статус доступности данных в производных классах
			int rad;		// Радиус пятна (изображения)
			int vis;		// Видимость пятна на экране
			int tag;		// Признак сохранения образа в памяти
			void *pspot;	// Указатель на область памяти для изображения
		public:	// Конструктор класса spot: Вызов конструктора базового класса
			spot(int xi, int yi, int ri) <b>:</b> point (xi, yi)
			{	int size;
				vis =0; tag = 0; rad = ri;
				// Определить размеры битового образа (для изображения):
				size = imagesize(xi - ri, yi - ri, xi + ri, yi + ri);
				// Выделить память для битового образа
				pspot = new char[size];
			}
			~spot()			// Деструктор класса SPOT
			{	hide();		// Убрать с экрана изображение пятка
				tag = 0;		// Сбросить признак сохранения в памяти
				// Освободить память, где находился битовый образ
				delete pspot;
			}
			void show()		// Изобразить пятно на экране дисплея
			{	if (tag == 0)	// Если битового образа нет в памяти:
				{	// Нарисовать окружность на экране
					circle(x, y, rad);
					floodfill(x, y, getcolor());	// Закрасить пятно
					// Запомнить битовый образ в памяти:
					getimage(x - rad, y - rad, x + rad, y + rad, pspot); tag = 1;
				}
				else	// Перенести изображение из памяти на экран:
					putimage(x - rad, y - rad, pspot, XOR_PUT);
				vis = 1;
			}
			void hide()		// Убрать с экрана изображение пятна
			{	if (vis == 0)	// Нечего убирать
					return;
				// Стереть изображение
				putimage(x - rad, y - rad, pspot, XOR_PUT);
				vis = 0;
			}
			void move(int xn, int yn)	// Переместить изображение:
			{	hide();		// Убрать старое изображение с экрана
				x = xn; y = yn;	// Изменить координаты центра пятна:
				show();		// Вывести изображение в новом месте
			}
			void vary (float dr)		// Изменить размер изображения пятна:
			{	float a; int size;
				hide();		// Убрать старое изображение с экрана
				tag = 0;
				delete pspot;	// Освободить память битового образа:
				a = dr * rad;	// Вычислить новый радиус:
				if (a <= 0)	rad = 0;
				else	rad = (int)a;
				// Определить размеры битового образа:
				size = imagesize(x - rad, y - rad, x + rad, y + rad);
				new char[size];	// Выделить память для нового образа:
				show();		// Изобразить пятно на экране
			}
			int& giver(void)		// Доступ к радиусу пятна
			{ return rad; }
	};
	#endif
</pre>
<p><b><i>В классе spot явно определены</i></b> конструктор, деструктор ~spot() и пять методов:<ul>
<li>show() - вывести на экран изображение пятна, затем перенести его битовый образ в память;
<li>hide() - убрать с экрана изображение пятна;
<li>move() - переместить изображение в другое место на экране;
<li>vary() - изменить (уменьшить или увеличить) изображение на экране;
<li>giver() - обеспечить доступ к радиусу пятна.</ul>
<br><b><i>Из класса point</i></b> класс spot наследует<ul><li>координаты (х, y) точки (центра пятна),<li>методы 
givex(), givey().</ul>
<br>Методы &nbsp; point <b>::</b> show() &nbsp; point <b>::</b> move() &nbsp; заменены в классе spot новыми функциями с такими же именами, 
функция &nbsp; point <b>::</b> hide() &nbsp; не наследуется, так как в классе point она имеет статус собственного компонента (private).
<p><b><i>Конструктор spot()</i></b> имеет три параметра - координаты центра (xi, yi) и радиус пятна на 
экране (ri). <p><b><i>При создании объекта класса spot</i></b> вначале вызывается конструктор класса 
point, который по значениям фактических параметров, соответствующих xi, yi, определяет 
точку - центр пятна. Эта точка создается как безымянный объект класса point. 
(Конструктор базового класса всегда вызывается и выполняется до конструктора 
производного класса.) <br>Затем выполняются операторы конструктора spot(). Здесь 
устанавливаются начальные значения признаков vis, tag, и по значению фактического 
параметра, соответствующего формальному параметру ri, определяется радиус пятна rad. 
<br>С помощью стандартной функции inagesize() из графической библиотеки GRAPHICS.LIB 
вычисляется объем памяти (вспомогательная переменная size), требуемый для сохранения 
прямоугольного (квадратного) участка экрана, на котором предполагается изобразить 
пятно. <br>Выделение участка основной памяти нужного объема выполняет стандартная 
операция new, операнд которой - это массив типа char из size элементов. <br>Выделенная 
память связывается с указателем pspot, имеющим в классе spot статус protected. <br>На этом 
работа конструктора заканчивается.
<p>В функциях show() - изобразить пятно на экране, vary() - изменить размер изображения и 
hide () - убрать изображение пятна с экрана используются возможности графических 
функций. 
<p>Правила выбора цвета при размещении на экране битового образа устанавливаются с 
помощью функции putimage(). Если в режиме XOR_PUT изображение вывести на экран в 
то же место, где уже было то же самое изображение, то изображение исчезнет с экрана. 
Флажок видимости пятна на экране vis необходим для распознавания необходимости 
повторного применения функции putimage().
<p>Функция show () выполняется в разных режимах в зависимости от значения признака tag 
записи изображения в память.<ul><li>Если значение tag равно 0, то рисуется и закрашивается 
окружность, затем ее образ переписывается в память функцией getimage() и 
устанавливается в 1 значение tag. <li>Если значение tag равно 1, то образ переносится на 
экран из той области основной памяти, где он сохранялся, - при помощи функции putimage().</ul>
<p>Особенностью функции vary() является необходимость не только изменить размеры 
изображения, но и заново сохранить его битовый образ в основной памяти. При изменении размеров изображения нужно изменять и размеры памяти для его образа.
<p> &nbsp; </p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=a>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=p>&nbsp 6 &nbsp</a></td>
<td><a href="07.htm" class=p>&nbsp 7 &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>