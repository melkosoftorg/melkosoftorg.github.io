<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | Лекция № 45</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=a>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=p>&nbsp 6 &nbsp</a></td>
<td><a href="07.htm" class=p>&nbsp 7 &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr><td class=usual>
<p align=center class=dbi><br>Особенности деструкторов</p>
Конструктор вызывается при создании каждого объекта класса и выполняет все 
необходимые операции как для выделения памяти для данных объекта, так и для ее 
инициализации. <p>Когда объект уничтожается при завершении программы или при выходе 
из области действия определения соответствующего класса, необходимы 
противоположные операции, самая важная из которых - освобождение памяти. Поэтому в 
определение класса явно или по умолчанию включают специальную принадлежащую 
классу функцию - деструктор. <br>Статус доступа деструктора по умолчанию public (то есть 
деструктор доступен во всей области действия определения класса).
<p>В несложных классах деструктор определяется по умолчанию. Например, в классе point 
деструктор явно не определен, и компилятор предполагает, что он имеет вид &nbsp; &nbsp; ~point() { };
<p>В классе spot деструктор явно определен: &nbsp; &nbsp; ~spot() { hide(); tag = 0; delete [] pspot; }
<br>Его действия:<ul>
<li>убрать с экрана изображение пятна, обратившись к функции spot <b>::</b> hide();
<li>установить в нуль признак tag наличия в памяти битового образа пятна;
<li>освободить память, выделенную при создании объекта для битового образа пятна и связанную с конкретным экземпляром указателя pspot.</ul>
Деструкторы не наследуются, поэтому даже при отсутствии в производном классе 
(например, в классе spot) деструктора он не передается из базового (например, из point), а 
формируется компилятором как умалчиваемый со статусом доступа public. <br>Этот 
деструктор вызывает деструкторы базовых классов, что будет выглядеть примерно так:
<p><center>public<b>:</b> &nbsp; &nbsp; ~spot() { ~point(); }</center>
<p>При создании объектов производного класса в первую очередь вызываются конструкторы 
базовых классов, а затем - конструктор, определенный в производном классе.
<br>При разрушении объекта деструкторы вызываются в обратном порядке.
<br>Рассмотрим программу, иллюстрирующую справедливость данного утверждения.
<pre>
	#include&lt;iostream.h>
	#include&lt;conio.h>
	class base
	{	protected:
			int Bval;
		public:
			void set_Bval(int x)
			{ Bval = x; }
			int get_Bval(int x)
			{ return Bval; }
			base(int x = -99);
			~base();
	};
	class sub : public base
	{	protected:
			int Sval;
		public:
			void set_Sval(int x)
			{ Sval = x; }
			int get_Sval(int x)
			{ return Sval; }
			sub(int x = -22);
			~sub();
	};
	base :: base(int x)
	{	Bval = x;
		cout << "\n\tконструктор base";
	}
	base :: ~base()
	{	cout << "\n\tдеструктор base";
	}
	sub :: sub(int x) : base(-1)
	{
		cout << "\n\tконструктор sub";
	}
	sub :: ~sub()
	{
		cout << "\n\tдеструктор sub";
	}
	void main(void)
	{	clrscr();
		cout << "Создаем объект класса sub производного от base";
		sub sub1;
		cout << "\nОбъект класса sub создан";
		cout << "\nКонец программы";
	}
	<i>Результаты выполнения программы:</i>
			Создаем объект класса sub производного от base
				конструктор base
				конструктор sub
			Объект класса sub создан
			Конец программы
				деструктор sub
				деструктор base
</pre>
<p>Вызовы деструкторов для объектов класса и для базовых классов выполняются неявно и 
не требуют никаких действий программиста. Однако вызов деструктора того класса, 
объект которого уничтожается в соответствии с логикой выполнения программы, может 
быть явным, например, случай, когда при создании объекта для него явно выделялась 
память. <br>Примером целесообразности явного вызова деструктора может служить класс 
spot. <p>Программа для работы с объектами класса spot:
<pre>
	#include&lt;graphics.h>
	#include&lt;conio.h>
	#include&lt;stdio.h>
	#include&lt;stdlib.h>
	#include "..\\h\\init.h"
	#include "spot.cpp"	// Определение класса spot
	void main()
	{	
		init();
		{	// В этом блоке создаются и используются объекты класса spot
			spot A(200, 50, 20), D(500, 200, 30);	// Создать невидимое пятно
			A.show(); getch(); D.show(); getch();	// Изобразить пятно
			A.move(50, 60); getch();		// Переместить пятно A
			D.vary(3); getch();			// Изменить размеры пятна D
		}	// При выходе из блока для каждого объекта автоматически
			// вызывается деструктор, освобождающий выделенную память
		closegraph();
	}
</pre>
<p>Отличительная особенность программы - наличие внутреннего блока, что связано с 
присутствием в классе spot деструктора, при выполнении которого вызывается 
компонентная функция hide() - убрать с экрана изображение пятна, использующая 
функции графики. Эти функции могут выполняться только в графическом режиме, то есть 
до выполнения функции closegraph(). <p>Если построить программу без внутреннего блока, 
то деструктор по умолчанию будет вызываться только при окончании программы, когда 
графический режим уже закрыт (после выполнения функции closegraph()) и выполнение 
любых графических функций невозможно, что приведет к ошибке.
<p>Второй способ избежать ошибочной ситуации - явный вызов деструкторов без
добавления вложенного блока:
<pre> 	<b>...</b>
	getch(); D<b>.</b>vary(3);		// Изменить размеры пятна D
	A.spot <b>::</b> ~spot();		// Уничтожить объект A
	D.spot <b>::</b> ~spot();		// Уничтожить объект D
	closegraph();		// Закрыть графический режим
</pre>
<p><b><i>Воспользовавшись рассмотренной программой и внеся в нее незначительные изменения, 
можно получить движущееся изображение предмета более сложной формы.</i></b>
<p>В теле функции main() введем переменные, изменяющие координаты точки и радиус 
круга:<p><center>float x1, y1, r1 = 20;</center>
<br>Заставим изображение перемещаться по диагонали из верхнего левого угла в правый 
нижний угол, а также зададим изменение радиуса:
<pre>
	{	for(x1 = 150, y1 = 50; x1 < 500; x1 += 10, y1 += 5, r1++)
		{
			spot A(x1, y1, r1); A<b>.</b>show(); A<b>.</b>move(x1, y1); delay(100); A<b>.</b>hide();
		} getch();
	} closegraph();
</pre>
Вид изображения, его цвет можно задать в теле функции show() - изобразить пятно на 
экране дисплея - класса &nbsp; class spot <b>:</b> public point (<a href="04.htm#01">файл SPOT.CPP</a>). <br>Изобразим фигуру, 
состоящую из двух эллипсов разных размеров и одного круга. 
<pre>
	setfillstyle(9, 9); ellipse(x, y, 0, 360, rad * 2, rad);			// эллипс 1
	floodfill(x, y, getcolor());					// Закрасить пятно
	setfillstyle(9, 2); ellipse(x, y, 0, 360, rad * 2, rad * .5);		// эллипс 2
	floodfill(x, y, getcolor());
	setfillstyle(7, 12); circle(x, y, rad) ; floodfill(x, y, getcolor());		// Окружность
	floodfill(x, y - 3 * rad / 4, getcolor()); floodfill(x, y + 3 * rad / 4, getcolor());
</pre>
Поскольку размер изображения изменился, необходимо эти изменения отобразить в 
программном коде функции show()
<pre>
	// Запомнить битовый образ в памяти:
	getimage (x - 2 * rad, y - rad, x + 2 * rad, y + rad, pspot);
	// Перенести изображение из памяти на экран:
	putimage(x - 2 * rad, y - rad, pspot, XOR_PUT);
</pre>
В теле функции void hide() - убрать с экрана изображение пятна - класса class spot <b>:</b> public point
<pre>
	// Стереть изображение с экрана:
	putimage(x - 2 * rad, y - rad, pspot, XOR_PUT);
</pre>
В теле функции void vary (float dr) - изменить размер изображения пятна - класса class spot <b>:</b> public point
<pre>
	// Определить размеры битового образа:
	size = imagesize(x - 2 * rad, y - rad, x + 2 * rad, y + rad);
</pre>
В конструкторе класса spot - вызов конструктора базового класса:
<pre>
	// Определить размеры битового образа:
	size = imagesize(xi - 2 * ri, yi - ri, xi + 2 * ri, yi + ri);
</pre>
<p> &nbsp; </p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=a>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=p>&nbsp 6 &nbsp</a></td>
<td><a href="07.htm" class=p>&nbsp 7 &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>