<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>ОП | СР 31_34</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>

<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=a>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=p>&nbsp 6 &nbsp</a></td>
<td><a href="07.htm" class=p>&nbsp 7 &nbsp</a></td>
<td><a href="08.htm" class=p>&nbsp 8 &nbsp</a></td>
<td><a href="09.htm" class=p>&nbsp 9 &nbsp</a></td>
<td><a href="10.htm" class=p>&nbsp 10 &nbsp</a></td>
<td><a href="11.htm" class=p>&nbsp 11 &nbsp</a></td>
<td><a href="12.htm" class=p>&nbsp 12 &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr><td class=usual><p align=center class=dbi><br>Создание файла последовательного доступа</p>
<p>C++ не предписывает никакой структуры файлу. Таким образом, понятия, вроде запись, не существуют в файлах языка C++. Следовательно, программист должен задавать структуру файлов в соответствии с требованиями прикладных программ.
<p>В примере показано, каким образом программист может задавать простую структуру записей в файле.
<br>Программа создает простой файл последовательного доступа, который можно использовать в системе платежных счетов по кредиторской задолженности для помощи в управлении деньгами по этим счетам.
<b><pre>
	// Создание последовательного файла
	#include &lt;iostream.h>
	#include &lt;fstream.h>
	#include &lt;stdlib.h>
	main ( )
	{
		ofstream outClientFile("clients.dat", ios :: out);
		if (! outClientFile)
		{
			cerr << "Файл не может быть открыт" << endl;
			exit(1);
		}
		cout << "Введите счет, имя и баланс." << endl
			<< "Введите EOF для окончания ввода." << endl << "? ";
		int account; char name [10] ; float balance;
		while (cin >> account >> name >> balance)
		{
			outClientFile << account << ' ' << name << ' ' << balance << endl;
			cout << "? ";
		}
		return 0;
	}
	
	<i>Результаты</i></b>	Введите счет, имя и баланс.
			Введите EOF для окончания ввода.
			? 100 Иванов 45.98
			? 200 Петров 23.11
			? 400 Сидоров -9.76
			? 500 Перцев 0.0
			? ^Z
</pre>
<p>Для каждого клиента программа получает номер счета, имя клиента, баланс клиента (сумма, которую клиент должен компании за товары и услуги, полученные в прошлом). Данные, полученные для каждого клиента, образуют запись. Номер счета в этом приложении используется в качестве ключа записи, то есть файл будет создаваться и обрабатываться в соответствии с порядком номеров счетов. Эта программа предполагает, что пользователь вводит записи в последовательности номеров счетов.
<p>В более полную систему платежных счетов может быть включена возможность сортировки, позволяющая пользователю вводить записи в произвольной последовательности - записи будут потом рассортированы и записаны в файл.
<p>В приведенной выше программе файлы открываются путем создания объектов классов потоков ifstream, ofstream или fstream.
<br>Файл должен быть открыт для вывода, так что создается объект ofstream.
<br>Конструктору объекта передаются два аргумента - имя файла и режим открытия файла.
<p>Для объекта ofstream режим открытия файла может быть
<ul><li>или ios :: out - для вывода данных в файл,
<li>или ios :: app - для добавления данных в конец файла (без модификации каких-либо данных, уже имеющихся в файле).
</ul>
<p>Существующие файлы, открываемые режимом ios :: out, усекаются - все данные в файле отбрасываются.
<br>Если какой-то файл еще не существует, тогда создается файл с тем же именем.
<p>Объявление&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>ofstream outClientFile("clients.dat", ios :: out);</b>
<br>создает объект outClientFile класса ofstream, связанный с файлом clients.dat, который открывается для вывода.
<p>Аргументы "clients.dat" и ios&nbsp;::&nbsp;out передаются конструктору класса ofstream, который открывает файл. Это устанавливает "линию связи" с файлом.
<p>По умолчанию объекты класса ofstream открыты для вывода, поэтому для открытия файла clients.dat для вывода может быть использован оператор
<p><b><center>ofstream outClientFile("clients.dat");</center></b></p>
<p>&nbsp;</p>
<p align=center class=dbi>Режимы открытия файлов</p>
<p><center><table  width="90%">
<tr><td width="25%">ios :: арр</td><td width="75%">Записать все данных в конец файла
</td></tr>
<tr><td valign="top">ios :: ate</td><td>Переместиться в конец исходного открытого файла. Данные могут быть записаны в любое место файла.
</td></tr>
<tr><td>ios :: in</td><td>Открыть файл для ввода
</td></tr>
<tr><td>ios :: out</td><td>Открыть файл для вывода
</td></tr>
<tr><td valign="top">ios :: trunc</td><td>Отбрасывать содержимое файла, если он существует (это по умолчанию делается для ios::out).
</td></tr>
<tr><td valign="top">ios :: nocreate</td><td>Если файл не существует, то операция его открытия не выполняется
</td></tr>
<tr><td valign="top">ios :: noreplace</td><td>Если файл существует, то операция его открытия не выполняется
</td></tr>
</table></center>
<p>Объект класса ofstream может быть создан без открытия какого-то файла - в этом случае файл может быть связан с объектом позднее.
<p>Например, объявление &nbsp;&nbsp;<b>ofstream outClientFile;</b>&nbsp;&nbsp;
создает объект &nbsp;outClientFile&nbsp; класса ofstream.
<p>Функция-элемент open класса ofstream открывает файл и связывает его с существующим объектом класса:
&nbsp;&nbsp;&nbsp;<b>outClientFile.open("clients.dat", ios&nbsp;::&nbsp;out);</b>
<p>После создания объекта класса ofstream и попытки открыть его программа проверяет, была ли операция открытия файла успешной.
<p>Фрагмент программы
<pre><b>
		if (!outClientFile)
		{
			cerr << "Файл не может быть открыт" << endl;
			exit (1);
		}
</b></pre>
<p>использует перегруженную функцию-операцию operator - элемент класса ios, для определения того, успешно ли открылся файл.
<br>Условие возвращает ненулевое значение (true), если при выполнении операции open для потока устанавливаются или failbit - при вводе данных неправильного типа - или badbit - при неуспешном завершении операции.
<p>Некоторые возможные ошибки являются следствием попытки
<ul><li>открыть для чтения несуществующий файл,
<li>открыть файл для чтения без разрешения,
<li>открытия файла для записи, когда на диске нет свободного места.
</ul>
<p>Когда условие указывает, что попытка открытия файла была безуспешной, выводится сообщение "Файл не может быть открыт" и вызывается функция exit для завершения программы.
<br>Аргумент функции exit возвращается среде окружения, из которой программа была вызвана. Аргумент 0 показывает, что программа завершается нормально, а любое другое значение, указывает среде окружения, что программа прекратила выполнение из-за ошибки.
<br>Значение, возвращаемое функцией exit, используется средой окружения (чаще всего операционной системой) для соответствующей реакции на ошибку.
<p>Другая перегруженная функция-операция&nbsp;&nbsp;&nbsp;<b>operator void*</b>&nbsp;&nbsp;- элемент класса ios, превращает поток в указатель, так что можно проверить, является ли он 0 (нулевым указателем), или имеет ненулевое значение (любое другое значение указателя).
<p>Если для потока устанавливаются failbit или badbit, то возвращается 0 (false).
<br>Условие в заголовке оператора while автоматически вызывает функцию-элемент operator&nbsp;void*:
&nbsp;&nbsp;&nbsp;<b>while (cin >> account >> name >> balance)</b>
<p>Это условие истинно, пока для cin не устанавливаются ни failbit, ни badbit. Ввод маркера конца файла устанавливает failbit для cin. Функция operator void* может быть использована для проверки конца файла в объекте ввода вместо явного вызова функции-элемента eof.
<p>Если файл открылся успешно, то программа начинает обрабатывать данные. Следующий оператор запрашивает пользователя о вводе различных полей каждой записи или информацию о конце файла, если ввод данных завершен:
<pre><b>
		cout << "Введите счет, имя и баланс." << endl
			<< "Введите EOF - для окончания ввода." << endl << " ? " ;

</b></pre>
<p align=center class=dbi>Список комбинаций клавиш для ввода признака конца файла<br>в различных операционных системах</p>
<p><center><table  width="50%">
<tr><td width="70%">UNIX</td><td width="30%">&lt;ctrl> + d
</td></tr>
<tr><td>IBM PC и совместимые</td><td>&lt;ctrl> + z
</td></tr>
<tr><td>Macintosh</td><td>&lt;ctrl> + d
</td></tr>
<tr><td>VAX (VMS)</td><td>&lt;ctrl> + z
</td></tr>
</table></center>
<p>Строка&nbsp;&nbsp;&nbsp;<b>while (cin >> account >> name >> balance)</b>
&nbsp;&nbsp;&nbsp;вводит каждый набор данных и определяет, не введен ли признак конца файла.
<br>Когда будет достигнут конец файла или вводятся неверные данные, операция извлечь из потока >> возвращает 0 (обычно операция извлечь из потока возвращает cin) и оператор while завершает свою работу.
<br>Пользователь должен вводить признак конца файла, чтобы сообщить программе о том, что ввод необходимых данных завершен.
<br>Оператор while продолжает выполнение цикла до тех пор, пока не будет введен маркер конца файла.
<p>Оператор&nbsp;&nbsp;&nbsp;<b>outClientFile << account << " " << name << " " << balance << endl;</b>
<br>записывает набор данных в текстовый файл "clients.dat", который может быть прочитан с помощью любого текстового редактора, используя операцию поместить в поток << и объект outClientFile, связанный с файлом в начале программы.
<p>Как только вводится признак конца файла, функция main завершается. Это приводит к тому, что объект outClientFile уничтожается вызовом его деструктора, который закрывает файл clients.dat.
<p>Объект ofstream может быть явным образом закрыт программистом с помощью функции-элемента close:
&nbsp;&nbsp;&nbsp;<b>outClientFile.close();</b>
<p><table align=center width=90% border=1 cellpadding=5 cellspacing=10>
<tr><td class=rule><b>Совет по повышению эффективности</b>
<br>Закрывайте явным образом каждый файл, как только станет понятным, что программа не будет обращаться к этому файлу снова.
<br>Это поможет сократить используемые ресурсы, которые программа продолжает потреблять длительное время после того, когда ей уже не надо обращаться к данному файлу.
<br>Этот прием делает программу также более ясной.
</td></tr>
</table>
<p>&nbsp;</p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=a>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=p>&nbsp 6 &nbsp</a></td>
<td><a href="07.htm" class=p>&nbsp 7 &nbsp</a></td>
<td><a href="08.htm" class=p>&nbsp 8 &nbsp</a></td>
<td><a href="09.htm" class=p>&nbsp 9 &nbsp</a></td>
<td><a href="10.htm" class=p>&nbsp 10 &nbsp</a></td>
<td><a href="11.htm" class=p>&nbsp 11 &nbsp</a></td>
<td><a href="12.htm" class=p>&nbsp 12 &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>