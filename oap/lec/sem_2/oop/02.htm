<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>Обзорная лекция | ООП</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>
<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=a>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=p>&nbsp 6 &nbsp</a></td>
<td><a href="07.htm" class=p>&nbsp 7 &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr>
<td class=usual>
<p align=center class=dbi><br>Компоненты класса</p>
<p>При определении класса в его теле описываются и (или) определяются данные класса и 
принадлежащие ему функции.
<p align=center class=dbi>Компонентные данные</p>
<p>Определение данных класса внешне аналогично обычному 
описанию объектов базовых и производных типов. Класс полностью сохраняет все 
особенности структурных типов, поэтому данные класса могут быть названы его 
элементами. <br>Элементы класса могут быть как базовых, так и производных типов, то есть 
компонентными данными служат переменные, массивы, указатели и так далее. <br>Как 
обычно, описания элементов одного типа могут быть объединены в одном операторе.
Но при описании элементов класса не допускается их инициализация, так как при его 
определении еще не существует участков памяти, соответствующих его компонентным 
данным. <br>Память выделяется не для класса, а только для объектов класса. 
<br>Для инициализации компонентных данных объектов должен использоваться автоматический 
или явно вызываемый конструктор соответствующего класса.
<p align=center class=dbi><br>Компонентные функции</p>
Компонентная функция <b><i>должна быть обязательно описана в 
теле класса</i></b>. В отличие от обычных (глобальных) функций компонентная функция имеет 
доступ ко всем компонентам класса (с любым статусом доступа).<br>Функция - компонент 
класса имеет ту же область видимости, что и класс, к которому она относится.
<br>Если определение компонентной функции полностью размещено в теле класса, то эта функция по умолчанию считается <a href="../s05/05.htm">подставляемой (inline)</a>. 
<pre>
	#include&lt;conio.h>
	#include&lt;iostream.h>
	// определение класса
	class smallobj
	{
		private:   int somedata;	// данные класса
		public:	// методы класса - inline функции 
			void setdata(int d)	// изменить значение поля
			{ somedata = d; }
			void showdata()		// отобразить значение поля
			{ cout << "Значение поля " << somedata << endl; }
	};
	void main()
	{
		clrscr();
		// определение 2-х объектов класса
		smallobj s1, s2;   
		s1.setdata(1066);      // вызов метода setdata
		s2.setdata(1776);
		s1.showdata();          // вызов метода showdata
		s2.showdata();
		getch();
	}
	Результаты работы программы
		Значение поля 1066
		Значение поля 1776
</pre>
<p>При внешнем определении компонентной функции в теле класса помещается <b>прототип:</b> 
<p><center>тип имя_функции(спецификация_и_инициализация_параметров);</center>
<p><b>Вне тела класса компонентная функция определяется:</b>
<p><center>тип имя_класса :: имя_функции(спецификация_формальных_параметров)
<br>{ тело_принадлежащей_классу_функции }
</center>
<p><b>Операция ::</b> - уточнение области действия
<p>Для рассмотренного примера в теле класса функции будут описаны
<pre>
		public:	void setdata(int d);
				void showdata();
</pre>
<p>Внешнее определение функций класса
<pre>
		void smallobj :: setdata(int d)
		{	somedata = d;
		}
		void smallobj :: showdata() 
		{	cout << "Значение поля " << somedata << endl;
		}
</pre>
<p><b>Квалифицированное имя компонентной функции</b>
<p><center>имя_класса :: имя_компонентной_функции</center>
<br>привязывает функцию к классу и позволяет в ее теле использовать любые данные класса (объектов класса) и любые принадлежащие классу функции, как собственные private, так и защищенные protected.
<p>Для рассмотренных функций квалифицированные имена это
<p><center>smallobj :: setdata
<br>smallobj :: showdata</center></p>
<p align=center class=dbi><br>Конструктор класса</p>
<p>Конструктор - компонентная функция, созданная для инициализации объектов.
<ul type="disc">
<li>Имя конструктора должно совпадать с именем класса.
<li>Для конструктора не определяется тип возвращаемого значения, даже тип void недопустим,
<li>Конструктор вызывается при создании объекта, при объявлении объекта
<li>Для глобальных объектов конструктор объекта вызывается тогда, когда начинается выполнение программы.
<li>Для локальных объектов конструктор вызывается всякий раз при выполнении инструкции объявления переменной. 
<li>В классе может быть несколько конструкторов (перегрузка), но только один с умалчиваемыми значениями параметров.
<li>Нельзя получить адрес конструктора.
<li>Параметром конструктора не может быть его собственный класс, но может быть ссылка на него. 
<li>Конструктор нельзя вызывать как обычную компонентную функцию.
</ul>
<p><b>Определение конструктора в теле класса:</b>
<pre>
	имя_класса (список_формальных_параметров)
	{
		операторы_тела_конструктора
	} 
</pre>
<p><b>При определениие конструктора вне тела класса</b> в теле класса разместить описание конструктора
<p><center>имя_класса (список_формальных_параметров);</center>
<br>Можно задать значения параметров по умолчании для начальной инициализации
 данных создаваемого объекта вида:	point Z;
<pre>
	class point
	{
		private:	// Собственные компоненты класса
				int x, y, c;
		public:	// Общедоступные компоненты класса
				point(int a = 50, int b = 20, int d = 3);
	};
</pre>
<p><b>Вне тела класса одним из способов определить конструктор</b>, обязательно указав какому классу он принадлежит.
<p>ИЛИ
<pre>
	имя_класса :: имя_класса (список_формальных_параметров)
	{
		операторы_тела_конструктора
	} 
</pre>
<p>ИЛИ
<pre>
	имя_класса (список_параметров) : список_инициализаторов_компонентных_данных
	{ тело_конструктора }
</pre>
<p>Каждый инициализатор списка относится к компоненту и имеет вид: 
<p><center>имя_компонента_данных (выражение)</center>
<p><b>Например, для созданного класса point</b>
<p><table align="center" width="80%">
<tr valign="top"><td width="40%">
<pre>
point :: point(int a, int b, int d)
{
    x = a; y = b; c = d;
}
</pre>
</td><td>ИЛИ</td><td width="40%">
<pre>
point :: point(int a, int b, int d) : x(a), y(b), c(d)
{ }
</pre>
</td></tr>
</table>
<p><b>Явный вызов конструктора</b>
<ul type="disc">
<li>При непустом списке фактических параметров. Предусматривает вызов конструктора при определении нового объекта данного класса
<p><center>имя_класса имя_объекта(фактические_параметры_конструктора);</center>
<p>// Определены два объекта D и Q с заданными параметрами 
<br>// и объект G с параметрами по умолчании x = 50, y = 20, c = 3
<br>point D(60, 87, 9), Q(90, 100, 15), G;	

<li>Создание объекта, не имеющего имени. 
Созданный безымянный объект может использоваться в тех выражениях, где допустимо использование объекта данного класса
<p><center>имя_класса (фактические_параметры_конструктора);</center>
<p>// Создан безымянный объект, в котором x = 100, y = 200, c = 4 и скопирован в объект S 
<br>point S = point(100, 200, 4);
</pre>
</ul>
<p>Если создан класс AZ с собственными компонентными данными ii, ee, cc
<pre>
	class AZ
	{    int ii;   float ее;  сhar сс;
	     public:   AZ(int in, float en, char cn) : ii(5), ee(ii * en + in), cc(cn) { }
	         ...
	};
	AZ A(2, 3.0, 'd');		Создается именованный объект A с компонентами
						A.ii=5,		A.ее = 5 * 3 + 2 = 17,		A.cc = 'd'
	AZ Х = AZ(0, 2.0, 'z');	Создается безымянный объект, в котором
						ii = 5,	ее = 10,	cc = 'z', и копируется в объект Х
</pre>
<p align=center class=dbi><br>Деструктор классов</p>
<p>Противоположные действия по отношению к конструктору вызывают функции деструкторы классов - destructor - разрушители объектов.
<p><b>Определение деструктора в теле класса:</b>
<pre>
	~имя_класса()
	{
		операторы_тела деструктора
	} 
</pre>
<p>Для созданного класса point деструктор
<pre>
	~point()
	{ }
</pre>
<ul type="disc">
<li>У деструктора не может быть параметров (даже типа void).
<li>Деструктор не имеет возвращаемого значения (даже типа void).
<li>Вызов деструктора выполняется неявно, автоматически, как только объект класса уничтожается. 
<li>Деструктор класса вызывается при удалении объекта.
<ul type="square">
<li>Локальные объекты удаляются тогда, когда они выходят из области видимости.
<li>Глобальные объекты удаляются при завершении программы.
</ul></ul>
<p align=center class=dbi><br>Обращение к компонентам класса</p>
Как только объект класса определен, появляется возможность обращаться к его компонентам.
<p>Существуют различия между обращениями к компонентным данным класса из 
принадлежащих ему функций и из других частей программы.
<p><b><i>Принадлежащие классу функции, имеют полный доступ к его данным</i></b>, то есть для 
обращения к элементу класса из тела компонентной функции достаточно использовать 
только имя элемента.
<p><b>Для доступа к компонентным данным из операторов, выполняемых вне определения 
класса</b>, непосредственное использование имен элементов недопустимо. <br>Для обращения к 
элементу объекта нужно использовать операции выбора компонентов класса <br>(<b>.</b> или <b>-></b> )
<ul><li><b><i>с помощью "квалифицированных" имен</i></b>, каждое из которых имеет формат:
<p><center>имя_объекта.имя_класса <b>::</b> имя_компонента</center>
<p>Имя класса с операцией уточнения области действия <b>::</b> обычно может быть опущено, и 
чаще всего для доступа к данным конкретного объекта заданного класса (как и в 
случае структур) используется уточненное имя:<p><center>имя_объекта<b>.</b>имя_элемента</center>
<p>При этом возможности те же, что и при работе с элементами структур. <br>Например, 
можно явно присвоить значения элементам объектов класса example: <p><center>X1<b>.</b>a = dim[3]<b>.</b>a = 2;</center>
<br>Уточненное имя принадлежащей классу (то есть компонентной) функции:
<p><center>имя_объекта<b>.</b>обращение_к_компонентной_функции</center>
<br>обеспечивает вызов компонентной функции класса для обработки данных именно того 
объекта, имя которого использовано в уточненном имени. 
<li>другой способ доступа к элементам объекта некоторого класса предусматривает 
<b><i>явное использование указателя на объект класса и операции косвенного выбора 
компонента</i></b>:
<p><center>указатель_на_объект_класса <b>-></b> имя_элемента</center>
<br>Указатель на объект класса позволяет вызывать принадлежащие классу функции для 
обработки данных того объекта, который адресуется указателем. Формат вызова 
функции:
<p><center>указатель_на_объект_класса -> обращение_к_компонентной_функции</center>
<p>Следующая программа демонстрирует порядок выполнения компонентных функций и полученные  результаты.
<p><center><img src="26_cl.gif" alt="Компонентные функции" ismap></center></p>
<p><b>Пример.</b> Создать класс Counter для получения текущего значения измеряемой величины.
<br>В конструкторе начальное значение по умолчании задать равным 0.
<br>Создать объекты и указатели на объекты класса Counter.
<pre>
	// Объект - счетчик
	#include&lt;iostream.h>
	#include&lt;conio.h>
	class Counter
	{
		private:
			unsigned int count;	// счетчик
		public:
			Counter() : count(0)	// конструктор
			{ /* пустое тело */ }
			void inc_count()		// нарастить count
			{ count++; }
			int get_count()		// получить count
			{ return count; }
	};
	void main()
	{
		clrscr();
		Counter c1, c2;		// определение и инициализация объектов
		cout << "\nc1 = " << c1.get_count();		// вывод
		cout << "\nc2 = " << c2.get_count();
		c1.inc_count();	// инкремент c1
		c2.inc_count();	// инкремент c2
		c2.inc_count();	// инкремент c2
		cout << "\nc1 = " << c1.get_count();		// вывод
		cout << "\nc2 = " << c2.get_count();

		cout << endl << "\nУказатели\n";
		Counter *pc1 = &c1, *pc2 = &c2;		// указатели
		cout << "\npc1 = " << pc1 -> get_count();	// вывод
		cout << "\npc2 = " << pc2 -> get_count();
		pc1 -> inc_count();	// инкремент pc1
		pc2 -> inc_count();	// инкремент pc2
		pc2 -> inc_count();	// инкремент pc2
		cout << "\npc1 = " << pc1 -> get_count();	// вывод
		cout << "\npc2 = " << pc2 -> get_count();
		getch();
	}
	<i>Результаты выполнения программы:</i>
			Объекты
			c1 = 0
			c2 = 0
			c1 = 1
			c2 = 2
			Указатели
			pc1 = 1
			pc2 = 2
			pc1 = 2
			pc2 = 4
</pre>
<p><b>Пример.</b> Создать класс part с собственными (private) компонентными данными: номер изделия, номер детали, стоимость детали.
<br>Предусмотреть методы интерфейса (public): изменить значения величин, вывести значения.
<p>В программе показано создание класса part с определением компонентных функций двумя способами: в теле класса и вне тела класса.
<pre>
	// детали изделия в качестве объектов 
	#include&lt;iostream.h&gt; 
	#include&lt;conio.h&gt;
/*
	// Класс part с определением функций в теле класса
	class part   
	{ 
		private: int modelnum;		// номер изделия
			 int partnum;			// номер детали
			 float cost;			// стоимость детали
		public:	// определения функций в теле класса
			// конструктор - для начальной инициализации
			part(int m = 5, int p = 6, float st = 33.22)
			{
				modelnum = m;
				partnum = p;
				cost = st;
			}
			// изменение значений
			void setpart(int mn, int pn, float c)
			{
				modelnum = mn;
				partnum = pn;
				cost = c;
			}
			// вывод данных
			void showpart()
			{
				cout << "модель " << modelnum;
				cout << ", деталь " << partnum;
				cout << ", стоимость $" << cost << endl;
			}
			// деструктор
			~part()
			{}
	};
*/
	// Класс part с определением функций вне класса
	class part
	{
		private: int modelnum;	// номер изделия
			 int partnum;	// номер детали
			 float cost;	// стоимость детали
		public:	// описания функций
			part(int m = 5, int p = 6, float st = 33.22);
			void setpart(int mn, int pn, float c);
			void showpart();
			// деструктор
			~part();
	};
	// определения функций вне класса
	// Конструктор
	part :: part(int m, int p, float st)
	{
		modelnum = m;
		partnum = p;
		cost = st;
	}
	// Изменение значений
	void part :: setpart(int mn, int pn, float c)
	{
		modelnum = mn;
		partnum = pn;
		cost = c;
	}
	// Вывод данных
	void part :: showpart()
	{
		cout << "модель " << modelnum;
		cout << ", деталь " << partnum;
		cout << ", стоимость $" << cost << endl;
	}
	// деструктор
	part :: ~part()
	{}
	void main()
	{
		clrscr();
		// определение объекта part0 класса part
		part part0;
		// вызов компонентной функции для объекта part0
		part0.showpart();		// вывод значений параметров по умолчании
	
		// определение объекта part1 класса part, значения для конструктора
		part part1(1111, 222, 896.56);
		// вызов компонентных функций для объекта part1
		part1.showpart();				// вывод значений, переданных в конструктор
		part1.setpart(6244, 373, 217.55);	// изменить значения
		part1.showpart();				// вывод измененных значений
		getch();
	}
	<i>Результаты выполнения программы:</i>
			модель 5, деталь 6, стоимость $33.220001
			модель 1111, деталь 222, стоимость $896.559998
			модель 6244, деталь 373, стоимость $217.550003
</pre>
<p align=center class=dbi><br>Статические компоненты класса</p>
<ul type="disc">
<li>Статические компонентные данные
<p><center>static тип_компонента имя_компонента;</center>
<li>Статические компонентные функции (методы) - описание
<p><center>static тип_значения имя_функции(параметры);</center>
</ul>
<p> - Определяются с использованием ключевого слова static     
<br> - Используются для совместного доступа и обмена информацией между всеми объектами класса
<br> - К полям и методам static можно обращаться даже при отсутствии объектов класса, используя операцию :: уточнения области действия
<p align=center class=dbi>Статические компонентные данные класса</p>
<ul type="disc">
<li>Память, соответствующая типу каждого поля, резервируется для каждого объекта, декларированного где-либо в программе. Только поля static относятся к классу вообще и доступны всем объектам данного класса одновременно, как глобальные переменные.
<li>Статическое поле видимо только внутри класса, но время его жизни совпадает с временем жизни программы.
<li>Статическая переменная класса используется для хранения данных, совместно используемых объектами класса.
<li>Доступ к статическому компоненту возможен после размещенной в глобальной области программы его инициализации.
</ul>
<p><b>Инициализация и обращение</b>
<p>Инициализация в глобальной области: 
<br><center>тип имя_класса :: имя_компонента инициализатор;</center>
<br>При инициализации под статический компонент выделяется память и ему присваивается значение.
<br>Обращаться к статическому компоненту можно до создания объекта данного класса:
<br><center>имя_класса :: имя_компонента</center>
<br>И после создания объекта:
<br><center>имя_объекта.имя_компонента</center>
<br>Либо
<br><center>имя_объекта.имя_класса :: имя_компонента</center>
<p><b>Пример.</b> Показать изменение счетчика static int count после создания каждого объекта класса foo.
<pre>
	#include&lt;iostream.h&gt;
	#include&lt;conio.h&gt;
	class foo
	{
		private:	// общее поле для всех объектов
				static int count;
		public:	// при создании объекта увеличить на 1
				foo()
				{	count++; 
				}
				// возвращает значение count
				int getcount()
				{	return count; 
				}
	};
	// определение и инициализация count
	int foo::count = 0;
	void main()
	{
		clrscr();
		cout << "Создание объектов и вывод счетчика после каждого" << endl;
		foo f1;
		cout << "f1 объектов " << f1.getcount() << endl;
		foo f2;
		cout << "f2 объектов " << f2.getcount() << endl;
		foo f3;
		cout << "f3 объектов " << f3.getcount() << endl << endl;
		cout << "Теперь каждый объект видит одно и то же значение" << endl;
		cout << "f1 объектов " << f1.getcount() << endl;
		cout << "f2 объектов " << f2.getcount() << endl;
		cout << "f3 объектов " << f3.getcount() << endl;
		getch();
	}
	<i>Результаты выполнения программы:</i>
			Создание объектов и вывод счетчика после каждого
			f1 объектов 1
			f2 объектов 2
			f3 объектов 3
		
			Теперь каждый объект видит одно и то же значение
			f1 объектов 3
			f2 объектов 3
			f3 объектов 3
</pre>
<p align=center class=dbi>Статические компонентные функции класса</p>
<p>Статическая компонентная функция сохраняет все основные особенности обычных (нестатических) компонентных функций.
<p>К функции можно обращаться:
<ul type="disc">
<li>используя имя уже существующего объекта класса
<br><center>имя_объекта.обращение_к_функции</center>
<li>либо указатель на такой объект
<br><center>указатель_на_объект -> обращение_к_функции</center>
</ul>
<p>Дополнительно статическую компонентную функцию можно вызвать, используя квалифицированное имя: 
<br><center>имя_класса :: имя_статической функции</center>

<p><b>Данные и методы</b>
<pre>
	#include&lt;iostream.h&gt;
	#include&lt;conio.h&gt;
	class Sob
	{	private:
			static int c;
			int b;
		public:
			void set(int);			// изменяет объекты
			int get() const;		// не изменяет объекты
			static void pass(int);	// инициализатор
			void show(char);		// показать поля
	};
	// Инициализатор поля private int b объекта
	void Sob :: set(int d)
	{	this -> b = d;
	}
	int Sob :: get() const
	{	return b;
	}
	// Инициализатор static int c
	void Sob :: pass(int n)
	{	c = n;
	}
	void Sob :: show(char ch)
	{	cout << "Объект " << ch << ": "<< "\tb = " << b << "\tc = " << c << endl;
	}
	// определение static int c
	int Sob :: c;
	void main()
	{	clrscr();
		// Создание объектов 
		Sob x, y;
		x.set(5);				// Инициализация поля b объекта x
		// Вызов static-метода pass
		Sob :: pass(x.get());	// Инициализация c значением поля b объекта x
		y.set(10);				// Инициализация поля b объекта y

		// Вывод значений компонентных данных
		x.show('x');			// объекта x
		y.show('y');			// объекта y

		Sob :: pass(y.get());	// Инициализация c значением поля b объекта y
		y.show('y');			// Вывод значений компонентных данных объекта y
		getch();
	}
	<i>Результаты выполнения программы:</i>
			Объект x:	b = 5		c = 5
			Объект y:	b = 10		c = 5
			Объект y:	b = 10		c = 10
</pre>
<p><b>Указатель this</b>
<p>Когда функция, принадлежащая классу, вызывается для обработки данных конкретного объекта, этой функции автоматически и неявно передается указатель с фиксированным именем this на тот объект, для которого функция вызвана.
<br>Указатель  this незаметно для программиста определен в каждой функции класса:
<p><center>имя_класса * const this = адрес_объекта;</center>
<p>Указатель this:
<ul type="disc">
<li>является дополнительным (скрытым) параметром каждой нестатической компонентной функции,
<li>при входе в тело принадлежащей классу функции инициализируется значением адреса того объекта, для которого вызвана функция,
<li>объект, который адресуется указателем this, становится доступным внутри принадлежащей классу функции именно с помощью указателя this.
</ul>
<p> &nbsp; </p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=a>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=p>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=p>&nbsp 6 &nbsp</a></td>
<td><a href="07.htm" class=p>&nbsp 7 &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>