<html>
<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<title>Обзорная лекция | ООП</title>
<link rel=stylesheet type=text/css href=../../../css/lec.css>
</head>

<body>
<a name=#start></a>
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=a>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=p>&nbsp 6 &nbsp</a></td>
<td><a href="07.htm" class=p>&nbsp 7 &nbsp</a></td>
</tr>
</table>
<!-- -------Inside table------- -->
<table width=98% border=0 cellpadding=5 cellspacing=0>
<tr>
<td class=usual>
<p align=center class=dbi><br>Наследование классов</p>
<p><b>Наследование (inheritance)</b> - возможность создания новых классов на основе существующих классов.
<p>Проектируя сложный класс, необходимо:
<ul type="disc">
<li>решить, какими наиболее общими свойствами должны обладать его объекты,
<li>проверить, нет ли похожего на него готового класса,
<li>продумать план вновь разрабатываемого класса,
<li>перейти к постепенной детализации, создавая на основе уже построенных классов новые классы, которые наследуют (inherit) от них свойства и поведение (члены-данные и функции-члены), приобретая в то же время новые качества.
</ul>
<p><b>Базовый класс</b> -  класс, на основе которого строится другой класс, класс, который наследуется другим классом.
<p><b>Производный класс (подкласс)</b> - построенный класс.
<p><img src=inherit.gif  align="left" HSPACE=30 VSPACE=5 alt="Наследование">
<p><b><i>Человек.</i></b> Мир населен людьми. Любого человека можно описать набором характеристик: фамилию и имя, возраст, страна проживания, ...
<p><b><i>Работник.</i></b> Не все люди работают в фирмах, однако все, кто работает в них, являются людьми. Работник фирмы обладает всеми перечисленными выше характеристиками человека, но при этом у него
есть дополнительные свойства: название фирмы, где он работает, размер заработной платы, ...
<p><b><i>Студент.</i></b> Студент - это не работник фирмы, но тоже человек. У него также есть все описанные выше характеристики человека, плюс некоторые дополнительные:
учебное заведение и специальность, номер студенческого билета, ...
<p>Работник и студент наследуют свойства человека. Поэтому, создавая класс людей вообще, работников фирм и студентов, можно сделать несколько выводов:
<ul type="disc">
<li><i>Человек</i> считается базовым классом.
<li><i>Работник</i> и <i>Студент</i> являются подклассами, то есть производными классами.
<li>Между классами <i>Работник</i> и <i>Студент</i> нет взаимосвязи, хотя оба происходят от одного базового класса <i>Человек</i>.
</ul>
<p><b>Производные классы</b> "получают наследство" - данные и методы своих базовых классов - и, кроме того, могут пополняться собственными компонентами (данными и собственными методами).
<p>Для задания шаблона производного класса используется следующий синтаксис:
<pre>
	class имя_производного_класса : спецификатор_доступа имя_базового_класса
	{
		тело_производного_класса
	} объекты_производного_класса (через запятую);
</pre>
<p><b>Спецификатор доступа</b> определяет то, как элементы базового класса наследуются производным классом.
<p>Если спецификатором доступа наследуемого базового класса является ключевое слово

<ul type="disc">
<li><i>public</i>, то все открытые члены базового класса остаются открытыми и в производном.
<li><i>private</i>, то все открытые члены базового класса в производном классе становятся закрытыми.
<li><i>protected</i> эквивалентен спецификатору private с единственным исключением:
<ul type="square">
<li>защищенные члены базового класса доступны для членов всех производных классов этого базового класса,
<li>вне базового или производных классов защищенные члены класса недоступны.
</ul></ul>
<p>Если спецификатор доступа не указан и базовый класс определен с ключевым словом 
<ul type="disc">
<li><i>class</i>, то базовый класс по умолчанию наследуется как закрытый. 
<li><i>struct</i>, то базовый класс по умолчанию наследуется как открытый. 
</ul>
<p>При создании объектов производного класса в первую очередь вызываются конструкторы 
базовых классов, а затем - конструктор, определенный в производном классе.
<br>При разрушении объекта деструкторы вызываются в обратном порядке.
<p><b>Пример.</b> Программа демонстрирует создание базового и производного классов.
<br>При создании объекта базового класса инициализировать поля базового класса: Имя, Должность, Оклад.
<br>При создании объекта производного класса инициализировать поля базового и
 производного классов: Имя, Должность, Оклад, Премия, Машина, Фондовый опцион.
<pre>
	#include&lt;conio.h&gt;
	#include&lt;iostream.h&gt;
	#include&lt;string.h&gt;
	// Базовый класс
	class emp
	{	private:
			char name [64];	// Имя
			char pos[64];		// Должность
			float sal;			// Оклад
		public:
			emp(char *, char *, float);
			void show_emp(void);
			~emp()
        		{	cout << "\n\tДеструктор базового класса";
			}
	};
	// Конструктор базового класса
	emp :: emp(char *name, char *pos, float sal)
	{
		cout << "\n\tКонструктор базового класса";
		strcpy(emp :: name, name);
		strcpy(emp :: pos, pos);
		emp :: sal = sal;
	}
	// Вывод компонентных данных базового класса
	void emp :: show_emp(void)
	{
		cout << "\n\tИмя: " << name;
		cout << "\n\tДолжность: " << pos;
		cout << "\n\tОклад: " << sal << endl;
	}
	// Производный класс
	class man : public emp
	{	private:
			float an_bon;		// Премия
			char com_car[64];	// Машина
			int st_op;		// Фондовый опцион
		public:
			man(char *, char *, char *, float, float, int);
			void show_man(void);
			~man()
			{	cout << "\n\tДеструктор производного класса";
			}
	};
	// Конструктор производного класса
	man :: man(char *name, char *pos, char *com_car, float sal, float bon, int st_op) : emp(name, pos, sal)
	{
		cout << "\n\tКонструктор производного класса";
		strcpy(man :: com_car, com_car);
		man :: an_bon = bon ;
		man :: st_op = st_op;
	}
	// Вывод компонентных данных производного класса
	void man :: show_man(void)
	{       // вызов функции базового класса
		show_emp();
		cout << "\n\tМашина фирмы: " << com_car;
		cout << "\n\tЕжегодная премия: " << an_bon;
		cout << "\n\tФондовый опцион: " << st_op;
	}
	void main(void)
	{
		clrscr();
		cout << "Создание объекта базового класса";
		emp worker("Джон Дой", "Программист", 35000);
		worker.show_emp();
	
		cout << "\nСоздание объекта производного класса";
		man boss("Джейн Дой", "Вице-президент ", "Lexus", 50000.0, 5000, 1000);
		boss.show_man();
		getch();
	}
	<i>Результаты выполнения программы:</i>
		Создание объекта базового класса
			Конструктор базового класса
			Имя: Джон Дой
			Должность: Программист
        		Оклад: 35000

		Создание объекта производного класса
			Конструктор базового класса
			Конструктор производного класса
			Имя: Джейн Дой
			Должность: Вице-президент
			Оклад: 50000

			Машина фирмы: Lexus
			Ежегодная премия: 5000
			Фондовый опцион: 1000
			Деструктор производного класса
			Деструктор базового класса
			Деструктор базового класса
</pre>


<p><b>Необходимо знать</b>
<ul type="disc">
<li>Наследование - способность производить новый класс из существующего базового класса. 
<li>Производный класс - это новый класс, базовый класс - существующий класс. 
<li>Когда порождаете класс из базового класса, производный класс наследует элементы базового класса. 
<li>Для порождения класса из базового начинайте определение производного класса ключевым словом class, за которым следует имя класса, двоеточие и имя базового класса,  например, class dalmatian : dog. 
<li>Когда порождаете класс из базового класса, производный класс может обращаться к общим элементам базового класса, как будто эти элементы определены внутри самого производного класса.
<li>Для доступа к частным данным базового класса производный класс должен использовать интерфейсные функции базового класса. 
<li>Внутри конструктора производного класса программа должна вызвать конструктор базового класса, указывая двоеточие, имя конструктора базового класса и соответствующие параметры сразу же после заголовка конструктора производного класса. 
<li>Чтобы обеспечить производным классам прямой доступ к определенным элементам базового класса, в то же время защищая эти элементы от оставшейся части программы, C++ обеспечивает защищенные (protected) элементы класса.
<li>Производный класс может обращаться к защищенным элементам базового класса, как будто они являются общими. Однако для оставшейся части программы защищенные элементы эквивалентны частным. 
<li>Если в производном и базовом классе есть элементы с одинаковым именем, то внутри функций производного класса C++ будет использовать элементы производного класса.
<li>Если функциям производного класса необходимо обратиться к элементу базового класса, надо использовать оператор глобального разрешения, например, base&nbsp;class&nbsp;::&nbsp;member.
</ul>
<p> &nbsp; </p>
</td></tr>
</table>
<!-- -------End of Inside table------- -->
<table class=pages align=center border=0 cellpadding=0 cellspacing=0>
<tr colspan=5>
<td>&nbsp&nbsp<a href="../../plan_2.htm" class=p>Календарно-тематический план</a>&nbsp&nbsp</td>
<td><a href="index.htm" class=p>&nbsp План лекции &nbsp</a></td>
<td><a href="01.htm" class=p>&nbsp 1 &nbsp</a></td>
<td><a href="02.htm" class=p>&nbsp 2 &nbsp</a></td>
<td><a href="03.htm" class=p>&nbsp 3 &nbsp</a></td>
<td><a href="04.htm" class=a>&nbsp 4 &nbsp</a></td>
<td><a href="05.htm" class=p>&nbsp 5 &nbsp</a></td>
<td><a href="06.htm" class=p>&nbsp 6 &nbsp</a></td>
<td><a href="07.htm" class=p>&nbsp 7 &nbsp</a></td>
</tr>
</table>
<a name=#end></a>
</body>
</html>